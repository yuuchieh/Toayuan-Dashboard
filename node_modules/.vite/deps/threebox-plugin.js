import {
  __commonJS
} from "./chunk-CF3WPAMV.js";

// node_modules/threebox-plugin/src/three.js
var require_three = __commonJS({
  "node_modules/threebox-plugin/src/three.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).THREE = {});
    }(exports, function(t) {
      "use strict";
      const e = "132", n = 100, i = 300, r = 301, s = 302, a = 303, o2 = 304, l = 306, c = 307, h = 1e3, u = 1001, d = 1002, p = 1003, m = 1004, f = 1005, g = 1006, v = 1007, y = 1008, x = 1009, _ = 1012, b = 1014, M = 1015, w = 1016, S = 1020, T = 1022, E = 1023, A = 1026, L = 1027, R = 33776, C = 33777, P = 33778, I = 33779, D = 35840, N = 35841, z = 35842, B = 35843, F = 37492, O = 37496, U = 2300, H = 2301, G = 2302, k = 2400, V = 2401, W = 2402, j = 2500, q = 2501, X = 3e3, Y = 3001, J = 3007, Z = 3002, Q = 3004, K = 3005, $ = 3006, tt = 7680, et = 35044, nt = 35048, it = "300 es";
      class rt {
        addEventListener(t2, e2) {
          void 0 === this._listeners && (this._listeners = {});
          const n2 = this._listeners;
          void 0 === n2[t2] && (n2[t2] = []), -1 === n2[t2].indexOf(e2) && n2[t2].push(e2);
        }
        hasEventListener(t2, e2) {
          if (void 0 === this._listeners)
            return false;
          const n2 = this._listeners;
          return void 0 !== n2[t2] && -1 !== n2[t2].indexOf(e2);
        }
        removeEventListener(t2, e2) {
          if (void 0 === this._listeners)
            return;
          const n2 = this._listeners[t2];
          if (void 0 !== n2) {
            const t3 = n2.indexOf(e2);
            -1 !== t3 && n2.splice(t3, 1);
          }
        }
        dispatchEvent(t2) {
          if (void 0 === this._listeners)
            return;
          const e2 = this._listeners[t2.type];
          if (void 0 !== e2) {
            t2.target = this;
            const n2 = e2.slice(0);
            for (let e3 = 0, i2 = n2.length; e3 < i2; e3++)
              n2[e3].call(this, t2);
            t2.target = null;
          }
        }
      }
      const st = [];
      for (let t2 = 0; t2 < 256; t2++)
        st[t2] = (t2 < 16 ? "0" : "") + t2.toString(16);
      let at = 1234567;
      const ot = Math.PI / 180, lt = 180 / Math.PI;
      function ct() {
        const t2 = 4294967295 * Math.random() | 0, e2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0;
        return (st[255 & t2] + st[t2 >> 8 & 255] + st[t2 >> 16 & 255] + st[t2 >> 24 & 255] + "-" + st[255 & e2] + st[e2 >> 8 & 255] + "-" + st[e2 >> 16 & 15 | 64] + st[e2 >> 24 & 255] + "-" + st[63 & n2 | 128] + st[n2 >> 8 & 255] + "-" + st[n2 >> 16 & 255] + st[n2 >> 24 & 255] + st[255 & i2] + st[i2 >> 8 & 255] + st[i2 >> 16 & 255] + st[i2 >> 24 & 255]).toUpperCase();
      }
      function ht(t2, e2, n2) {
        return Math.max(e2, Math.min(n2, t2));
      }
      function ut(t2, e2) {
        return (t2 % e2 + e2) % e2;
      }
      function dt(t2, e2, n2) {
        return (1 - n2) * t2 + n2 * e2;
      }
      function pt(t2) {
        return 0 == (t2 & t2 - 1) && 0 !== t2;
      }
      function mt(t2) {
        return Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }
      function ft(t2) {
        return Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
      }
      var gt = Object.freeze({ __proto__: null, DEG2RAD: ot, RAD2DEG: lt, generateUUID: ct, clamp: ht, euclideanModulo: ut, mapLinear: function(t2, e2, n2, i2, r2) {
        return i2 + (t2 - e2) * (r2 - i2) / (n2 - e2);
      }, inverseLerp: function(t2, e2, n2) {
        return t2 !== e2 ? (n2 - t2) / (e2 - t2) : 0;
      }, lerp: dt, damp: function(t2, e2, n2, i2) {
        return dt(t2, e2, 1 - Math.exp(-n2 * i2));
      }, pingpong: function(t2, e2 = 1) {
        return e2 - Math.abs(ut(t2, 2 * e2) - e2);
      }, smoothstep: function(t2, e2, n2) {
        return t2 <= e2 ? 0 : t2 >= n2 ? 1 : (t2 = (t2 - e2) / (n2 - e2)) * t2 * (3 - 2 * t2);
      }, smootherstep: function(t2, e2, n2) {
        return t2 <= e2 ? 0 : t2 >= n2 ? 1 : (t2 = (t2 - e2) / (n2 - e2)) * t2 * t2 * (t2 * (6 * t2 - 15) + 10);
      }, randInt: function(t2, e2) {
        return t2 + Math.floor(Math.random() * (e2 - t2 + 1));
      }, randFloat: function(t2, e2) {
        return t2 + Math.random() * (e2 - t2);
      }, randFloatSpread: function(t2) {
        return t2 * (0.5 - Math.random());
      }, seededRandom: function(t2) {
        return void 0 !== t2 && (at = t2 % 2147483647), at = 16807 * at % 2147483647, (at - 1) / 2147483646;
      }, degToRad: function(t2) {
        return t2 * ot;
      }, radToDeg: function(t2) {
        return t2 * lt;
      }, isPowerOfTwo: pt, ceilPowerOfTwo: mt, floorPowerOfTwo: ft, setQuaternionFromProperEuler: function(t2, e2, n2, i2, r2) {
        const s2 = Math.cos, a2 = Math.sin, o3 = s2(n2 / 2), l2 = a2(n2 / 2), c2 = s2((e2 + i2) / 2), h2 = a2((e2 + i2) / 2), u2 = s2((e2 - i2) / 2), d2 = a2((e2 - i2) / 2), p2 = s2((i2 - e2) / 2), m2 = a2((i2 - e2) / 2);
        switch (r2) {
          case "XYX":
            t2.set(o3 * h2, l2 * u2, l2 * d2, o3 * c2);
            break;
          case "YZY":
            t2.set(l2 * d2, o3 * h2, l2 * u2, o3 * c2);
            break;
          case "ZXZ":
            t2.set(l2 * u2, l2 * d2, o3 * h2, o3 * c2);
            break;
          case "XZX":
            t2.set(o3 * h2, l2 * m2, l2 * p2, o3 * c2);
            break;
          case "YXY":
            t2.set(l2 * p2, o3 * h2, l2 * m2, o3 * c2);
            break;
          case "ZYZ":
            t2.set(l2 * m2, l2 * p2, o3 * h2, o3 * c2);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r2);
        }
      } });
      class vt {
        constructor(t2 = 0, e2 = 0) {
          this.x = t2, this.y = e2;
        }
        get width() {
          return this.x;
        }
        set width(t2) {
          this.x = t2;
        }
        get height() {
          return this.y;
        }
        set height(t2) {
          this.y = t2;
        }
        set(t2, e2) {
          return this.x = t2, this.y = e2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this;
        }
        multiply(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this;
        }
        divide(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        applyMatrix3(t2) {
          const e2 = this.x, n2 = this.y, i2 = t2.elements;
          return this.x = i2[0] * e2 + i2[3] * n2 + i2[6], this.y = i2[1] * e2 + i2[4] * n2 + i2[7], this;
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this;
        }
        clampLength(t2, e2) {
          const n2 = this.length();
          return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y;
        }
        cross(t2) {
          return this.x * t2.y - this.y * t2.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(t2) {
          return Math.sqrt(this.distanceToSquared(t2));
        }
        distanceToSquared(t2) {
          const e2 = this.x - t2.x, n2 = this.y - t2.y;
          return e2 * e2 + n2 * n2;
        }
        manhattanDistanceTo(t2) {
          return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this;
        }
        lerpVectors(t2, e2, n2) {
          return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this;
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2;
        }
        fromBufferAttribute(t2, e2, n2) {
          return void 0 !== n2 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this;
        }
        rotateAround(t2, e2) {
          const n2 = Math.cos(e2), i2 = Math.sin(e2), r2 = this.x - t2.x, s2 = this.y - t2.y;
          return this.x = r2 * n2 - s2 * i2 + t2.x, this.y = r2 * i2 + s2 * n2 + t2.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
      }
      vt.prototype.isVector2 = true;
      class yt {
        constructor() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
        set(t2, e2, n2, i2, r2, s2, a2, o3, l2) {
          const c2 = this.elements;
          return c2[0] = t2, c2[1] = i2, c2[2] = a2, c2[3] = e2, c2[4] = r2, c2[5] = o3, c2[6] = n2, c2[7] = s2, c2[8] = l2, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t2) {
          const e2 = this.elements, n2 = t2.elements;
          return e2[0] = n2[0], e2[1] = n2[1], e2[2] = n2[2], e2[3] = n2[3], e2[4] = n2[4], e2[5] = n2[5], e2[6] = n2[6], e2[7] = n2[7], e2[8] = n2[8], this;
        }
        extractBasis(t2, e2, n2) {
          return t2.setFromMatrix3Column(this, 0), e2.setFromMatrix3Column(this, 1), n2.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(t2) {
          const e2 = t2.elements;
          return this.set(e2[0], e2[4], e2[8], e2[1], e2[5], e2[9], e2[2], e2[6], e2[10]), this;
        }
        multiply(t2) {
          return this.multiplyMatrices(this, t2);
        }
        premultiply(t2) {
          return this.multiplyMatrices(t2, this);
        }
        multiplyMatrices(t2, e2) {
          const n2 = t2.elements, i2 = e2.elements, r2 = this.elements, s2 = n2[0], a2 = n2[3], o3 = n2[6], l2 = n2[1], c2 = n2[4], h2 = n2[7], u2 = n2[2], d2 = n2[5], p2 = n2[8], m2 = i2[0], f2 = i2[3], g2 = i2[6], v2 = i2[1], y2 = i2[4], x2 = i2[7], _2 = i2[2], b2 = i2[5], M2 = i2[8];
          return r2[0] = s2 * m2 + a2 * v2 + o3 * _2, r2[3] = s2 * f2 + a2 * y2 + o3 * b2, r2[6] = s2 * g2 + a2 * x2 + o3 * M2, r2[1] = l2 * m2 + c2 * v2 + h2 * _2, r2[4] = l2 * f2 + c2 * y2 + h2 * b2, r2[7] = l2 * g2 + c2 * x2 + h2 * M2, r2[2] = u2 * m2 + d2 * v2 + p2 * _2, r2[5] = u2 * f2 + d2 * y2 + p2 * b2, r2[8] = u2 * g2 + d2 * x2 + p2 * M2, this;
        }
        multiplyScalar(t2) {
          const e2 = this.elements;
          return e2[0] *= t2, e2[3] *= t2, e2[6] *= t2, e2[1] *= t2, e2[4] *= t2, e2[7] *= t2, e2[2] *= t2, e2[5] *= t2, e2[8] *= t2, this;
        }
        determinant() {
          const t2 = this.elements, e2 = t2[0], n2 = t2[1], i2 = t2[2], r2 = t2[3], s2 = t2[4], a2 = t2[5], o3 = t2[6], l2 = t2[7], c2 = t2[8];
          return e2 * s2 * c2 - e2 * a2 * l2 - n2 * r2 * c2 + n2 * a2 * o3 + i2 * r2 * l2 - i2 * s2 * o3;
        }
        invert() {
          const t2 = this.elements, e2 = t2[0], n2 = t2[1], i2 = t2[2], r2 = t2[3], s2 = t2[4], a2 = t2[5], o3 = t2[6], l2 = t2[7], c2 = t2[8], h2 = c2 * s2 - a2 * l2, u2 = a2 * o3 - c2 * r2, d2 = l2 * r2 - s2 * o3, p2 = e2 * h2 + n2 * u2 + i2 * d2;
          if (0 === p2)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const m2 = 1 / p2;
          return t2[0] = h2 * m2, t2[1] = (i2 * l2 - c2 * n2) * m2, t2[2] = (a2 * n2 - i2 * s2) * m2, t2[3] = u2 * m2, t2[4] = (c2 * e2 - i2 * o3) * m2, t2[5] = (i2 * r2 - a2 * e2) * m2, t2[6] = d2 * m2, t2[7] = (n2 * o3 - l2 * e2) * m2, t2[8] = (s2 * e2 - n2 * r2) * m2, this;
        }
        transpose() {
          let t2;
          const e2 = this.elements;
          return t2 = e2[1], e2[1] = e2[3], e2[3] = t2, t2 = e2[2], e2[2] = e2[6], e2[6] = t2, t2 = e2[5], e2[5] = e2[7], e2[7] = t2, this;
        }
        getNormalMatrix(t2) {
          return this.setFromMatrix4(t2).invert().transpose();
        }
        transposeIntoArray(t2) {
          const e2 = this.elements;
          return t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8], this;
        }
        setUvTransform(t2, e2, n2, i2, r2, s2, a2) {
          const o3 = Math.cos(r2), l2 = Math.sin(r2);
          return this.set(n2 * o3, n2 * l2, -n2 * (o3 * s2 + l2 * a2) + s2 + t2, -i2 * l2, i2 * o3, -i2 * (-l2 * s2 + o3 * a2) + a2 + e2, 0, 0, 1), this;
        }
        scale(t2, e2) {
          const n2 = this.elements;
          return n2[0] *= t2, n2[3] *= t2, n2[6] *= t2, n2[1] *= e2, n2[4] *= e2, n2[7] *= e2, this;
        }
        rotate(t2) {
          const e2 = Math.cos(t2), n2 = Math.sin(t2), i2 = this.elements, r2 = i2[0], s2 = i2[3], a2 = i2[6], o3 = i2[1], l2 = i2[4], c2 = i2[7];
          return i2[0] = e2 * r2 + n2 * o3, i2[3] = e2 * s2 + n2 * l2, i2[6] = e2 * a2 + n2 * c2, i2[1] = -n2 * r2 + e2 * o3, i2[4] = -n2 * s2 + e2 * l2, i2[7] = -n2 * a2 + e2 * c2, this;
        }
        translate(t2, e2) {
          const n2 = this.elements;
          return n2[0] += t2 * n2[2], n2[3] += t2 * n2[5], n2[6] += t2 * n2[8], n2[1] += e2 * n2[2], n2[4] += e2 * n2[5], n2[7] += e2 * n2[8], this;
        }
        equals(t2) {
          const e2 = this.elements, n2 = t2.elements;
          for (let t3 = 0; t3 < 9; t3++)
            if (e2[t3] !== n2[t3])
              return false;
          return true;
        }
        fromArray(t2, e2 = 0) {
          for (let n2 = 0; n2 < 9; n2++)
            this.elements[n2] = t2[n2 + e2];
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const n2 = this.elements;
          return t2[e2] = n2[0], t2[e2 + 1] = n2[1], t2[e2 + 2] = n2[2], t2[e2 + 3] = n2[3], t2[e2 + 4] = n2[4], t2[e2 + 5] = n2[5], t2[e2 + 6] = n2[6], t2[e2 + 7] = n2[7], t2[e2 + 8] = n2[8], t2;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      let xt;
      yt.prototype.isMatrix3 = true;
      class _t {
        static getDataURL(t2) {
          if (/^data:/i.test(t2.src))
            return t2.src;
          if ("undefined" == typeof HTMLCanvasElement)
            return t2.src;
          let e2;
          if (t2 instanceof HTMLCanvasElement)
            e2 = t2;
          else {
            void 0 === xt && (xt = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), xt.width = t2.width, xt.height = t2.height;
            const n2 = xt.getContext("2d");
            t2 instanceof ImageData ? n2.putImageData(t2, 0, 0) : n2.drawImage(t2, 0, 0, t2.width, t2.height), e2 = xt;
          }
          return e2.width > 2048 || e2.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t2), e2.toDataURL("image/jpeg", 0.6)) : e2.toDataURL("image/png");
        }
      }
      let bt = 0;
      class Mt extends rt {
        constructor(t2 = Mt.DEFAULT_IMAGE, e2 = Mt.DEFAULT_MAPPING, n2 = 1001, i2 = 1001, r2 = 1006, s2 = 1008, a2 = 1023, o3 = 1009, l2 = 1, c2 = 3e3) {
          super(), Object.defineProperty(this, "id", { value: bt++ }), this.uuid = ct(), this.name = "", this.image = t2, this.mipmaps = [], this.mapping = e2, this.wrapS = n2, this.wrapT = i2, this.magFilter = r2, this.minFilter = s2, this.anisotropy = l2, this.format = a2, this.internalFormat = null, this.type = o3, this.offset = new vt(0, 0), this.repeat = new vt(1, 1), this.center = new vt(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new yt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c2, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.name = t2.name, this.image = t2.image, this.mipmaps = t2.mipmaps.slice(0), this.mapping = t2.mapping, this.wrapS = t2.wrapS, this.wrapT = t2.wrapT, this.magFilter = t2.magFilter, this.minFilter = t2.minFilter, this.anisotropy = t2.anisotropy, this.format = t2.format, this.internalFormat = t2.internalFormat, this.type = t2.type, this.offset.copy(t2.offset), this.repeat.copy(t2.repeat), this.center.copy(t2.center), this.rotation = t2.rotation, this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrix.copy(t2.matrix), this.generateMipmaps = t2.generateMipmaps, this.premultiplyAlpha = t2.premultiplyAlpha, this.flipY = t2.flipY, this.unpackAlignment = t2.unpackAlignment, this.encoding = t2.encoding, this;
        }
        toJSON(t2) {
          const e2 = void 0 === t2 || "string" == typeof t2;
          if (!e2 && void 0 !== t2.textures[this.uuid])
            return t2.textures[this.uuid];
          const n2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
          if (void 0 !== this.image) {
            const i2 = this.image;
            if (void 0 === i2.uuid && (i2.uuid = ct()), !e2 && void 0 === t2.images[i2.uuid]) {
              let e3;
              if (Array.isArray(i2)) {
                e3 = [];
                for (let t3 = 0, n3 = i2.length; t3 < n3; t3++)
                  i2[t3].isDataTexture ? e3.push(wt(i2[t3].image)) : e3.push(wt(i2[t3]));
              } else
                e3 = wt(i2);
              t2.images[i2.uuid] = { uuid: i2.uuid, url: e3 };
            }
            n2.image = i2.uuid;
          }
          return e2 || (t2.textures[this.uuid] = n2), n2;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(t2) {
          if (this.mapping !== i)
            return t2;
          if (t2.applyMatrix3(this.matrix), t2.x < 0 || t2.x > 1)
            switch (this.wrapS) {
              case h:
                t2.x = t2.x - Math.floor(t2.x);
                break;
              case u:
                t2.x = t2.x < 0 ? 0 : 1;
                break;
              case d:
                1 === Math.abs(Math.floor(t2.x) % 2) ? t2.x = Math.ceil(t2.x) - t2.x : t2.x = t2.x - Math.floor(t2.x);
            }
          if (t2.y < 0 || t2.y > 1)
            switch (this.wrapT) {
              case h:
                t2.y = t2.y - Math.floor(t2.y);
                break;
              case u:
                t2.y = t2.y < 0 ? 0 : 1;
                break;
              case d:
                1 === Math.abs(Math.floor(t2.y) % 2) ? t2.y = Math.ceil(t2.y) - t2.y : t2.y = t2.y - Math.floor(t2.y);
            }
          return this.flipY && (t2.y = 1 - t2.y), t2;
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
      }
      function wt(t2) {
        return "undefined" != typeof HTMLImageElement && t2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap ? _t.getDataURL(t2) : t2.data ? { data: Array.prototype.slice.call(t2.data), width: t2.width, height: t2.height, type: t2.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      Mt.DEFAULT_IMAGE = void 0, Mt.DEFAULT_MAPPING = i, Mt.prototype.isTexture = true;
      class St {
        constructor(t2 = 0, e2 = 0, n2 = 0, i2 = 1) {
          this.x = t2, this.y = e2, this.z = n2, this.w = i2;
        }
        get width() {
          return this.z;
        }
        set width(t2) {
          this.z = t2;
        }
        get height() {
          return this.w;
        }
        set height(t2) {
          this.w = t2;
        }
        set(t2, e2, n2, i2) {
          return this.x = t2, this.y = e2, this.z = n2, this.w = i2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this.z = t2, this.w = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setZ(t2) {
          return this.z = t2, this;
        }
        setW(t2) {
          return this.w = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            case 2:
              this.z = e2;
              break;
            case 3:
              this.w = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this.z = t2.z, this.w = void 0 !== t2.w ? t2.w : 1, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this.w += t2.w, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this.z += t2, this.w += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this.w = t2.w + e2.w, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this.w += t2.w * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this.w -= t2.w, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this.z -= t2, this.w -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this.w = t2.w - e2.w, this;
        }
        multiply(t2) {
          return this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this.w *= t2.w, this;
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this.z *= t2, this.w *= t2, this;
        }
        applyMatrix4(t2) {
          const e2 = this.x, n2 = this.y, i2 = this.z, r2 = this.w, s2 = t2.elements;
          return this.x = s2[0] * e2 + s2[4] * n2 + s2[8] * i2 + s2[12] * r2, this.y = s2[1] * e2 + s2[5] * n2 + s2[9] * i2 + s2[13] * r2, this.z = s2[2] * e2 + s2[6] * n2 + s2[10] * i2 + s2[14] * r2, this.w = s2[3] * e2 + s2[7] * n2 + s2[11] * i2 + s2[15] * r2, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        setAxisAngleFromQuaternion(t2) {
          this.w = 2 * Math.acos(t2.w);
          const e2 = Math.sqrt(1 - t2.w * t2.w);
          return e2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t2.x / e2, this.y = t2.y / e2, this.z = t2.z / e2), this;
        }
        setAxisAngleFromRotationMatrix(t2) {
          let e2, n2, i2, r2;
          const s2 = 0.01, a2 = 0.1, o3 = t2.elements, l2 = o3[0], c2 = o3[4], h2 = o3[8], u2 = o3[1], d2 = o3[5], p2 = o3[9], m2 = o3[2], f2 = o3[6], g2 = o3[10];
          if (Math.abs(c2 - u2) < s2 && Math.abs(h2 - m2) < s2 && Math.abs(p2 - f2) < s2) {
            if (Math.abs(c2 + u2) < a2 && Math.abs(h2 + m2) < a2 && Math.abs(p2 + f2) < a2 && Math.abs(l2 + d2 + g2 - 3) < a2)
              return this.set(1, 0, 0, 0), this;
            e2 = Math.PI;
            const t3 = (l2 + 1) / 2, o4 = (d2 + 1) / 2, v3 = (g2 + 1) / 2, y2 = (c2 + u2) / 4, x2 = (h2 + m2) / 4, _2 = (p2 + f2) / 4;
            return t3 > o4 && t3 > v3 ? t3 < s2 ? (n2 = 0, i2 = 0.707106781, r2 = 0.707106781) : (n2 = Math.sqrt(t3), i2 = y2 / n2, r2 = x2 / n2) : o4 > v3 ? o4 < s2 ? (n2 = 0.707106781, i2 = 0, r2 = 0.707106781) : (i2 = Math.sqrt(o4), n2 = y2 / i2, r2 = _2 / i2) : v3 < s2 ? (n2 = 0.707106781, i2 = 0.707106781, r2 = 0) : (r2 = Math.sqrt(v3), n2 = x2 / r2, i2 = _2 / r2), this.set(n2, i2, r2, e2), this;
          }
          let v2 = Math.sqrt((f2 - p2) * (f2 - p2) + (h2 - m2) * (h2 - m2) + (u2 - c2) * (u2 - c2));
          return Math.abs(v2) < 1e-3 && (v2 = 1), this.x = (f2 - p2) / v2, this.y = (h2 - m2) / v2, this.z = (u2 - c2) / v2, this.w = Math.acos((l2 + d2 + g2 - 1) / 2), this;
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this.w = Math.min(this.w, t2.w), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this.w = Math.max(this.w, t2.w), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this.w = Math.max(t2.w, Math.min(e2.w, this.w)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this.w = Math.max(t2, Math.min(e2, this.w)), this;
        }
        clampLength(t2, e2) {
          const n2 = this.length();
          return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y + this.z * t2.z + this.w * t2.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this.w += (t2.w - this.w) * e2, this;
        }
        lerpVectors(t2, e2, n2) {
          return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this.z = t2.z + (e2.z - t2.z) * n2, this.w = t2.w + (e2.w - t2.w) * n2, this;
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y && t2.z === this.z && t2.w === this.w;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this.w = t2[e2 + 3], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2[e2 + 3] = this.w, t2;
        }
        fromBufferAttribute(t2, e2, n2) {
          return void 0 !== n2 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this.w = t2.getW(e2), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
      }
      St.prototype.isVector4 = true;
      class Tt extends rt {
        constructor(t2, e2, n2 = {}) {
          super(), this.width = t2, this.height = e2, this.depth = 1, this.scissor = new St(0, 0, t2, e2), this.scissorTest = false, this.viewport = new St(0, 0, t2, e2), this.texture = new Mt(void 0, n2.mapping, n2.wrapS, n2.wrapT, n2.magFilter, n2.minFilter, n2.format, n2.type, n2.anisotropy, n2.encoding), this.texture.isRenderTargetTexture = true, this.texture.image = { width: t2, height: e2, depth: 1 }, this.texture.generateMipmaps = void 0 !== n2.generateMipmaps && n2.generateMipmaps, this.texture.internalFormat = void 0 !== n2.internalFormat ? n2.internalFormat : null, this.texture.minFilter = void 0 !== n2.minFilter ? n2.minFilter : g, this.depthBuffer = void 0 === n2.depthBuffer || n2.depthBuffer, this.stencilBuffer = void 0 !== n2.stencilBuffer && n2.stencilBuffer, this.depthTexture = void 0 !== n2.depthTexture ? n2.depthTexture : null;
        }
        setTexture(t2) {
          t2.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t2;
        }
        setSize(t2, e2, n2 = 1) {
          this.width === t2 && this.height === e2 && this.depth === n2 || (this.width = t2, this.height = e2, this.depth = n2, this.texture.image.width = t2, this.texture.image.height = e2, this.texture.image.depth = n2, this.dispose()), this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.width = t2.width, this.height = t2.height, this.depth = t2.depth, this.viewport.copy(t2.viewport), this.texture = t2.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Tt.prototype.isWebGLRenderTarget = true;
      class Et extends Tt {
        constructor(t2, e2, n2) {
          super(t2, e2);
          const i2 = this.texture;
          this.texture = [];
          for (let t3 = 0; t3 < n2; t3++)
            this.texture[t3] = i2.clone();
        }
        setSize(t2, e2, n2 = 1) {
          if (this.width !== t2 || this.height !== e2 || this.depth !== n2) {
            this.width = t2, this.height = e2, this.depth = n2;
            for (let i2 = 0, r2 = this.texture.length; i2 < r2; i2++)
              this.texture[i2].image.width = t2, this.texture[i2].image.height = e2, this.texture[i2].image.depth = n2;
            this.dispose();
          }
          return this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2), this;
        }
        copy(t2) {
          this.dispose(), this.width = t2.width, this.height = t2.height, this.depth = t2.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this.texture.length = 0;
          for (let e2 = 0, n2 = t2.texture.length; e2 < n2; e2++)
            this.texture[e2] = t2.texture[e2].clone();
          return this;
        }
      }
      Et.prototype.isWebGLMultipleRenderTargets = true;
      class At extends Tt {
        constructor(t2, e2, n2) {
          super(t2, e2, n2), this.samples = 4;
        }
        copy(t2) {
          return super.copy.call(this, t2), this.samples = t2.samples, this;
        }
      }
      At.prototype.isWebGLMultisampleRenderTarget = true;
      class Lt {
        constructor(t2 = 0, e2 = 0, n2 = 0, i2 = 1) {
          this._x = t2, this._y = e2, this._z = n2, this._w = i2;
        }
        static slerp(t2, e2, n2, i2) {
          return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n2.slerpQuaternions(t2, e2, i2);
        }
        static slerpFlat(t2, e2, n2, i2, r2, s2, a2) {
          let o3 = n2[i2 + 0], l2 = n2[i2 + 1], c2 = n2[i2 + 2], h2 = n2[i2 + 3];
          const u2 = r2[s2 + 0], d2 = r2[s2 + 1], p2 = r2[s2 + 2], m2 = r2[s2 + 3];
          if (0 === a2)
            return t2[e2 + 0] = o3, t2[e2 + 1] = l2, t2[e2 + 2] = c2, void (t2[e2 + 3] = h2);
          if (1 === a2)
            return t2[e2 + 0] = u2, t2[e2 + 1] = d2, t2[e2 + 2] = p2, void (t2[e2 + 3] = m2);
          if (h2 !== m2 || o3 !== u2 || l2 !== d2 || c2 !== p2) {
            let t3 = 1 - a2;
            const e3 = o3 * u2 + l2 * d2 + c2 * p2 + h2 * m2, n3 = e3 >= 0 ? 1 : -1, i3 = 1 - e3 * e3;
            if (i3 > Number.EPSILON) {
              const r4 = Math.sqrt(i3), s3 = Math.atan2(r4, e3 * n3);
              t3 = Math.sin(t3 * s3) / r4, a2 = Math.sin(a2 * s3) / r4;
            }
            const r3 = a2 * n3;
            if (o3 = o3 * t3 + u2 * r3, l2 = l2 * t3 + d2 * r3, c2 = c2 * t3 + p2 * r3, h2 = h2 * t3 + m2 * r3, t3 === 1 - a2) {
              const t4 = 1 / Math.sqrt(o3 * o3 + l2 * l2 + c2 * c2 + h2 * h2);
              o3 *= t4, l2 *= t4, c2 *= t4, h2 *= t4;
            }
          }
          t2[e2] = o3, t2[e2 + 1] = l2, t2[e2 + 2] = c2, t2[e2 + 3] = h2;
        }
        static multiplyQuaternionsFlat(t2, e2, n2, i2, r2, s2) {
          const a2 = n2[i2], o3 = n2[i2 + 1], l2 = n2[i2 + 2], c2 = n2[i2 + 3], h2 = r2[s2], u2 = r2[s2 + 1], d2 = r2[s2 + 2], p2 = r2[s2 + 3];
          return t2[e2] = a2 * p2 + c2 * h2 + o3 * d2 - l2 * u2, t2[e2 + 1] = o3 * p2 + c2 * u2 + l2 * h2 - a2 * d2, t2[e2 + 2] = l2 * p2 + c2 * d2 + a2 * u2 - o3 * h2, t2[e2 + 3] = c2 * p2 - a2 * h2 - o3 * u2 - l2 * d2, t2;
        }
        get x() {
          return this._x;
        }
        set x(t2) {
          this._x = t2, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t2) {
          this._y = t2, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t2) {
          this._z = t2, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t2) {
          this._w = t2, this._onChangeCallback();
        }
        set(t2, e2, n2, i2) {
          return this._x = t2, this._y = e2, this._z = n2, this._w = i2, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t2) {
          return this._x = t2.x, this._y = t2.y, this._z = t2.z, this._w = t2.w, this._onChangeCallback(), this;
        }
        setFromEuler(t2, e2) {
          if (!t2 || !t2.isEuler)
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          const n2 = t2._x, i2 = t2._y, r2 = t2._z, s2 = t2._order, a2 = Math.cos, o3 = Math.sin, l2 = a2(n2 / 2), c2 = a2(i2 / 2), h2 = a2(r2 / 2), u2 = o3(n2 / 2), d2 = o3(i2 / 2), p2 = o3(r2 / 2);
          switch (s2) {
            case "XYZ":
              this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
              break;
            case "YXZ":
              this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
              break;
            case "ZXY":
              this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
              break;
            case "ZYX":
              this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
              break;
            case "YZX":
              this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
              break;
            case "XZY":
              this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s2);
          }
          return false !== e2 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t2, e2) {
          const n2 = e2 / 2, i2 = Math.sin(n2);
          return this._x = t2.x * i2, this._y = t2.y * i2, this._z = t2.z * i2, this._w = Math.cos(n2), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t2) {
          const e2 = t2.elements, n2 = e2[0], i2 = e2[4], r2 = e2[8], s2 = e2[1], a2 = e2[5], o3 = e2[9], l2 = e2[2], c2 = e2[6], h2 = e2[10], u2 = n2 + a2 + h2;
          if (u2 > 0) {
            const t3 = 0.5 / Math.sqrt(u2 + 1);
            this._w = 0.25 / t3, this._x = (c2 - o3) * t3, this._y = (r2 - l2) * t3, this._z = (s2 - i2) * t3;
          } else if (n2 > a2 && n2 > h2) {
            const t3 = 2 * Math.sqrt(1 + n2 - a2 - h2);
            this._w = (c2 - o3) / t3, this._x = 0.25 * t3, this._y = (i2 + s2) / t3, this._z = (r2 + l2) / t3;
          } else if (a2 > h2) {
            const t3 = 2 * Math.sqrt(1 + a2 - n2 - h2);
            this._w = (r2 - l2) / t3, this._x = (i2 + s2) / t3, this._y = 0.25 * t3, this._z = (o3 + c2) / t3;
          } else {
            const t3 = 2 * Math.sqrt(1 + h2 - n2 - a2);
            this._w = (s2 - i2) / t3, this._x = (r2 + l2) / t3, this._y = (o3 + c2) / t3, this._z = 0.25 * t3;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t2, e2) {
          let n2 = t2.dot(e2) + 1;
          return n2 < Number.EPSILON ? (n2 = 0, Math.abs(t2.x) > Math.abs(t2.z) ? (this._x = -t2.y, this._y = t2.x, this._z = 0, this._w = n2) : (this._x = 0, this._y = -t2.z, this._z = t2.y, this._w = n2)) : (this._x = t2.y * e2.z - t2.z * e2.y, this._y = t2.z * e2.x - t2.x * e2.z, this._z = t2.x * e2.y - t2.y * e2.x, this._w = n2), this.normalize();
        }
        angleTo(t2) {
          return 2 * Math.acos(Math.abs(ht(this.dot(t2), -1, 1)));
        }
        rotateTowards(t2, e2) {
          const n2 = this.angleTo(t2);
          if (0 === n2)
            return this;
          const i2 = Math.min(1, e2 / n2);
          return this.slerp(t2, i2), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(t2) {
          return this._x * t2._x + this._y * t2._y + this._z * t2._z + this._w * t2._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let t2 = this.length();
          return 0 === t2 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t2 = 1 / t2, this._x = this._x * t2, this._y = this._y * t2, this._z = this._z * t2, this._w = this._w * t2), this._onChangeCallback(), this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t2, e2)) : this.multiplyQuaternions(this, t2);
        }
        premultiply(t2) {
          return this.multiplyQuaternions(t2, this);
        }
        multiplyQuaternions(t2, e2) {
          const n2 = t2._x, i2 = t2._y, r2 = t2._z, s2 = t2._w, a2 = e2._x, o3 = e2._y, l2 = e2._z, c2 = e2._w;
          return this._x = n2 * c2 + s2 * a2 + i2 * l2 - r2 * o3, this._y = i2 * c2 + s2 * o3 + r2 * a2 - n2 * l2, this._z = r2 * c2 + s2 * l2 + n2 * o3 - i2 * a2, this._w = s2 * c2 - n2 * a2 - i2 * o3 - r2 * l2, this._onChangeCallback(), this;
        }
        slerp(t2, e2) {
          if (0 === e2)
            return this;
          if (1 === e2)
            return this.copy(t2);
          const n2 = this._x, i2 = this._y, r2 = this._z, s2 = this._w;
          let a2 = s2 * t2._w + n2 * t2._x + i2 * t2._y + r2 * t2._z;
          if (a2 < 0 ? (this._w = -t2._w, this._x = -t2._x, this._y = -t2._y, this._z = -t2._z, a2 = -a2) : this.copy(t2), a2 >= 1)
            return this._w = s2, this._x = n2, this._y = i2, this._z = r2, this;
          const o3 = 1 - a2 * a2;
          if (o3 <= Number.EPSILON) {
            const t3 = 1 - e2;
            return this._w = t3 * s2 + e2 * this._w, this._x = t3 * n2 + e2 * this._x, this._y = t3 * i2 + e2 * this._y, this._z = t3 * r2 + e2 * this._z, this.normalize(), this._onChangeCallback(), this;
          }
          const l2 = Math.sqrt(o3), c2 = Math.atan2(l2, a2), h2 = Math.sin((1 - e2) * c2) / l2, u2 = Math.sin(e2 * c2) / l2;
          return this._w = s2 * h2 + this._w * u2, this._x = n2 * h2 + this._x * u2, this._y = i2 * h2 + this._y * u2, this._z = r2 * h2 + this._z * u2, this._onChangeCallback(), this;
        }
        slerpQuaternions(t2, e2, n2) {
          this.copy(t2).slerp(e2, n2);
        }
        equals(t2) {
          return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._w === this._w;
        }
        fromArray(t2, e2 = 0) {
          return this._x = t2[e2], this._y = t2[e2 + 1], this._z = t2[e2 + 2], this._w = t2[e2 + 3], this._onChangeCallback(), this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._w, t2;
        }
        fromBufferAttribute(t2, e2) {
          return this._x = t2.getX(e2), this._y = t2.getY(e2), this._z = t2.getZ(e2), this._w = t2.getW(e2), this;
        }
        _onChange(t2) {
          return this._onChangeCallback = t2, this;
        }
        _onChangeCallback() {
        }
      }
      Lt.prototype.isQuaternion = true;
      class Rt {
        constructor(t2 = 0, e2 = 0, n2 = 0) {
          this.x = t2, this.y = e2, this.z = n2;
        }
        set(t2, e2, n2) {
          return void 0 === n2 && (n2 = this.z), this.x = t2, this.y = e2, this.z = n2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this.z = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setZ(t2) {
          return this.z = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            case 2:
              this.z = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this.z = t2.z, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this.z += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this.z -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t2, e2)) : (this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this);
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this.z *= t2, this;
        }
        multiplyVectors(t2, e2) {
          return this.x = t2.x * e2.x, this.y = t2.y * e2.y, this.z = t2.z * e2.z, this;
        }
        applyEuler(t2) {
          return t2 && t2.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Pt.setFromEuler(t2));
        }
        applyAxisAngle(t2, e2) {
          return this.applyQuaternion(Pt.setFromAxisAngle(t2, e2));
        }
        applyMatrix3(t2) {
          const e2 = this.x, n2 = this.y, i2 = this.z, r2 = t2.elements;
          return this.x = r2[0] * e2 + r2[3] * n2 + r2[6] * i2, this.y = r2[1] * e2 + r2[4] * n2 + r2[7] * i2, this.z = r2[2] * e2 + r2[5] * n2 + r2[8] * i2, this;
        }
        applyNormalMatrix(t2) {
          return this.applyMatrix3(t2).normalize();
        }
        applyMatrix4(t2) {
          const e2 = this.x, n2 = this.y, i2 = this.z, r2 = t2.elements, s2 = 1 / (r2[3] * e2 + r2[7] * n2 + r2[11] * i2 + r2[15]);
          return this.x = (r2[0] * e2 + r2[4] * n2 + r2[8] * i2 + r2[12]) * s2, this.y = (r2[1] * e2 + r2[5] * n2 + r2[9] * i2 + r2[13]) * s2, this.z = (r2[2] * e2 + r2[6] * n2 + r2[10] * i2 + r2[14]) * s2, this;
        }
        applyQuaternion(t2) {
          const e2 = this.x, n2 = this.y, i2 = this.z, r2 = t2.x, s2 = t2.y, a2 = t2.z, o3 = t2.w, l2 = o3 * e2 + s2 * i2 - a2 * n2, c2 = o3 * n2 + a2 * e2 - r2 * i2, h2 = o3 * i2 + r2 * n2 - s2 * e2, u2 = -r2 * e2 - s2 * n2 - a2 * i2;
          return this.x = l2 * o3 + u2 * -r2 + c2 * -a2 - h2 * -s2, this.y = c2 * o3 + u2 * -s2 + h2 * -r2 - l2 * -a2, this.z = h2 * o3 + u2 * -a2 + l2 * -s2 - c2 * -r2, this;
        }
        project(t2) {
          return this.applyMatrix4(t2.matrixWorldInverse).applyMatrix4(t2.projectionMatrix);
        }
        unproject(t2) {
          return this.applyMatrix4(t2.projectionMatrixInverse).applyMatrix4(t2.matrixWorld);
        }
        transformDirection(t2) {
          const e2 = this.x, n2 = this.y, i2 = this.z, r2 = t2.elements;
          return this.x = r2[0] * e2 + r2[4] * n2 + r2[8] * i2, this.y = r2[1] * e2 + r2[5] * n2 + r2[9] * i2, this.z = r2[2] * e2 + r2[6] * n2 + r2[10] * i2, this.normalize();
        }
        divide(t2) {
          return this.x /= t2.x, this.y /= t2.y, this.z /= t2.z, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this;
        }
        clampLength(t2, e2) {
          const n2 = this.length();
          return this.divideScalar(n2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, n2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y + this.z * t2.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this;
        }
        lerpVectors(t2, e2, n2) {
          return this.x = t2.x + (e2.x - t2.x) * n2, this.y = t2.y + (e2.y - t2.y) * n2, this.z = t2.z + (e2.z - t2.z) * n2, this;
        }
        cross(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t2, e2)) : this.crossVectors(this, t2);
        }
        crossVectors(t2, e2) {
          const n2 = t2.x, i2 = t2.y, r2 = t2.z, s2 = e2.x, a2 = e2.y, o3 = e2.z;
          return this.x = i2 * o3 - r2 * a2, this.y = r2 * s2 - n2 * o3, this.z = n2 * a2 - i2 * s2, this;
        }
        projectOnVector(t2) {
          const e2 = t2.lengthSq();
          if (0 === e2)
            return this.set(0, 0, 0);
          const n2 = t2.dot(this) / e2;
          return this.copy(t2).multiplyScalar(n2);
        }
        projectOnPlane(t2) {
          return Ct.copy(this).projectOnVector(t2), this.sub(Ct);
        }
        reflect(t2) {
          return this.sub(Ct.copy(t2).multiplyScalar(2 * this.dot(t2)));
        }
        angleTo(t2) {
          const e2 = Math.sqrt(this.lengthSq() * t2.lengthSq());
          if (0 === e2)
            return Math.PI / 2;
          const n2 = this.dot(t2) / e2;
          return Math.acos(ht(n2, -1, 1));
        }
        distanceTo(t2) {
          return Math.sqrt(this.distanceToSquared(t2));
        }
        distanceToSquared(t2) {
          const e2 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.z - t2.z;
          return e2 * e2 + n2 * n2 + i2 * i2;
        }
        manhattanDistanceTo(t2) {
          return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y) + Math.abs(this.z - t2.z);
        }
        setFromSpherical(t2) {
          return this.setFromSphericalCoords(t2.radius, t2.phi, t2.theta);
        }
        setFromSphericalCoords(t2, e2, n2) {
          const i2 = Math.sin(e2) * t2;
          return this.x = i2 * Math.sin(n2), this.y = Math.cos(e2) * t2, this.z = i2 * Math.cos(n2), this;
        }
        setFromCylindrical(t2) {
          return this.setFromCylindricalCoords(t2.radius, t2.theta, t2.y);
        }
        setFromCylindricalCoords(t2, e2, n2) {
          return this.x = t2 * Math.sin(e2), this.y = n2, this.z = t2 * Math.cos(e2), this;
        }
        setFromMatrixPosition(t2) {
          const e2 = t2.elements;
          return this.x = e2[12], this.y = e2[13], this.z = e2[14], this;
        }
        setFromMatrixScale(t2) {
          const e2 = this.setFromMatrixColumn(t2, 0).length(), n2 = this.setFromMatrixColumn(t2, 1).length(), i2 = this.setFromMatrixColumn(t2, 2).length();
          return this.x = e2, this.y = n2, this.z = i2, this;
        }
        setFromMatrixColumn(t2, e2) {
          return this.fromArray(t2.elements, 4 * e2);
        }
        setFromMatrix3Column(t2, e2) {
          return this.fromArray(t2.elements, 3 * e2);
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y && t2.z === this.z;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2;
        }
        fromBufferAttribute(t2, e2, n2) {
          return void 0 !== n2 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
      }
      Rt.prototype.isVector3 = true;
      const Ct = new Rt(), Pt = new Lt();
      class It {
        constructor(t2 = new Rt(1 / 0, 1 / 0, 1 / 0), e2 = new Rt(-1 / 0, -1 / 0, -1 / 0)) {
          this.min = t2, this.max = e2;
        }
        set(t2, e2) {
          return this.min.copy(t2), this.max.copy(e2), this;
        }
        setFromArray(t2) {
          let e2 = 1 / 0, n2 = 1 / 0, i2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, a2 = -1 / 0;
          for (let o3 = 0, l2 = t2.length; o3 < l2; o3 += 3) {
            const l3 = t2[o3], c2 = t2[o3 + 1], h2 = t2[o3 + 2];
            l3 < e2 && (e2 = l3), c2 < n2 && (n2 = c2), h2 < i2 && (i2 = h2), l3 > r2 && (r2 = l3), c2 > s2 && (s2 = c2), h2 > a2 && (a2 = h2);
          }
          return this.min.set(e2, n2, i2), this.max.set(r2, s2, a2), this;
        }
        setFromBufferAttribute(t2) {
          let e2 = 1 / 0, n2 = 1 / 0, i2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, a2 = -1 / 0;
          for (let o3 = 0, l2 = t2.count; o3 < l2; o3++) {
            const l3 = t2.getX(o3), c2 = t2.getY(o3), h2 = t2.getZ(o3);
            l3 < e2 && (e2 = l3), c2 < n2 && (n2 = c2), h2 < i2 && (i2 = h2), l3 > r2 && (r2 = l3), c2 > s2 && (s2 = c2), h2 > a2 && (a2 = h2);
          }
          return this.min.set(e2, n2, i2), this.max.set(r2, s2, a2), this;
        }
        setFromPoints(t2) {
          this.makeEmpty();
          for (let e2 = 0, n2 = t2.length; e2 < n2; e2++)
            this.expandByPoint(t2[e2]);
          return this;
        }
        setFromCenterAndSize(t2, e2) {
          const n2 = Nt.copy(e2).multiplyScalar(0.5);
          return this.min.copy(t2).sub(n2), this.max.copy(t2).add(n2), this;
        }
        setFromObject(t2) {
          return this.makeEmpty(), this.expandByObject(t2);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.min.copy(t2.min), this.max.copy(t2.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(t2) {
          return this.isEmpty() ? t2.set(0, 0, 0) : t2.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t2) {
          return this.isEmpty() ? t2.set(0, 0, 0) : t2.subVectors(this.max, this.min);
        }
        expandByPoint(t2) {
          return this.min.min(t2), this.max.max(t2), this;
        }
        expandByVector(t2) {
          return this.min.sub(t2), this.max.add(t2), this;
        }
        expandByScalar(t2) {
          return this.min.addScalar(-t2), this.max.addScalar(t2), this;
        }
        expandByObject(t2) {
          t2.updateWorldMatrix(false, false);
          const e2 = t2.geometry;
          void 0 !== e2 && (null === e2.boundingBox && e2.computeBoundingBox(), zt.copy(e2.boundingBox), zt.applyMatrix4(t2.matrixWorld), this.union(zt));
          const n2 = t2.children;
          for (let t3 = 0, e3 = n2.length; t3 < e3; t3++)
            this.expandByObject(n2[t3]);
          return this;
        }
        containsPoint(t2) {
          return !(t2.x < this.min.x || t2.x > this.max.x || t2.y < this.min.y || t2.y > this.max.y || t2.z < this.min.z || t2.z > this.max.z);
        }
        containsBox(t2) {
          return this.min.x <= t2.min.x && t2.max.x <= this.max.x && this.min.y <= t2.min.y && t2.max.y <= this.max.y && this.min.z <= t2.min.z && t2.max.z <= this.max.z;
        }
        getParameter(t2, e2) {
          return e2.set((t2.x - this.min.x) / (this.max.x - this.min.x), (t2.y - this.min.y) / (this.max.y - this.min.y), (t2.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(t2) {
          return !(t2.max.x < this.min.x || t2.min.x > this.max.x || t2.max.y < this.min.y || t2.min.y > this.max.y || t2.max.z < this.min.z || t2.min.z > this.max.z);
        }
        intersectsSphere(t2) {
          return this.clampPoint(t2.center, Nt), Nt.distanceToSquared(t2.center) <= t2.radius * t2.radius;
        }
        intersectsPlane(t2) {
          let e2, n2;
          return t2.normal.x > 0 ? (e2 = t2.normal.x * this.min.x, n2 = t2.normal.x * this.max.x) : (e2 = t2.normal.x * this.max.x, n2 = t2.normal.x * this.min.x), t2.normal.y > 0 ? (e2 += t2.normal.y * this.min.y, n2 += t2.normal.y * this.max.y) : (e2 += t2.normal.y * this.max.y, n2 += t2.normal.y * this.min.y), t2.normal.z > 0 ? (e2 += t2.normal.z * this.min.z, n2 += t2.normal.z * this.max.z) : (e2 += t2.normal.z * this.max.z, n2 += t2.normal.z * this.min.z), e2 <= -t2.constant && n2 >= -t2.constant;
        }
        intersectsTriangle(t2) {
          if (this.isEmpty())
            return false;
          this.getCenter(kt), Vt.subVectors(this.max, kt), Bt.subVectors(t2.a, kt), Ft.subVectors(t2.b, kt), Ot.subVectors(t2.c, kt), Ut.subVectors(Ft, Bt), Ht.subVectors(Ot, Ft), Gt.subVectors(Bt, Ot);
          let e2 = [0, -Ut.z, Ut.y, 0, -Ht.z, Ht.y, 0, -Gt.z, Gt.y, Ut.z, 0, -Ut.x, Ht.z, 0, -Ht.x, Gt.z, 0, -Gt.x, -Ut.y, Ut.x, 0, -Ht.y, Ht.x, 0, -Gt.y, Gt.x, 0];
          return !!qt(e2, Bt, Ft, Ot, Vt) && (e2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!qt(e2, Bt, Ft, Ot, Vt) && (Wt.crossVectors(Ut, Ht), e2 = [Wt.x, Wt.y, Wt.z], qt(e2, Bt, Ft, Ot, Vt)));
        }
        clampPoint(t2, e2) {
          return e2.copy(t2).clamp(this.min, this.max);
        }
        distanceToPoint(t2) {
          return Nt.copy(t2).clamp(this.min, this.max).sub(t2).length();
        }
        getBoundingSphere(t2) {
          return this.getCenter(t2.center), t2.radius = 0.5 * this.getSize(Nt).length(), t2;
        }
        intersect(t2) {
          return this.min.max(t2.min), this.max.min(t2.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(t2) {
          return this.min.min(t2.min), this.max.max(t2.max), this;
        }
        applyMatrix4(t2) {
          return this.isEmpty() || (Dt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t2), Dt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t2), Dt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t2), Dt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t2), Dt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t2), Dt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t2), Dt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t2), Dt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t2), this.setFromPoints(Dt)), this;
        }
        translate(t2) {
          return this.min.add(t2), this.max.add(t2), this;
        }
        equals(t2) {
          return t2.min.equals(this.min) && t2.max.equals(this.max);
        }
      }
      It.prototype.isBox3 = true;
      const Dt = [new Rt(), new Rt(), new Rt(), new Rt(), new Rt(), new Rt(), new Rt(), new Rt()], Nt = new Rt(), zt = new It(), Bt = new Rt(), Ft = new Rt(), Ot = new Rt(), Ut = new Rt(), Ht = new Rt(), Gt = new Rt(), kt = new Rt(), Vt = new Rt(), Wt = new Rt(), jt = new Rt();
      function qt(t2, e2, n2, i2, r2) {
        for (let s2 = 0, a2 = t2.length - 3; s2 <= a2; s2 += 3) {
          jt.fromArray(t2, s2);
          const a3 = r2.x * Math.abs(jt.x) + r2.y * Math.abs(jt.y) + r2.z * Math.abs(jt.z), o3 = e2.dot(jt), l2 = n2.dot(jt), c2 = i2.dot(jt);
          if (Math.max(-Math.max(o3, l2, c2), Math.min(o3, l2, c2)) > a3)
            return false;
        }
        return true;
      }
      const Xt = new It(), Yt = new Rt(), Jt = new Rt(), Zt = new Rt();
      class Qt {
        constructor(t2 = new Rt(), e2 = -1) {
          this.center = t2, this.radius = e2;
        }
        set(t2, e2) {
          return this.center.copy(t2), this.radius = e2, this;
        }
        setFromPoints(t2, e2) {
          const n2 = this.center;
          void 0 !== e2 ? n2.copy(e2) : Xt.setFromPoints(t2).getCenter(n2);
          let i2 = 0;
          for (let e3 = 0, r2 = t2.length; e3 < r2; e3++)
            i2 = Math.max(i2, n2.distanceToSquared(t2[e3]));
          return this.radius = Math.sqrt(i2), this;
        }
        copy(t2) {
          return this.center.copy(t2.center), this.radius = t2.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(t2) {
          return t2.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t2) {
          return t2.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t2) {
          const e2 = this.radius + t2.radius;
          return t2.center.distanceToSquared(this.center) <= e2 * e2;
        }
        intersectsBox(t2) {
          return t2.intersectsSphere(this);
        }
        intersectsPlane(t2) {
          return Math.abs(t2.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t2, e2) {
          const n2 = this.center.distanceToSquared(t2);
          return e2.copy(t2), n2 > this.radius * this.radius && (e2.sub(this.center).normalize(), e2.multiplyScalar(this.radius).add(this.center)), e2;
        }
        getBoundingBox(t2) {
          return this.isEmpty() ? (t2.makeEmpty(), t2) : (t2.set(this.center, this.center), t2.expandByScalar(this.radius), t2);
        }
        applyMatrix4(t2) {
          return this.center.applyMatrix4(t2), this.radius = this.radius * t2.getMaxScaleOnAxis(), this;
        }
        translate(t2) {
          return this.center.add(t2), this;
        }
        expandByPoint(t2) {
          Zt.subVectors(t2, this.center);
          const e2 = Zt.lengthSq();
          if (e2 > this.radius * this.radius) {
            const t3 = Math.sqrt(e2), n2 = 0.5 * (t3 - this.radius);
            this.center.add(Zt.multiplyScalar(n2 / t3)), this.radius += n2;
          }
          return this;
        }
        union(t2) {
          return Jt.subVectors(t2.center, this.center).normalize().multiplyScalar(t2.radius), this.expandByPoint(Yt.copy(t2.center).add(Jt)), this.expandByPoint(Yt.copy(t2.center).sub(Jt)), this;
        }
        equals(t2) {
          return t2.center.equals(this.center) && t2.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Kt = new Rt(), $t = new Rt(), te = new Rt(), ee = new Rt(), ne = new Rt(), ie = new Rt(), re = new Rt();
      class se {
        constructor(t2 = new Rt(), e2 = new Rt(0, 0, -1)) {
          this.origin = t2, this.direction = e2;
        }
        set(t2, e2) {
          return this.origin.copy(t2), this.direction.copy(e2), this;
        }
        copy(t2) {
          return this.origin.copy(t2.origin), this.direction.copy(t2.direction), this;
        }
        at(t2, e2) {
          return e2.copy(this.direction).multiplyScalar(t2).add(this.origin);
        }
        lookAt(t2) {
          return this.direction.copy(t2).sub(this.origin).normalize(), this;
        }
        recast(t2) {
          return this.origin.copy(this.at(t2, Kt)), this;
        }
        closestPointToPoint(t2, e2) {
          e2.subVectors(t2, this.origin);
          const n2 = e2.dot(this.direction);
          return n2 < 0 ? e2.copy(this.origin) : e2.copy(this.direction).multiplyScalar(n2).add(this.origin);
        }
        distanceToPoint(t2) {
          return Math.sqrt(this.distanceSqToPoint(t2));
        }
        distanceSqToPoint(t2) {
          const e2 = Kt.subVectors(t2, this.origin).dot(this.direction);
          return e2 < 0 ? this.origin.distanceToSquared(t2) : (Kt.copy(this.direction).multiplyScalar(e2).add(this.origin), Kt.distanceToSquared(t2));
        }
        distanceSqToSegment(t2, e2, n2, i2) {
          $t.copy(t2).add(e2).multiplyScalar(0.5), te.copy(e2).sub(t2).normalize(), ee.copy(this.origin).sub($t);
          const r2 = 0.5 * t2.distanceTo(e2), s2 = -this.direction.dot(te), a2 = ee.dot(this.direction), o3 = -ee.dot(te), l2 = ee.lengthSq(), c2 = Math.abs(1 - s2 * s2);
          let h2, u2, d2, p2;
          if (c2 > 0)
            if (h2 = s2 * o3 - a2, u2 = s2 * a2 - o3, p2 = r2 * c2, h2 >= 0)
              if (u2 >= -p2)
                if (u2 <= p2) {
                  const t3 = 1 / c2;
                  h2 *= t3, u2 *= t3, d2 = h2 * (h2 + s2 * u2 + 2 * a2) + u2 * (s2 * h2 + u2 + 2 * o3) + l2;
                } else
                  u2 = r2, h2 = Math.max(0, -(s2 * u2 + a2)), d2 = -h2 * h2 + u2 * (u2 + 2 * o3) + l2;
              else
                u2 = -r2, h2 = Math.max(0, -(s2 * u2 + a2)), d2 = -h2 * h2 + u2 * (u2 + 2 * o3) + l2;
            else
              u2 <= -p2 ? (h2 = Math.max(0, -(-s2 * r2 + a2)), u2 = h2 > 0 ? -r2 : Math.min(Math.max(-r2, -o3), r2), d2 = -h2 * h2 + u2 * (u2 + 2 * o3) + l2) : u2 <= p2 ? (h2 = 0, u2 = Math.min(Math.max(-r2, -o3), r2), d2 = u2 * (u2 + 2 * o3) + l2) : (h2 = Math.max(0, -(s2 * r2 + a2)), u2 = h2 > 0 ? r2 : Math.min(Math.max(-r2, -o3), r2), d2 = -h2 * h2 + u2 * (u2 + 2 * o3) + l2);
          else
            u2 = s2 > 0 ? -r2 : r2, h2 = Math.max(0, -(s2 * u2 + a2)), d2 = -h2 * h2 + u2 * (u2 + 2 * o3) + l2;
          return n2 && n2.copy(this.direction).multiplyScalar(h2).add(this.origin), i2 && i2.copy(te).multiplyScalar(u2).add($t), d2;
        }
        intersectSphere(t2, e2) {
          Kt.subVectors(t2.center, this.origin);
          const n2 = Kt.dot(this.direction), i2 = Kt.dot(Kt) - n2 * n2, r2 = t2.radius * t2.radius;
          if (i2 > r2)
            return null;
          const s2 = Math.sqrt(r2 - i2), a2 = n2 - s2, o3 = n2 + s2;
          return a2 < 0 && o3 < 0 ? null : a2 < 0 ? this.at(o3, e2) : this.at(a2, e2);
        }
        intersectsSphere(t2) {
          return this.distanceSqToPoint(t2.center) <= t2.radius * t2.radius;
        }
        distanceToPlane(t2) {
          const e2 = t2.normal.dot(this.direction);
          if (0 === e2)
            return 0 === t2.distanceToPoint(this.origin) ? 0 : null;
          const n2 = -(this.origin.dot(t2.normal) + t2.constant) / e2;
          return n2 >= 0 ? n2 : null;
        }
        intersectPlane(t2, e2) {
          const n2 = this.distanceToPlane(t2);
          return null === n2 ? null : this.at(n2, e2);
        }
        intersectsPlane(t2) {
          const e2 = t2.distanceToPoint(this.origin);
          if (0 === e2)
            return true;
          return t2.normal.dot(this.direction) * e2 < 0;
        }
        intersectBox(t2, e2) {
          let n2, i2, r2, s2, a2, o3;
          const l2 = 1 / this.direction.x, c2 = 1 / this.direction.y, h2 = 1 / this.direction.z, u2 = this.origin;
          return l2 >= 0 ? (n2 = (t2.min.x - u2.x) * l2, i2 = (t2.max.x - u2.x) * l2) : (n2 = (t2.max.x - u2.x) * l2, i2 = (t2.min.x - u2.x) * l2), c2 >= 0 ? (r2 = (t2.min.y - u2.y) * c2, s2 = (t2.max.y - u2.y) * c2) : (r2 = (t2.max.y - u2.y) * c2, s2 = (t2.min.y - u2.y) * c2), n2 > s2 || r2 > i2 ? null : ((r2 > n2 || n2 != n2) && (n2 = r2), (s2 < i2 || i2 != i2) && (i2 = s2), h2 >= 0 ? (a2 = (t2.min.z - u2.z) * h2, o3 = (t2.max.z - u2.z) * h2) : (a2 = (t2.max.z - u2.z) * h2, o3 = (t2.min.z - u2.z) * h2), n2 > o3 || a2 > i2 ? null : ((a2 > n2 || n2 != n2) && (n2 = a2), (o3 < i2 || i2 != i2) && (i2 = o3), i2 < 0 ? null : this.at(n2 >= 0 ? n2 : i2, e2)));
        }
        intersectsBox(t2) {
          return null !== this.intersectBox(t2, Kt);
        }
        intersectTriangle(t2, e2, n2, i2, r2) {
          ne.subVectors(e2, t2), ie.subVectors(n2, t2), re.crossVectors(ne, ie);
          let s2, a2 = this.direction.dot(re);
          if (a2 > 0) {
            if (i2)
              return null;
            s2 = 1;
          } else {
            if (!(a2 < 0))
              return null;
            s2 = -1, a2 = -a2;
          }
          ee.subVectors(this.origin, t2);
          const o3 = s2 * this.direction.dot(ie.crossVectors(ee, ie));
          if (o3 < 0)
            return null;
          const l2 = s2 * this.direction.dot(ne.cross(ee));
          if (l2 < 0)
            return null;
          if (o3 + l2 > a2)
            return null;
          const c2 = -s2 * ee.dot(re);
          return c2 < 0 ? null : this.at(c2 / a2, r2);
        }
        applyMatrix4(t2) {
          return this.origin.applyMatrix4(t2), this.direction.transformDirection(t2), this;
        }
        equals(t2) {
          return t2.origin.equals(this.origin) && t2.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class ae {
        constructor() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
        set(t2, e2, n2, i2, r2, s2, a2, o3, l2, c2, h2, u2, d2, p2, m2, f2) {
          const g2 = this.elements;
          return g2[0] = t2, g2[4] = e2, g2[8] = n2, g2[12] = i2, g2[1] = r2, g2[5] = s2, g2[9] = a2, g2[13] = o3, g2[2] = l2, g2[6] = c2, g2[10] = h2, g2[14] = u2, g2[3] = d2, g2[7] = p2, g2[11] = m2, g2[15] = f2, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ae().fromArray(this.elements);
        }
        copy(t2) {
          const e2 = this.elements, n2 = t2.elements;
          return e2[0] = n2[0], e2[1] = n2[1], e2[2] = n2[2], e2[3] = n2[3], e2[4] = n2[4], e2[5] = n2[5], e2[6] = n2[6], e2[7] = n2[7], e2[8] = n2[8], e2[9] = n2[9], e2[10] = n2[10], e2[11] = n2[11], e2[12] = n2[12], e2[13] = n2[13], e2[14] = n2[14], e2[15] = n2[15], this;
        }
        copyPosition(t2) {
          const e2 = this.elements, n2 = t2.elements;
          return e2[12] = n2[12], e2[13] = n2[13], e2[14] = n2[14], this;
        }
        setFromMatrix3(t2) {
          const e2 = t2.elements;
          return this.set(e2[0], e2[3], e2[6], 0, e2[1], e2[4], e2[7], 0, e2[2], e2[5], e2[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(t2, e2, n2) {
          return t2.setFromMatrixColumn(this, 0), e2.setFromMatrixColumn(this, 1), n2.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(t2, e2, n2) {
          return this.set(t2.x, e2.x, n2.x, 0, t2.y, e2.y, n2.y, 0, t2.z, e2.z, n2.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(t2) {
          const e2 = this.elements, n2 = t2.elements, i2 = 1 / oe.setFromMatrixColumn(t2, 0).length(), r2 = 1 / oe.setFromMatrixColumn(t2, 1).length(), s2 = 1 / oe.setFromMatrixColumn(t2, 2).length();
          return e2[0] = n2[0] * i2, e2[1] = n2[1] * i2, e2[2] = n2[2] * i2, e2[3] = 0, e2[4] = n2[4] * r2, e2[5] = n2[5] * r2, e2[6] = n2[6] * r2, e2[7] = 0, e2[8] = n2[8] * s2, e2[9] = n2[9] * s2, e2[10] = n2[10] * s2, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
        }
        makeRotationFromEuler(t2) {
          t2 && t2.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          const e2 = this.elements, n2 = t2.x, i2 = t2.y, r2 = t2.z, s2 = Math.cos(n2), a2 = Math.sin(n2), o3 = Math.cos(i2), l2 = Math.sin(i2), c2 = Math.cos(r2), h2 = Math.sin(r2);
          if ("XYZ" === t2.order) {
            const t3 = s2 * c2, n3 = s2 * h2, i3 = a2 * c2, r3 = a2 * h2;
            e2[0] = o3 * c2, e2[4] = -o3 * h2, e2[8] = l2, e2[1] = n3 + i3 * l2, e2[5] = t3 - r3 * l2, e2[9] = -a2 * o3, e2[2] = r3 - t3 * l2, e2[6] = i3 + n3 * l2, e2[10] = s2 * o3;
          } else if ("YXZ" === t2.order) {
            const t3 = o3 * c2, n3 = o3 * h2, i3 = l2 * c2, r3 = l2 * h2;
            e2[0] = t3 + r3 * a2, e2[4] = i3 * a2 - n3, e2[8] = s2 * l2, e2[1] = s2 * h2, e2[5] = s2 * c2, e2[9] = -a2, e2[2] = n3 * a2 - i3, e2[6] = r3 + t3 * a2, e2[10] = s2 * o3;
          } else if ("ZXY" === t2.order) {
            const t3 = o3 * c2, n3 = o3 * h2, i3 = l2 * c2, r3 = l2 * h2;
            e2[0] = t3 - r3 * a2, e2[4] = -s2 * h2, e2[8] = i3 + n3 * a2, e2[1] = n3 + i3 * a2, e2[5] = s2 * c2, e2[9] = r3 - t3 * a2, e2[2] = -s2 * l2, e2[6] = a2, e2[10] = s2 * o3;
          } else if ("ZYX" === t2.order) {
            const t3 = s2 * c2, n3 = s2 * h2, i3 = a2 * c2, r3 = a2 * h2;
            e2[0] = o3 * c2, e2[4] = i3 * l2 - n3, e2[8] = t3 * l2 + r3, e2[1] = o3 * h2, e2[5] = r3 * l2 + t3, e2[9] = n3 * l2 - i3, e2[2] = -l2, e2[6] = a2 * o3, e2[10] = s2 * o3;
          } else if ("YZX" === t2.order) {
            const t3 = s2 * o3, n3 = s2 * l2, i3 = a2 * o3, r3 = a2 * l2;
            e2[0] = o3 * c2, e2[4] = r3 - t3 * h2, e2[8] = i3 * h2 + n3, e2[1] = h2, e2[5] = s2 * c2, e2[9] = -a2 * c2, e2[2] = -l2 * c2, e2[6] = n3 * h2 + i3, e2[10] = t3 - r3 * h2;
          } else if ("XZY" === t2.order) {
            const t3 = s2 * o3, n3 = s2 * l2, i3 = a2 * o3, r3 = a2 * l2;
            e2[0] = o3 * c2, e2[4] = -h2, e2[8] = l2 * c2, e2[1] = t3 * h2 + r3, e2[5] = s2 * c2, e2[9] = n3 * h2 - i3, e2[2] = i3 * h2 - n3, e2[6] = a2 * c2, e2[10] = r3 * h2 + t3;
          }
          return e2[3] = 0, e2[7] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
        }
        makeRotationFromQuaternion(t2) {
          return this.compose(ce, t2, he);
        }
        lookAt(t2, e2, n2) {
          const i2 = this.elements;
          return pe.subVectors(t2, e2), 0 === pe.lengthSq() && (pe.z = 1), pe.normalize(), ue.crossVectors(n2, pe), 0 === ue.lengthSq() && (1 === Math.abs(n2.z) ? pe.x += 1e-4 : pe.z += 1e-4, pe.normalize(), ue.crossVectors(n2, pe)), ue.normalize(), de.crossVectors(pe, ue), i2[0] = ue.x, i2[4] = de.x, i2[8] = pe.x, i2[1] = ue.y, i2[5] = de.y, i2[9] = pe.y, i2[2] = ue.z, i2[6] = de.z, i2[10] = pe.z, this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t2, e2)) : this.multiplyMatrices(this, t2);
        }
        premultiply(t2) {
          return this.multiplyMatrices(t2, this);
        }
        multiplyMatrices(t2, e2) {
          const n2 = t2.elements, i2 = e2.elements, r2 = this.elements, s2 = n2[0], a2 = n2[4], o3 = n2[8], l2 = n2[12], c2 = n2[1], h2 = n2[5], u2 = n2[9], d2 = n2[13], p2 = n2[2], m2 = n2[6], f2 = n2[10], g2 = n2[14], v2 = n2[3], y2 = n2[7], x2 = n2[11], _2 = n2[15], b2 = i2[0], M2 = i2[4], w2 = i2[8], S2 = i2[12], T2 = i2[1], E2 = i2[5], A2 = i2[9], L2 = i2[13], R2 = i2[2], C2 = i2[6], P2 = i2[10], I2 = i2[14], D2 = i2[3], N2 = i2[7], z2 = i2[11], B2 = i2[15];
          return r2[0] = s2 * b2 + a2 * T2 + o3 * R2 + l2 * D2, r2[4] = s2 * M2 + a2 * E2 + o3 * C2 + l2 * N2, r2[8] = s2 * w2 + a2 * A2 + o3 * P2 + l2 * z2, r2[12] = s2 * S2 + a2 * L2 + o3 * I2 + l2 * B2, r2[1] = c2 * b2 + h2 * T2 + u2 * R2 + d2 * D2, r2[5] = c2 * M2 + h2 * E2 + u2 * C2 + d2 * N2, r2[9] = c2 * w2 + h2 * A2 + u2 * P2 + d2 * z2, r2[13] = c2 * S2 + h2 * L2 + u2 * I2 + d2 * B2, r2[2] = p2 * b2 + m2 * T2 + f2 * R2 + g2 * D2, r2[6] = p2 * M2 + m2 * E2 + f2 * C2 + g2 * N2, r2[10] = p2 * w2 + m2 * A2 + f2 * P2 + g2 * z2, r2[14] = p2 * S2 + m2 * L2 + f2 * I2 + g2 * B2, r2[3] = v2 * b2 + y2 * T2 + x2 * R2 + _2 * D2, r2[7] = v2 * M2 + y2 * E2 + x2 * C2 + _2 * N2, r2[11] = v2 * w2 + y2 * A2 + x2 * P2 + _2 * z2, r2[15] = v2 * S2 + y2 * L2 + x2 * I2 + _2 * B2, this;
        }
        multiplyScalar(t2) {
          const e2 = this.elements;
          return e2[0] *= t2, e2[4] *= t2, e2[8] *= t2, e2[12] *= t2, e2[1] *= t2, e2[5] *= t2, e2[9] *= t2, e2[13] *= t2, e2[2] *= t2, e2[6] *= t2, e2[10] *= t2, e2[14] *= t2, e2[3] *= t2, e2[7] *= t2, e2[11] *= t2, e2[15] *= t2, this;
        }
        determinant() {
          const t2 = this.elements, e2 = t2[0], n2 = t2[4], i2 = t2[8], r2 = t2[12], s2 = t2[1], a2 = t2[5], o3 = t2[9], l2 = t2[13], c2 = t2[2], h2 = t2[6], u2 = t2[10], d2 = t2[14];
          return t2[3] * (+r2 * o3 * h2 - i2 * l2 * h2 - r2 * a2 * u2 + n2 * l2 * u2 + i2 * a2 * d2 - n2 * o3 * d2) + t2[7] * (+e2 * o3 * d2 - e2 * l2 * u2 + r2 * s2 * u2 - i2 * s2 * d2 + i2 * l2 * c2 - r2 * o3 * c2) + t2[11] * (+e2 * l2 * h2 - e2 * a2 * d2 - r2 * s2 * h2 + n2 * s2 * d2 + r2 * a2 * c2 - n2 * l2 * c2) + t2[15] * (-i2 * a2 * c2 - e2 * o3 * h2 + e2 * a2 * u2 + i2 * s2 * h2 - n2 * s2 * u2 + n2 * o3 * c2);
        }
        transpose() {
          const t2 = this.elements;
          let e2;
          return e2 = t2[1], t2[1] = t2[4], t2[4] = e2, e2 = t2[2], t2[2] = t2[8], t2[8] = e2, e2 = t2[6], t2[6] = t2[9], t2[9] = e2, e2 = t2[3], t2[3] = t2[12], t2[12] = e2, e2 = t2[7], t2[7] = t2[13], t2[13] = e2, e2 = t2[11], t2[11] = t2[14], t2[14] = e2, this;
        }
        setPosition(t2, e2, n2) {
          const i2 = this.elements;
          return t2.isVector3 ? (i2[12] = t2.x, i2[13] = t2.y, i2[14] = t2.z) : (i2[12] = t2, i2[13] = e2, i2[14] = n2), this;
        }
        invert() {
          const t2 = this.elements, e2 = t2[0], n2 = t2[1], i2 = t2[2], r2 = t2[3], s2 = t2[4], a2 = t2[5], o3 = t2[6], l2 = t2[7], c2 = t2[8], h2 = t2[9], u2 = t2[10], d2 = t2[11], p2 = t2[12], m2 = t2[13], f2 = t2[14], g2 = t2[15], v2 = h2 * f2 * l2 - m2 * u2 * l2 + m2 * o3 * d2 - a2 * f2 * d2 - h2 * o3 * g2 + a2 * u2 * g2, y2 = p2 * u2 * l2 - c2 * f2 * l2 - p2 * o3 * d2 + s2 * f2 * d2 + c2 * o3 * g2 - s2 * u2 * g2, x2 = c2 * m2 * l2 - p2 * h2 * l2 + p2 * a2 * d2 - s2 * m2 * d2 - c2 * a2 * g2 + s2 * h2 * g2, _2 = p2 * h2 * o3 - c2 * m2 * o3 - p2 * a2 * u2 + s2 * m2 * u2 + c2 * a2 * f2 - s2 * h2 * f2, b2 = e2 * v2 + n2 * y2 + i2 * x2 + r2 * _2;
          if (0 === b2)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const M2 = 1 / b2;
          return t2[0] = v2 * M2, t2[1] = (m2 * u2 * r2 - h2 * f2 * r2 - m2 * i2 * d2 + n2 * f2 * d2 + h2 * i2 * g2 - n2 * u2 * g2) * M2, t2[2] = (a2 * f2 * r2 - m2 * o3 * r2 + m2 * i2 * l2 - n2 * f2 * l2 - a2 * i2 * g2 + n2 * o3 * g2) * M2, t2[3] = (h2 * o3 * r2 - a2 * u2 * r2 - h2 * i2 * l2 + n2 * u2 * l2 + a2 * i2 * d2 - n2 * o3 * d2) * M2, t2[4] = y2 * M2, t2[5] = (c2 * f2 * r2 - p2 * u2 * r2 + p2 * i2 * d2 - e2 * f2 * d2 - c2 * i2 * g2 + e2 * u2 * g2) * M2, t2[6] = (p2 * o3 * r2 - s2 * f2 * r2 - p2 * i2 * l2 + e2 * f2 * l2 + s2 * i2 * g2 - e2 * o3 * g2) * M2, t2[7] = (s2 * u2 * r2 - c2 * o3 * r2 + c2 * i2 * l2 - e2 * u2 * l2 - s2 * i2 * d2 + e2 * o3 * d2) * M2, t2[8] = x2 * M2, t2[9] = (p2 * h2 * r2 - c2 * m2 * r2 - p2 * n2 * d2 + e2 * m2 * d2 + c2 * n2 * g2 - e2 * h2 * g2) * M2, t2[10] = (s2 * m2 * r2 - p2 * a2 * r2 + p2 * n2 * l2 - e2 * m2 * l2 - s2 * n2 * g2 + e2 * a2 * g2) * M2, t2[11] = (c2 * a2 * r2 - s2 * h2 * r2 - c2 * n2 * l2 + e2 * h2 * l2 + s2 * n2 * d2 - e2 * a2 * d2) * M2, t2[12] = _2 * M2, t2[13] = (c2 * m2 * i2 - p2 * h2 * i2 + p2 * n2 * u2 - e2 * m2 * u2 - c2 * n2 * f2 + e2 * h2 * f2) * M2, t2[14] = (p2 * a2 * i2 - s2 * m2 * i2 - p2 * n2 * o3 + e2 * m2 * o3 + s2 * n2 * f2 - e2 * a2 * f2) * M2, t2[15] = (s2 * h2 * i2 - c2 * a2 * i2 + c2 * n2 * o3 - e2 * h2 * o3 - s2 * n2 * u2 + e2 * a2 * u2) * M2, this;
        }
        scale(t2) {
          const e2 = this.elements, n2 = t2.x, i2 = t2.y, r2 = t2.z;
          return e2[0] *= n2, e2[4] *= i2, e2[8] *= r2, e2[1] *= n2, e2[5] *= i2, e2[9] *= r2, e2[2] *= n2, e2[6] *= i2, e2[10] *= r2, e2[3] *= n2, e2[7] *= i2, e2[11] *= r2, this;
        }
        getMaxScaleOnAxis() {
          const t2 = this.elements, e2 = t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2], n2 = t2[4] * t2[4] + t2[5] * t2[5] + t2[6] * t2[6], i2 = t2[8] * t2[8] + t2[9] * t2[9] + t2[10] * t2[10];
          return Math.sqrt(Math.max(e2, n2, i2));
        }
        makeTranslation(t2, e2, n2) {
          return this.set(1, 0, 0, t2, 0, 1, 0, e2, 0, 0, 1, n2, 0, 0, 0, 1), this;
        }
        makeRotationX(t2) {
          const e2 = Math.cos(t2), n2 = Math.sin(t2);
          return this.set(1, 0, 0, 0, 0, e2, -n2, 0, 0, n2, e2, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(t2) {
          const e2 = Math.cos(t2), n2 = Math.sin(t2);
          return this.set(e2, 0, n2, 0, 0, 1, 0, 0, -n2, 0, e2, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(t2) {
          const e2 = Math.cos(t2), n2 = Math.sin(t2);
          return this.set(e2, -n2, 0, 0, n2, e2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(t2, e2) {
          const n2 = Math.cos(e2), i2 = Math.sin(e2), r2 = 1 - n2, s2 = t2.x, a2 = t2.y, o3 = t2.z, l2 = r2 * s2, c2 = r2 * a2;
          return this.set(l2 * s2 + n2, l2 * a2 - i2 * o3, l2 * o3 + i2 * a2, 0, l2 * a2 + i2 * o3, c2 * a2 + n2, c2 * o3 - i2 * s2, 0, l2 * o3 - i2 * a2, c2 * o3 + i2 * s2, r2 * o3 * o3 + n2, 0, 0, 0, 0, 1), this;
        }
        makeScale(t2, e2, n2) {
          return this.set(t2, 0, 0, 0, 0, e2, 0, 0, 0, 0, n2, 0, 0, 0, 0, 1), this;
        }
        makeShear(t2, e2, n2, i2, r2, s2) {
          return this.set(1, n2, r2, 0, t2, 1, s2, 0, e2, i2, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t2, e2, n2) {
          const i2 = this.elements, r2 = e2._x, s2 = e2._y, a2 = e2._z, o3 = e2._w, l2 = r2 + r2, c2 = s2 + s2, h2 = a2 + a2, u2 = r2 * l2, d2 = r2 * c2, p2 = r2 * h2, m2 = s2 * c2, f2 = s2 * h2, g2 = a2 * h2, v2 = o3 * l2, y2 = o3 * c2, x2 = o3 * h2, _2 = n2.x, b2 = n2.y, M2 = n2.z;
          return i2[0] = (1 - (m2 + g2)) * _2, i2[1] = (d2 + x2) * _2, i2[2] = (p2 - y2) * _2, i2[3] = 0, i2[4] = (d2 - x2) * b2, i2[5] = (1 - (u2 + g2)) * b2, i2[6] = (f2 + v2) * b2, i2[7] = 0, i2[8] = (p2 + y2) * M2, i2[9] = (f2 - v2) * M2, i2[10] = (1 - (u2 + m2)) * M2, i2[11] = 0, i2[12] = t2.x, i2[13] = t2.y, i2[14] = t2.z, i2[15] = 1, this;
        }
        decompose(t2, e2, n2) {
          const i2 = this.elements;
          let r2 = oe.set(i2[0], i2[1], i2[2]).length();
          const s2 = oe.set(i2[4], i2[5], i2[6]).length(), a2 = oe.set(i2[8], i2[9], i2[10]).length();
          this.determinant() < 0 && (r2 = -r2), t2.x = i2[12], t2.y = i2[13], t2.z = i2[14], le.copy(this);
          const o3 = 1 / r2, l2 = 1 / s2, c2 = 1 / a2;
          return le.elements[0] *= o3, le.elements[1] *= o3, le.elements[2] *= o3, le.elements[4] *= l2, le.elements[5] *= l2, le.elements[6] *= l2, le.elements[8] *= c2, le.elements[9] *= c2, le.elements[10] *= c2, e2.setFromRotationMatrix(le), n2.x = r2, n2.y = s2, n2.z = a2, this;
        }
        makePerspective(t2, e2, n2, i2, r2, s2) {
          void 0 === s2 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          const a2 = this.elements, o3 = 2 * r2 / (e2 - t2), l2 = 2 * r2 / (n2 - i2), c2 = (e2 + t2) / (e2 - t2), h2 = (n2 + i2) / (n2 - i2), u2 = -(s2 + r2) / (s2 - r2), d2 = -2 * s2 * r2 / (s2 - r2);
          return a2[0] = o3, a2[4] = 0, a2[8] = c2, a2[12] = 0, a2[1] = 0, a2[5] = l2, a2[9] = h2, a2[13] = 0, a2[2] = 0, a2[6] = 0, a2[10] = u2, a2[14] = d2, a2[3] = 0, a2[7] = 0, a2[11] = -1, a2[15] = 0, this;
        }
        makeOrthographic(t2, e2, n2, i2, r2, s2) {
          const a2 = this.elements, o3 = 1 / (e2 - t2), l2 = 1 / (n2 - i2), c2 = 1 / (s2 - r2), h2 = (e2 + t2) * o3, u2 = (n2 + i2) * l2, d2 = (s2 + r2) * c2;
          return a2[0] = 2 * o3, a2[4] = 0, a2[8] = 0, a2[12] = -h2, a2[1] = 0, a2[5] = 2 * l2, a2[9] = 0, a2[13] = -u2, a2[2] = 0, a2[6] = 0, a2[10] = -2 * c2, a2[14] = -d2, a2[3] = 0, a2[7] = 0, a2[11] = 0, a2[15] = 1, this;
        }
        equals(t2) {
          const e2 = this.elements, n2 = t2.elements;
          for (let t3 = 0; t3 < 16; t3++)
            if (e2[t3] !== n2[t3])
              return false;
          return true;
        }
        fromArray(t2, e2 = 0) {
          for (let n2 = 0; n2 < 16; n2++)
            this.elements[n2] = t2[n2 + e2];
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const n2 = this.elements;
          return t2[e2] = n2[0], t2[e2 + 1] = n2[1], t2[e2 + 2] = n2[2], t2[e2 + 3] = n2[3], t2[e2 + 4] = n2[4], t2[e2 + 5] = n2[5], t2[e2 + 6] = n2[6], t2[e2 + 7] = n2[7], t2[e2 + 8] = n2[8], t2[e2 + 9] = n2[9], t2[e2 + 10] = n2[10], t2[e2 + 11] = n2[11], t2[e2 + 12] = n2[12], t2[e2 + 13] = n2[13], t2[e2 + 14] = n2[14], t2[e2 + 15] = n2[15], t2;
        }
      }
      ae.prototype.isMatrix4 = true;
      const oe = new Rt(), le = new ae(), ce = new Rt(0, 0, 0), he = new Rt(1, 1, 1), ue = new Rt(), de = new Rt(), pe = new Rt(), me = new ae(), fe = new Lt();
      class ge {
        constructor(t2 = 0, e2 = 0, n2 = 0, i2 = ge.DefaultOrder) {
          this._x = t2, this._y = e2, this._z = n2, this._order = i2;
        }
        get x() {
          return this._x;
        }
        set x(t2) {
          this._x = t2, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t2) {
          this._y = t2, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t2) {
          this._z = t2, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t2) {
          this._order = t2, this._onChangeCallback();
        }
        set(t2, e2, n2, i2 = this._order) {
          return this._x = t2, this._y = e2, this._z = n2, this._order = i2, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t2) {
          return this._x = t2._x, this._y = t2._y, this._z = t2._z, this._order = t2._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t2, e2 = this._order, n2 = true) {
          const i2 = t2.elements, r2 = i2[0], s2 = i2[4], a2 = i2[8], o3 = i2[1], l2 = i2[5], c2 = i2[9], h2 = i2[2], u2 = i2[6], d2 = i2[10];
          switch (e2) {
            case "XYZ":
              this._y = Math.asin(ht(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-c2, d2), this._z = Math.atan2(-s2, r2)) : (this._x = Math.atan2(u2, l2), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-ht(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._y = Math.atan2(a2, d2), this._z = Math.atan2(o3, l2)) : (this._y = Math.atan2(-h2, r2), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(ht(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._y = Math.atan2(-h2, d2), this._z = Math.atan2(-s2, l2)) : (this._y = 0, this._z = Math.atan2(o3, r2));
              break;
            case "ZYX":
              this._y = Math.asin(-ht(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._x = Math.atan2(u2, d2), this._z = Math.atan2(o3, r2)) : (this._x = 0, this._z = Math.atan2(-s2, l2));
              break;
            case "YZX":
              this._z = Math.asin(ht(o3, -1, 1)), Math.abs(o3) < 0.9999999 ? (this._x = Math.atan2(-c2, l2), this._y = Math.atan2(-h2, r2)) : (this._x = 0, this._y = Math.atan2(a2, d2));
              break;
            case "XZY":
              this._z = Math.asin(-ht(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(u2, l2), this._y = Math.atan2(a2, r2)) : (this._x = Math.atan2(-c2, d2), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e2);
          }
          return this._order = e2, true === n2 && this._onChangeCallback(), this;
        }
        setFromQuaternion(t2, e2, n2) {
          return me.makeRotationFromQuaternion(t2), this.setFromRotationMatrix(me, e2, n2);
        }
        setFromVector3(t2, e2 = this._order) {
          return this.set(t2.x, t2.y, t2.z, e2);
        }
        reorder(t2) {
          return fe.setFromEuler(this), this.setFromQuaternion(fe, t2);
        }
        equals(t2) {
          return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._order === this._order;
        }
        fromArray(t2) {
          return this._x = t2[0], this._y = t2[1], this._z = t2[2], void 0 !== t2[3] && (this._order = t2[3]), this._onChangeCallback(), this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._order, t2;
        }
        toVector3(t2) {
          return t2 ? t2.set(this._x, this._y, this._z) : new Rt(this._x, this._y, this._z);
        }
        _onChange(t2) {
          return this._onChangeCallback = t2, this;
        }
        _onChangeCallback() {
        }
      }
      ge.prototype.isEuler = true, ge.DefaultOrder = "XYZ", ge.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class ve {
        constructor() {
          this.mask = 1;
        }
        set(t2) {
          this.mask = 1 << t2 | 0;
        }
        enable(t2) {
          this.mask |= 1 << t2 | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t2) {
          this.mask ^= 1 << t2 | 0;
        }
        disable(t2) {
          this.mask &= ~(1 << t2 | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t2) {
          return 0 != (this.mask & t2.mask);
        }
      }
      let ye = 0;
      const xe = new Rt(), _e = new Lt(), be = new ae(), Me = new Rt(), we = new Rt(), Se = new Rt(), Te = new Lt(), Ee = new Rt(1, 0, 0), Ae = new Rt(0, 1, 0), Le = new Rt(0, 0, 1), Re = { type: "added" }, Ce = { type: "removed" };
      class Pe extends rt {
        constructor() {
          super(), Object.defineProperty(this, "id", { value: ye++ }), this.uuid = ct(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Pe.DefaultUp.clone();
          const t2 = new Rt(), e2 = new ge(), n2 = new Lt(), i2 = new Rt(1, 1, 1);
          e2._onChange(function() {
            n2.setFromEuler(e2, false);
          }), n2._onChange(function() {
            e2.setFromQuaternion(n2, void 0, false);
          }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t2 }, rotation: { configurable: true, enumerable: true, value: e2 }, quaternion: { configurable: true, enumerable: true, value: n2 }, scale: { configurable: true, enumerable: true, value: i2 }, modelViewMatrix: { value: new ae() }, normalMatrix: { value: new yt() } }), this.matrix = new ae(), this.matrixWorld = new ae(), this.matrixAutoUpdate = Pe.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new ve(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(t2) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t2), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t2) {
          return this.quaternion.premultiply(t2), this;
        }
        setRotationFromAxisAngle(t2, e2) {
          this.quaternion.setFromAxisAngle(t2, e2);
        }
        setRotationFromEuler(t2) {
          this.quaternion.setFromEuler(t2, true);
        }
        setRotationFromMatrix(t2) {
          this.quaternion.setFromRotationMatrix(t2);
        }
        setRotationFromQuaternion(t2) {
          this.quaternion.copy(t2);
        }
        rotateOnAxis(t2, e2) {
          return _e.setFromAxisAngle(t2, e2), this.quaternion.multiply(_e), this;
        }
        rotateOnWorldAxis(t2, e2) {
          return _e.setFromAxisAngle(t2, e2), this.quaternion.premultiply(_e), this;
        }
        rotateX(t2) {
          return this.rotateOnAxis(Ee, t2);
        }
        rotateY(t2) {
          return this.rotateOnAxis(Ae, t2);
        }
        rotateZ(t2) {
          return this.rotateOnAxis(Le, t2);
        }
        translateOnAxis(t2, e2) {
          return xe.copy(t2).applyQuaternion(this.quaternion), this.position.add(xe.multiplyScalar(e2)), this;
        }
        translateX(t2) {
          return this.translateOnAxis(Ee, t2);
        }
        translateY(t2) {
          return this.translateOnAxis(Ae, t2);
        }
        translateZ(t2) {
          return this.translateOnAxis(Le, t2);
        }
        localToWorld(t2) {
          return t2.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t2) {
          return t2.applyMatrix4(be.copy(this.matrixWorld).invert());
        }
        lookAt(t2, e2, n2) {
          t2.isVector3 ? Me.copy(t2) : Me.set(t2, e2, n2);
          const i2 = this.parent;
          this.updateWorldMatrix(true, false), we.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? be.lookAt(we, Me, this.up) : be.lookAt(Me, we, this.up), this.quaternion.setFromRotationMatrix(be), i2 && (be.extractRotation(i2.matrixWorld), _e.setFromRotationMatrix(be), this.quaternion.premultiply(_e.invert()));
        }
        add(t2) {
          if (arguments.length > 1) {
            for (let t3 = 0; t3 < arguments.length; t3++)
              this.add(arguments[t3]);
            return this;
          }
          return t2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t2), this) : (t2 && t2.isObject3D ? (null !== t2.parent && t2.parent.remove(t2), t2.parent = this, this.children.push(t2), t2.dispatchEvent(Re)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t2), this);
        }
        remove(t2) {
          if (arguments.length > 1) {
            for (let t3 = 0; t3 < arguments.length; t3++)
              this.remove(arguments[t3]);
            return this;
          }
          const e2 = this.children.indexOf(t2);
          return -1 !== e2 && (t2.parent = null, this.children.splice(e2, 1), t2.dispatchEvent(Ce)), this;
        }
        removeFromParent() {
          const t2 = this.parent;
          return null !== t2 && t2.remove(this), this;
        }
        clear() {
          for (let t2 = 0; t2 < this.children.length; t2++) {
            const e2 = this.children[t2];
            e2.parent = null, e2.dispatchEvent(Ce);
          }
          return this.children.length = 0, this;
        }
        attach(t2) {
          return this.updateWorldMatrix(true, false), be.copy(this.matrixWorld).invert(), null !== t2.parent && (t2.parent.updateWorldMatrix(true, false), be.multiply(t2.parent.matrixWorld)), t2.applyMatrix4(be), this.add(t2), t2.updateWorldMatrix(false, true), this;
        }
        getObjectById(t2) {
          return this.getObjectByProperty("id", t2);
        }
        getObjectByName(t2) {
          return this.getObjectByProperty("name", t2);
        }
        getObjectByProperty(t2, e2) {
          if (this[t2] === e2)
            return this;
          for (let n2 = 0, i2 = this.children.length; n2 < i2; n2++) {
            const i3 = this.children[n2].getObjectByProperty(t2, e2);
            if (void 0 !== i3)
              return i3;
          }
        }
        getWorldPosition(t2) {
          return this.updateWorldMatrix(true, false), t2.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(t2) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(we, t2, Se), t2;
        }
        getWorldScale(t2) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(we, Te, t2), t2;
        }
        getWorldDirection(t2) {
          this.updateWorldMatrix(true, false);
          const e2 = this.matrixWorld.elements;
          return t2.set(e2[8], e2[9], e2[10]).normalize();
        }
        raycast() {
        }
        traverse(t2) {
          t2(this);
          const e2 = this.children;
          for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
            e2[n2].traverse(t2);
        }
        traverseVisible(t2) {
          if (false === this.visible)
            return;
          t2(this);
          const e2 = this.children;
          for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
            e2[n2].traverseVisible(t2);
        }
        traverseAncestors(t2) {
          const e2 = this.parent;
          null !== e2 && (t2(e2), e2.traverseAncestors(t2));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(t2) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t2) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t2 = true);
          const e2 = this.children;
          for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
            e2[n2].updateMatrixWorld(t2);
        }
        updateWorldMatrix(t2, e2) {
          const n2 = this.parent;
          if (true === t2 && null !== n2 && n2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === e2) {
            const t3 = this.children;
            for (let e3 = 0, n3 = t3.length; e3 < n3; e3++)
              t3[e3].updateWorldMatrix(false, true);
          }
        }
        toJSON(t2) {
          const e2 = void 0 === t2 || "string" == typeof t2, n2 = {};
          e2 && (t2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
          const i2 = {};
          function r2(e3, n3) {
            return void 0 === e3[n3.uuid] && (e3[n3.uuid] = n3.toJSON(t2)), n3.uuid;
          }
          if (i2.uuid = this.uuid, i2.type = this.type, "" !== this.name && (i2.name = this.name), true === this.castShadow && (i2.castShadow = true), true === this.receiveShadow && (i2.receiveShadow = true), false === this.visible && (i2.visible = false), false === this.frustumCulled && (i2.frustumCulled = false), 0 !== this.renderOrder && (i2.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i2.userData = this.userData), i2.layers = this.layers.mask, i2.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (i2.matrixAutoUpdate = false), this.isInstancedMesh && (i2.type = "InstancedMesh", i2.count = this.count, i2.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i2.instanceColor = this.instanceColor.toJSON())), this.isScene)
            this.background && (this.background.isColor ? i2.background = this.background.toJSON() : this.background.isTexture && (i2.background = this.background.toJSON(t2).uuid)), this.environment && this.environment.isTexture && (i2.environment = this.environment.toJSON(t2).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i2.geometry = r2(t2.geometries, this.geometry);
            const e3 = this.geometry.parameters;
            if (void 0 !== e3 && void 0 !== e3.shapes) {
              const n3 = e3.shapes;
              if (Array.isArray(n3))
                for (let e4 = 0, i3 = n3.length; e4 < i3; e4++) {
                  const i4 = n3[e4];
                  r2(t2.shapes, i4);
                }
              else
                r2(t2.shapes, n3);
            }
          }
          if (this.isSkinnedMesh && (i2.bindMode = this.bindMode, i2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r2(t2.skeletons, this.skeleton), i2.skeleton = this.skeleton.uuid)), void 0 !== this.material)
            if (Array.isArray(this.material)) {
              const e3 = [];
              for (let n3 = 0, i3 = this.material.length; n3 < i3; n3++)
                e3.push(r2(t2.materials, this.material[n3]));
              i2.material = e3;
            } else
              i2.material = r2(t2.materials, this.material);
          if (this.children.length > 0) {
            i2.children = [];
            for (let e3 = 0; e3 < this.children.length; e3++)
              i2.children.push(this.children[e3].toJSON(t2).object);
          }
          if (this.animations.length > 0) {
            i2.animations = [];
            for (let e3 = 0; e3 < this.animations.length; e3++) {
              const n3 = this.animations[e3];
              i2.animations.push(r2(t2.animations, n3));
            }
          }
          if (e2) {
            const e3 = s2(t2.geometries), i3 = s2(t2.materials), r3 = s2(t2.textures), a2 = s2(t2.images), o3 = s2(t2.shapes), l2 = s2(t2.skeletons), c2 = s2(t2.animations);
            e3.length > 0 && (n2.geometries = e3), i3.length > 0 && (n2.materials = i3), r3.length > 0 && (n2.textures = r3), a2.length > 0 && (n2.images = a2), o3.length > 0 && (n2.shapes = o3), l2.length > 0 && (n2.skeletons = l2), c2.length > 0 && (n2.animations = c2);
          }
          return n2.object = i2, n2;
          function s2(t3) {
            const e3 = [];
            for (const n3 in t3) {
              const i3 = t3[n3];
              delete i3.metadata, e3.push(i3);
            }
            return e3;
          }
        }
        clone(t2) {
          return new this.constructor().copy(this, t2);
        }
        copy(t2, e2 = true) {
          if (this.name = t2.name, this.up.copy(t2.up), this.position.copy(t2.position), this.rotation.order = t2.rotation.order, this.quaternion.copy(t2.quaternion), this.scale.copy(t2.scale), this.matrix.copy(t2.matrix), this.matrixWorld.copy(t2.matrixWorld), this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t2.matrixWorldNeedsUpdate, this.layers.mask = t2.layers.mask, this.visible = t2.visible, this.castShadow = t2.castShadow, this.receiveShadow = t2.receiveShadow, this.frustumCulled = t2.frustumCulled, this.renderOrder = t2.renderOrder, this.userData = JSON.parse(JSON.stringify(t2.userData)), true === e2)
            for (let e3 = 0; e3 < t2.children.length; e3++) {
              const n2 = t2.children[e3];
              this.add(n2.clone());
            }
          return this;
        }
      }
      Pe.DefaultUp = new Rt(0, 1, 0), Pe.DefaultMatrixAutoUpdate = true, Pe.prototype.isObject3D = true;
      const Ie = new Rt(), De = new Rt(), Ne = new Rt(), ze = new Rt(), Be = new Rt(), Fe = new Rt(), Oe = new Rt(), Ue = new Rt(), He = new Rt(), Ge = new Rt();
      class ke {
        constructor(t2 = new Rt(), e2 = new Rt(), n2 = new Rt()) {
          this.a = t2, this.b = e2, this.c = n2;
        }
        static getNormal(t2, e2, n2, i2) {
          i2.subVectors(n2, e2), Ie.subVectors(t2, e2), i2.cross(Ie);
          const r2 = i2.lengthSq();
          return r2 > 0 ? i2.multiplyScalar(1 / Math.sqrt(r2)) : i2.set(0, 0, 0);
        }
        static getBarycoord(t2, e2, n2, i2, r2) {
          Ie.subVectors(i2, e2), De.subVectors(n2, e2), Ne.subVectors(t2, e2);
          const s2 = Ie.dot(Ie), a2 = Ie.dot(De), o3 = Ie.dot(Ne), l2 = De.dot(De), c2 = De.dot(Ne), h2 = s2 * l2 - a2 * a2;
          if (0 === h2)
            return r2.set(-2, -1, -1);
          const u2 = 1 / h2, d2 = (l2 * o3 - a2 * c2) * u2, p2 = (s2 * c2 - a2 * o3) * u2;
          return r2.set(1 - d2 - p2, p2, d2);
        }
        static containsPoint(t2, e2, n2, i2) {
          return this.getBarycoord(t2, e2, n2, i2, ze), ze.x >= 0 && ze.y >= 0 && ze.x + ze.y <= 1;
        }
        static getUV(t2, e2, n2, i2, r2, s2, a2, o3) {
          return this.getBarycoord(t2, e2, n2, i2, ze), o3.set(0, 0), o3.addScaledVector(r2, ze.x), o3.addScaledVector(s2, ze.y), o3.addScaledVector(a2, ze.z), o3;
        }
        static isFrontFacing(t2, e2, n2, i2) {
          return Ie.subVectors(n2, e2), De.subVectors(t2, e2), Ie.cross(De).dot(i2) < 0;
        }
        set(t2, e2, n2) {
          return this.a.copy(t2), this.b.copy(e2), this.c.copy(n2), this;
        }
        setFromPointsAndIndices(t2, e2, n2, i2) {
          return this.a.copy(t2[e2]), this.b.copy(t2[n2]), this.c.copy(t2[i2]), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.a.copy(t2.a), this.b.copy(t2.b), this.c.copy(t2.c), this;
        }
        getArea() {
          return Ie.subVectors(this.c, this.b), De.subVectors(this.a, this.b), 0.5 * Ie.cross(De).length();
        }
        getMidpoint(t2) {
          return t2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(t2) {
          return ke.getNormal(this.a, this.b, this.c, t2);
        }
        getPlane(t2) {
          return t2.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t2, e2) {
          return ke.getBarycoord(t2, this.a, this.b, this.c, e2);
        }
        getUV(t2, e2, n2, i2, r2) {
          return ke.getUV(t2, this.a, this.b, this.c, e2, n2, i2, r2);
        }
        containsPoint(t2) {
          return ke.containsPoint(t2, this.a, this.b, this.c);
        }
        isFrontFacing(t2) {
          return ke.isFrontFacing(this.a, this.b, this.c, t2);
        }
        intersectsBox(t2) {
          return t2.intersectsTriangle(this);
        }
        closestPointToPoint(t2, e2) {
          const n2 = this.a, i2 = this.b, r2 = this.c;
          let s2, a2;
          Be.subVectors(i2, n2), Fe.subVectors(r2, n2), Ue.subVectors(t2, n2);
          const o3 = Be.dot(Ue), l2 = Fe.dot(Ue);
          if (o3 <= 0 && l2 <= 0)
            return e2.copy(n2);
          He.subVectors(t2, i2);
          const c2 = Be.dot(He), h2 = Fe.dot(He);
          if (c2 >= 0 && h2 <= c2)
            return e2.copy(i2);
          const u2 = o3 * h2 - c2 * l2;
          if (u2 <= 0 && o3 >= 0 && c2 <= 0)
            return s2 = o3 / (o3 - c2), e2.copy(n2).addScaledVector(Be, s2);
          Ge.subVectors(t2, r2);
          const d2 = Be.dot(Ge), p2 = Fe.dot(Ge);
          if (p2 >= 0 && d2 <= p2)
            return e2.copy(r2);
          const m2 = d2 * l2 - o3 * p2;
          if (m2 <= 0 && l2 >= 0 && p2 <= 0)
            return a2 = l2 / (l2 - p2), e2.copy(n2).addScaledVector(Fe, a2);
          const f2 = c2 * p2 - d2 * h2;
          if (f2 <= 0 && h2 - c2 >= 0 && d2 - p2 >= 0)
            return Oe.subVectors(r2, i2), a2 = (h2 - c2) / (h2 - c2 + (d2 - p2)), e2.copy(i2).addScaledVector(Oe, a2);
          const g2 = 1 / (f2 + m2 + u2);
          return s2 = m2 * g2, a2 = u2 * g2, e2.copy(n2).addScaledVector(Be, s2).addScaledVector(Fe, a2);
        }
        equals(t2) {
          return t2.a.equals(this.a) && t2.b.equals(this.b) && t2.c.equals(this.c);
        }
      }
      let Ve = 0;
      class We extends rt {
        constructor() {
          super(), Object.defineProperty(this, "id", { value: Ve++ }), this.uuid = ct(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.format = E, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = n, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = tt, this.stencilZFail = tt, this.stencilZPass = tt, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t2) {
          this._alphaTest > 0 != t2 > 0 && this.version++, this._alphaTest = t2;
        }
        onBuild() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t2) {
          if (void 0 !== t2)
            for (const e2 in t2) {
              const n2 = t2[e2];
              if (void 0 === n2) {
                console.warn("THREE.Material: '" + e2 + "' parameter is undefined.");
                continue;
              }
              if ("shading" === e2) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n2;
                continue;
              }
              const i2 = this[e2];
              void 0 !== i2 ? i2 && i2.isColor ? i2.set(n2) : i2 && i2.isVector3 && n2 && n2.isVector3 ? i2.copy(n2) : this[e2] = n2 : console.warn("THREE." + this.type + ": '" + e2 + "' is not a property of this material.");
            }
        }
        toJSON(t2) {
          const e2 = void 0 === t2 || "string" == typeof t2;
          e2 && (t2 = { textures: {}, images: {} });
          const n2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
          function i2(t3) {
            const e3 = [];
            for (const n3 in t3) {
              const i3 = t3[n3];
              delete i3.metadata, e3.push(i3);
            }
            return e3;
          }
          if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), this.color && this.color.isColor && (n2.color = this.color.getHex()), void 0 !== this.roughness && (n2.roughness = this.roughness), void 0 !== this.metalness && (n2.metalness = this.metalness), this.sheenTint && this.sheenTint.isColor && (n2.sheenTint = this.sheenTint.getHex()), this.emissive && this.emissive.isColor && (n2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n2.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n2.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (n2.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (n2.shininess = this.shininess), void 0 !== this.clearcoat && (n2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n2.clearcoatMap = this.clearcoatMap.toJSON(t2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t2).uuid, n2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n2.map = this.map.toJSON(t2).uuid), this.matcap && this.matcap.isTexture && (n2.matcap = this.matcap.toJSON(t2).uuid), this.alphaMap && this.alphaMap.isTexture && (n2.alphaMap = this.alphaMap.toJSON(t2).uuid), this.lightMap && this.lightMap.isTexture && (n2.lightMap = this.lightMap.toJSON(t2).uuid, n2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n2.aoMap = this.aoMap.toJSON(t2).uuid, n2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n2.bumpMap = this.bumpMap.toJSON(t2).uuid, n2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n2.normalMap = this.normalMap.toJSON(t2).uuid, n2.normalMapType = this.normalMapType, n2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n2.displacementMap = this.displacementMap.toJSON(t2).uuid, n2.displacementScale = this.displacementScale, n2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n2.roughnessMap = this.roughnessMap.toJSON(t2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n2.metalnessMap = this.metalnessMap.toJSON(t2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n2.emissiveMap = this.emissiveMap.toJSON(t2).uuid), this.specularMap && this.specularMap.isTexture && (n2.specularMap = this.specularMap.toJSON(t2).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n2.specularIntensityMap = this.specularIntensityMap.toJSON(t2).uuid), this.specularTintMap && this.specularTintMap.isTexture && (n2.specularTintMap = this.specularTintMap.toJSON(t2).uuid), this.envMap && this.envMap.isTexture && (n2.envMap = this.envMap.toJSON(t2).uuid, void 0 !== this.combine && (n2.combine = this.combine)), void 0 !== this.envMapIntensity && (n2.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n2.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n2.gradientMap = this.gradientMap.toJSON(t2).uuid), void 0 !== this.transmission && (n2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n2.transmissionMap = this.transmissionMap.toJSON(t2).uuid), void 0 !== this.thickness && (n2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n2.thicknessMap = this.thicknessMap.toJSON(t2).uuid), void 0 !== this.attenuationDistance && (n2.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (n2.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (n2.size = this.size), null !== this.shadowSide && (n2.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n2.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n2.blending = this.blending), 0 !== this.side && (n2.side = this.side), this.vertexColors && (n2.vertexColors = true), this.opacity < 1 && (n2.opacity = this.opacity), this.format !== E && (n2.format = this.format), true === this.transparent && (n2.transparent = this.transparent), n2.depthFunc = this.depthFunc, n2.depthTest = this.depthTest, n2.depthWrite = this.depthWrite, n2.colorWrite = this.colorWrite, n2.stencilWrite = this.stencilWrite, n2.stencilWriteMask = this.stencilWriteMask, n2.stencilFunc = this.stencilFunc, n2.stencilRef = this.stencilRef, n2.stencilFuncMask = this.stencilFuncMask, n2.stencilFail = this.stencilFail, n2.stencilZFail = this.stencilZFail, n2.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n2.rotation = this.rotation), true === this.polygonOffset && (n2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (n2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n2.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n2.linewidth = this.linewidth), void 0 !== this.dashSize && (n2.dashSize = this.dashSize), void 0 !== this.gapSize && (n2.gapSize = this.gapSize), void 0 !== this.scale && (n2.scale = this.scale), true === this.dithering && (n2.dithering = true), this.alphaTest > 0 && (n2.alphaTest = this.alphaTest), true === this.alphaToCoverage && (n2.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (n2.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (n2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n2.wireframeLinejoin = this.wireframeLinejoin), true === this.flatShading && (n2.flatShading = this.flatShading), false === this.visible && (n2.visible = false), false === this.toneMapped && (n2.toneMapped = false), "{}" !== JSON.stringify(this.userData) && (n2.userData = this.userData), e2) {
            const e3 = i2(t2.textures), r2 = i2(t2.images);
            e3.length > 0 && (n2.textures = e3), r2.length > 0 && (n2.images = r2);
          }
          return n2;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          this.name = t2.name, this.fog = t2.fog, this.blending = t2.blending, this.side = t2.side, this.vertexColors = t2.vertexColors, this.opacity = t2.opacity, this.format = t2.format, this.transparent = t2.transparent, this.blendSrc = t2.blendSrc, this.blendDst = t2.blendDst, this.blendEquation = t2.blendEquation, this.blendSrcAlpha = t2.blendSrcAlpha, this.blendDstAlpha = t2.blendDstAlpha, this.blendEquationAlpha = t2.blendEquationAlpha, this.depthFunc = t2.depthFunc, this.depthTest = t2.depthTest, this.depthWrite = t2.depthWrite, this.stencilWriteMask = t2.stencilWriteMask, this.stencilFunc = t2.stencilFunc, this.stencilRef = t2.stencilRef, this.stencilFuncMask = t2.stencilFuncMask, this.stencilFail = t2.stencilFail, this.stencilZFail = t2.stencilZFail, this.stencilZPass = t2.stencilZPass, this.stencilWrite = t2.stencilWrite;
          const e2 = t2.clippingPlanes;
          let n2 = null;
          if (null !== e2) {
            const t3 = e2.length;
            n2 = new Array(t3);
            for (let i2 = 0; i2 !== t3; ++i2)
              n2[i2] = e2[i2].clone();
          }
          return this.clippingPlanes = n2, this.clipIntersection = t2.clipIntersection, this.clipShadows = t2.clipShadows, this.shadowSide = t2.shadowSide, this.colorWrite = t2.colorWrite, this.precision = t2.precision, this.polygonOffset = t2.polygonOffset, this.polygonOffsetFactor = t2.polygonOffsetFactor, this.polygonOffsetUnits = t2.polygonOffsetUnits, this.dithering = t2.dithering, this.alphaTest = t2.alphaTest, this.alphaToCoverage = t2.alphaToCoverage, this.premultipliedAlpha = t2.premultipliedAlpha, this.visible = t2.visible, this.toneMapped = t2.toneMapped, this.userData = JSON.parse(JSON.stringify(t2.userData)), this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
      }
      We.prototype.isMaterial = true;
      const je = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, qe = { h: 0, s: 0, l: 0 }, Xe = { h: 0, s: 0, l: 0 };
      function Ye(t2, e2, n2) {
        return n2 < 0 && (n2 += 1), n2 > 1 && (n2 -= 1), n2 < 1 / 6 ? t2 + 6 * (e2 - t2) * n2 : n2 < 0.5 ? e2 : n2 < 2 / 3 ? t2 + 6 * (e2 - t2) * (2 / 3 - n2) : t2;
      }
      function Je(t2) {
        return t2 < 0.04045 ? 0.0773993808 * t2 : Math.pow(0.9478672986 * t2 + 0.0521327014, 2.4);
      }
      function Ze(t2) {
        return t2 < 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 0.41666) - 0.055;
      }
      class Qe {
        constructor(t2, e2, n2) {
          return void 0 === e2 && void 0 === n2 ? this.set(t2) : this.setRGB(t2, e2, n2);
        }
        set(t2) {
          return t2 && t2.isColor ? this.copy(t2) : "number" == typeof t2 ? this.setHex(t2) : "string" == typeof t2 && this.setStyle(t2), this;
        }
        setScalar(t2) {
          return this.r = t2, this.g = t2, this.b = t2, this;
        }
        setHex(t2) {
          return t2 = Math.floor(t2), this.r = (t2 >> 16 & 255) / 255, this.g = (t2 >> 8 & 255) / 255, this.b = (255 & t2) / 255, this;
        }
        setRGB(t2, e2, n2) {
          return this.r = t2, this.g = e2, this.b = n2, this;
        }
        setHSL(t2, e2, n2) {
          if (t2 = ut(t2, 1), e2 = ht(e2, 0, 1), n2 = ht(n2, 0, 1), 0 === e2)
            this.r = this.g = this.b = n2;
          else {
            const i2 = n2 <= 0.5 ? n2 * (1 + e2) : n2 + e2 - n2 * e2, r2 = 2 * n2 - i2;
            this.r = Ye(r2, i2, t2 + 1 / 3), this.g = Ye(r2, i2, t2), this.b = Ye(r2, i2, t2 - 1 / 3);
          }
          return this;
        }
        setStyle(t2) {
          function e2(e3) {
            void 0 !== e3 && parseFloat(e3) < 1 && console.warn("THREE.Color: Alpha component of " + t2 + " will be ignored.");
          }
          let n2;
          if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t2)) {
            let t3;
            const i2 = n2[1], r2 = n2[2];
            switch (i2) {
              case "rgb":
              case "rgba":
                if (t3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2))
                  return this.r = Math.min(255, parseInt(t3[1], 10)) / 255, this.g = Math.min(255, parseInt(t3[2], 10)) / 255, this.b = Math.min(255, parseInt(t3[3], 10)) / 255, e2(t3[4]), this;
                if (t3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2))
                  return this.r = Math.min(100, parseInt(t3[1], 10)) / 100, this.g = Math.min(100, parseInt(t3[2], 10)) / 100, this.b = Math.min(100, parseInt(t3[3], 10)) / 100, e2(t3[4]), this;
                break;
              case "hsl":
              case "hsla":
                if (t3 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) {
                  const n3 = parseFloat(t3[1]) / 360, i3 = parseInt(t3[2], 10) / 100, r3 = parseInt(t3[3], 10) / 100;
                  return e2(t3[4]), this.setHSL(n3, i3, r3);
                }
            }
          } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(t2)) {
            const t3 = n2[1], e3 = t3.length;
            if (3 === e3)
              return this.r = parseInt(t3.charAt(0) + t3.charAt(0), 16) / 255, this.g = parseInt(t3.charAt(1) + t3.charAt(1), 16) / 255, this.b = parseInt(t3.charAt(2) + t3.charAt(2), 16) / 255, this;
            if (6 === e3)
              return this.r = parseInt(t3.charAt(0) + t3.charAt(1), 16) / 255, this.g = parseInt(t3.charAt(2) + t3.charAt(3), 16) / 255, this.b = parseInt(t3.charAt(4) + t3.charAt(5), 16) / 255, this;
          }
          return t2 && t2.length > 0 ? this.setColorName(t2) : this;
        }
        setColorName(t2) {
          const e2 = je[t2.toLowerCase()];
          return void 0 !== e2 ? this.setHex(e2) : console.warn("THREE.Color: Unknown color " + t2), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t2) {
          return this.r = t2.r, this.g = t2.g, this.b = t2.b, this;
        }
        copyGammaToLinear(t2, e2 = 2) {
          return this.r = Math.pow(t2.r, e2), this.g = Math.pow(t2.g, e2), this.b = Math.pow(t2.b, e2), this;
        }
        copyLinearToGamma(t2, e2 = 2) {
          const n2 = e2 > 0 ? 1 / e2 : 1;
          return this.r = Math.pow(t2.r, n2), this.g = Math.pow(t2.g, n2), this.b = Math.pow(t2.b, n2), this;
        }
        convertGammaToLinear(t2) {
          return this.copyGammaToLinear(this, t2), this;
        }
        convertLinearToGamma(t2) {
          return this.copyLinearToGamma(this, t2), this;
        }
        copySRGBToLinear(t2) {
          return this.r = Je(t2.r), this.g = Je(t2.g), this.b = Je(t2.b), this;
        }
        copyLinearToSRGB(t2) {
          return this.r = Ze(t2.r), this.g = Ze(t2.g), this.b = Ze(t2.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(t2) {
          const e2 = this.r, n2 = this.g, i2 = this.b, r2 = Math.max(e2, n2, i2), s2 = Math.min(e2, n2, i2);
          let a2, o3;
          const l2 = (s2 + r2) / 2;
          if (s2 === r2)
            a2 = 0, o3 = 0;
          else {
            const t3 = r2 - s2;
            switch (o3 = l2 <= 0.5 ? t3 / (r2 + s2) : t3 / (2 - r2 - s2), r2) {
              case e2:
                a2 = (n2 - i2) / t3 + (n2 < i2 ? 6 : 0);
                break;
              case n2:
                a2 = (i2 - e2) / t3 + 2;
                break;
              case i2:
                a2 = (e2 - n2) / t3 + 4;
            }
            a2 /= 6;
          }
          return t2.h = a2, t2.s = o3, t2.l = l2, t2;
        }
        getStyle() {
          return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
        }
        offsetHSL(t2, e2, n2) {
          return this.getHSL(qe), qe.h += t2, qe.s += e2, qe.l += n2, this.setHSL(qe.h, qe.s, qe.l), this;
        }
        add(t2) {
          return this.r += t2.r, this.g += t2.g, this.b += t2.b, this;
        }
        addColors(t2, e2) {
          return this.r = t2.r + e2.r, this.g = t2.g + e2.g, this.b = t2.b + e2.b, this;
        }
        addScalar(t2) {
          return this.r += t2, this.g += t2, this.b += t2, this;
        }
        sub(t2) {
          return this.r = Math.max(0, this.r - t2.r), this.g = Math.max(0, this.g - t2.g), this.b = Math.max(0, this.b - t2.b), this;
        }
        multiply(t2) {
          return this.r *= t2.r, this.g *= t2.g, this.b *= t2.b, this;
        }
        multiplyScalar(t2) {
          return this.r *= t2, this.g *= t2, this.b *= t2, this;
        }
        lerp(t2, e2) {
          return this.r += (t2.r - this.r) * e2, this.g += (t2.g - this.g) * e2, this.b += (t2.b - this.b) * e2, this;
        }
        lerpColors(t2, e2, n2) {
          return this.r = t2.r + (e2.r - t2.r) * n2, this.g = t2.g + (e2.g - t2.g) * n2, this.b = t2.b + (e2.b - t2.b) * n2, this;
        }
        lerpHSL(t2, e2) {
          this.getHSL(qe), t2.getHSL(Xe);
          const n2 = dt(qe.h, Xe.h, e2), i2 = dt(qe.s, Xe.s, e2), r2 = dt(qe.l, Xe.l, e2);
          return this.setHSL(n2, i2, r2), this;
        }
        equals(t2) {
          return t2.r === this.r && t2.g === this.g && t2.b === this.b;
        }
        fromArray(t2, e2 = 0) {
          return this.r = t2[e2], this.g = t2[e2 + 1], this.b = t2[e2 + 2], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.r, t2[e2 + 1] = this.g, t2[e2 + 2] = this.b, t2;
        }
        fromBufferAttribute(t2, e2) {
          return this.r = t2.getX(e2), this.g = t2.getY(e2), this.b = t2.getZ(e2), true === t2.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
        }
        toJSON() {
          return this.getHex();
        }
      }
      Qe.NAMES = je, Qe.prototype.isColor = true, Qe.prototype.r = 1, Qe.prototype.g = 1, Qe.prototype.b = 1;
      class Ke extends We {
        constructor(t2) {
          super(), this.type = "MeshBasicMaterial", this.color = new Qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this;
        }
      }
      Ke.prototype.isMeshBasicMaterial = true;
      const $e = new Rt(), tn = new vt();
      class en {
        constructor(t2, e2, n2) {
          if (Array.isArray(t2))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.name = "", this.array = t2, this.itemSize = e2, this.count = void 0 !== t2 ? t2.length / e2 : 0, this.normalized = true === n2, this.usage = et, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
        setUsage(t2) {
          return this.usage = t2, this;
        }
        copy(t2) {
          return this.name = t2.name, this.array = new t2.array.constructor(t2.array), this.itemSize = t2.itemSize, this.count = t2.count, this.normalized = t2.normalized, this.usage = t2.usage, this;
        }
        copyAt(t2, e2, n2) {
          t2 *= this.itemSize, n2 *= e2.itemSize;
          for (let i2 = 0, r2 = this.itemSize; i2 < r2; i2++)
            this.array[t2 + i2] = e2.array[n2 + i2];
          return this;
        }
        copyArray(t2) {
          return this.array.set(t2), this;
        }
        copyColorsArray(t2) {
          const e2 = this.array;
          let n2 = 0;
          for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
            let r3 = t2[i2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2), r3 = new Qe()), e2[n2++] = r3.r, e2[n2++] = r3.g, e2[n2++] = r3.b;
          }
          return this;
        }
        copyVector2sArray(t2) {
          const e2 = this.array;
          let n2 = 0;
          for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
            let r3 = t2[i2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2), r3 = new vt()), e2[n2++] = r3.x, e2[n2++] = r3.y;
          }
          return this;
        }
        copyVector3sArray(t2) {
          const e2 = this.array;
          let n2 = 0;
          for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
            let r3 = t2[i2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2), r3 = new Rt()), e2[n2++] = r3.x, e2[n2++] = r3.y, e2[n2++] = r3.z;
          }
          return this;
        }
        copyVector4sArray(t2) {
          const e2 = this.array;
          let n2 = 0;
          for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
            let r3 = t2[i2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2), r3 = new St()), e2[n2++] = r3.x, e2[n2++] = r3.y, e2[n2++] = r3.z, e2[n2++] = r3.w;
          }
          return this;
        }
        applyMatrix3(t2) {
          if (2 === this.itemSize)
            for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
              tn.fromBufferAttribute(this, e2), tn.applyMatrix3(t2), this.setXY(e2, tn.x, tn.y);
          else if (3 === this.itemSize)
            for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
              $e.fromBufferAttribute(this, e2), $e.applyMatrix3(t2), this.setXYZ(e2, $e.x, $e.y, $e.z);
          return this;
        }
        applyMatrix4(t2) {
          for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
            $e.x = this.getX(e2), $e.y = this.getY(e2), $e.z = this.getZ(e2), $e.applyMatrix4(t2), this.setXYZ(e2, $e.x, $e.y, $e.z);
          return this;
        }
        applyNormalMatrix(t2) {
          for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
            $e.x = this.getX(e2), $e.y = this.getY(e2), $e.z = this.getZ(e2), $e.applyNormalMatrix(t2), this.setXYZ(e2, $e.x, $e.y, $e.z);
          return this;
        }
        transformDirection(t2) {
          for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
            $e.x = this.getX(e2), $e.y = this.getY(e2), $e.z = this.getZ(e2), $e.transformDirection(t2), this.setXYZ(e2, $e.x, $e.y, $e.z);
          return this;
        }
        set(t2, e2 = 0) {
          return this.array.set(t2, e2), this;
        }
        getX(t2) {
          return this.array[t2 * this.itemSize];
        }
        setX(t2, e2) {
          return this.array[t2 * this.itemSize] = e2, this;
        }
        getY(t2) {
          return this.array[t2 * this.itemSize + 1];
        }
        setY(t2, e2) {
          return this.array[t2 * this.itemSize + 1] = e2, this;
        }
        getZ(t2) {
          return this.array[t2 * this.itemSize + 2];
        }
        setZ(t2, e2) {
          return this.array[t2 * this.itemSize + 2] = e2, this;
        }
        getW(t2) {
          return this.array[t2 * this.itemSize + 3];
        }
        setW(t2, e2) {
          return this.array[t2 * this.itemSize + 3] = e2, this;
        }
        setXY(t2, e2, n2) {
          return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this;
        }
        setXYZ(t2, e2, n2, i2) {
          return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this.array[t2 + 2] = i2, this;
        }
        setXYZW(t2, e2, n2, i2, r2) {
          return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = n2, this.array[t2 + 2] = i2, this.array[t2 + 3] = r2, this;
        }
        onUpload(t2) {
          return this.onUploadCallback = t2, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
          return "" !== this.name && (t2.name = this.name), this.usage !== et && (t2.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t2.updateRange = this.updateRange), t2;
        }
      }
      en.prototype.isBufferAttribute = true;
      class nn extends en {
        constructor(t2, e2, n2) {
          super(new Int8Array(t2), e2, n2);
        }
      }
      class rn extends en {
        constructor(t2, e2, n2) {
          super(new Uint8Array(t2), e2, n2);
        }
      }
      class sn extends en {
        constructor(t2, e2, n2) {
          super(new Uint8ClampedArray(t2), e2, n2);
        }
      }
      class an extends en {
        constructor(t2, e2, n2) {
          super(new Int16Array(t2), e2, n2);
        }
      }
      class on extends en {
        constructor(t2, e2, n2) {
          super(new Uint16Array(t2), e2, n2);
        }
      }
      class ln extends en {
        constructor(t2, e2, n2) {
          super(new Int32Array(t2), e2, n2);
        }
      }
      class cn extends en {
        constructor(t2, e2, n2) {
          super(new Uint32Array(t2), e2, n2);
        }
      }
      class hn extends en {
        constructor(t2, e2, n2) {
          super(new Uint16Array(t2), e2, n2);
        }
      }
      hn.prototype.isFloat16BufferAttribute = true;
      class un extends en {
        constructor(t2, e2, n2) {
          super(new Float32Array(t2), e2, n2);
        }
      }
      class dn extends en {
        constructor(t2, e2, n2) {
          super(new Float64Array(t2), e2, n2);
        }
      }
      function pn(t2) {
        if (0 === t2.length)
          return -1 / 0;
        let e2 = t2[0];
        for (let n2 = 1, i2 = t2.length; n2 < i2; ++n2)
          t2[n2] > e2 && (e2 = t2[n2]);
        return e2;
      }
      const mn = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
      function fn(t2, e2) {
        return new mn[t2](e2);
      }
      let gn = 0;
      const vn = new ae(), yn = new Pe(), xn = new Rt(), _n = new It(), bn = new It(), Mn = new Rt();
      class wn extends rt {
        constructor() {
          super(), Object.defineProperty(this, "id", { value: gn++ }), this.uuid = ct(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(t2) {
          return Array.isArray(t2) ? this.index = new (pn(t2) > 65535 ? cn : on)(t2, 1) : this.index = t2, this;
        }
        getAttribute(t2) {
          return this.attributes[t2];
        }
        setAttribute(t2, e2) {
          return this.attributes[t2] = e2, this;
        }
        deleteAttribute(t2) {
          return delete this.attributes[t2], this;
        }
        hasAttribute(t2) {
          return void 0 !== this.attributes[t2];
        }
        addGroup(t2, e2, n2 = 0) {
          this.groups.push({ start: t2, count: e2, materialIndex: n2 });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t2, e2) {
          this.drawRange.start = t2, this.drawRange.count = e2;
        }
        applyMatrix4(t2) {
          const e2 = this.attributes.position;
          void 0 !== e2 && (e2.applyMatrix4(t2), e2.needsUpdate = true);
          const n2 = this.attributes.normal;
          if (void 0 !== n2) {
            const e3 = new yt().getNormalMatrix(t2);
            n2.applyNormalMatrix(e3), n2.needsUpdate = true;
          }
          const i2 = this.attributes.tangent;
          return void 0 !== i2 && (i2.transformDirection(t2), i2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
        }
        applyQuaternion(t2) {
          return vn.makeRotationFromQuaternion(t2), this.applyMatrix4(vn), this;
        }
        rotateX(t2) {
          return vn.makeRotationX(t2), this.applyMatrix4(vn), this;
        }
        rotateY(t2) {
          return vn.makeRotationY(t2), this.applyMatrix4(vn), this;
        }
        rotateZ(t2) {
          return vn.makeRotationZ(t2), this.applyMatrix4(vn), this;
        }
        translate(t2, e2, n2) {
          return vn.makeTranslation(t2, e2, n2), this.applyMatrix4(vn), this;
        }
        scale(t2, e2, n2) {
          return vn.makeScale(t2, e2, n2), this.applyMatrix4(vn), this;
        }
        lookAt(t2) {
          return yn.lookAt(t2), yn.updateMatrix(), this.applyMatrix4(yn.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(xn).negate(), this.translate(xn.x, xn.y, xn.z), this;
        }
        setFromPoints(t2) {
          const e2 = [];
          for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) {
            const i3 = t2[n2];
            e2.push(i3.x, i3.y, i3.z || 0);
          }
          return this.setAttribute("position", new un(e2, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new It());
          const t2 = this.attributes.position, e2 = this.morphAttributes.position;
          if (t2 && t2.isGLBufferAttribute)
            return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Rt(-1 / 0, -1 / 0, -1 / 0), new Rt(1 / 0, 1 / 0, 1 / 0));
          if (void 0 !== t2) {
            if (this.boundingBox.setFromBufferAttribute(t2), e2)
              for (let t3 = 0, n2 = e2.length; t3 < n2; t3++) {
                const n3 = e2[t3];
                _n.setFromBufferAttribute(n3), this.morphTargetsRelative ? (Mn.addVectors(this.boundingBox.min, _n.min), this.boundingBox.expandByPoint(Mn), Mn.addVectors(this.boundingBox.max, _n.max), this.boundingBox.expandByPoint(Mn)) : (this.boundingBox.expandByPoint(_n.min), this.boundingBox.expandByPoint(_n.max));
              }
          } else
            this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Qt());
          const t2 = this.attributes.position, e2 = this.morphAttributes.position;
          if (t2 && t2.isGLBufferAttribute)
            return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Rt(), 1 / 0);
          if (t2) {
            const n2 = this.boundingSphere.center;
            if (_n.setFromBufferAttribute(t2), e2)
              for (let t3 = 0, n3 = e2.length; t3 < n3; t3++) {
                const n4 = e2[t3];
                bn.setFromBufferAttribute(n4), this.morphTargetsRelative ? (Mn.addVectors(_n.min, bn.min), _n.expandByPoint(Mn), Mn.addVectors(_n.max, bn.max), _n.expandByPoint(Mn)) : (_n.expandByPoint(bn.min), _n.expandByPoint(bn.max));
              }
            _n.getCenter(n2);
            let i2 = 0;
            for (let e3 = 0, r2 = t2.count; e3 < r2; e3++)
              Mn.fromBufferAttribute(t2, e3), i2 = Math.max(i2, n2.distanceToSquared(Mn));
            if (e2)
              for (let r2 = 0, s2 = e2.length; r2 < s2; r2++) {
                const s3 = e2[r2], a2 = this.morphTargetsRelative;
                for (let e3 = 0, r3 = s3.count; e3 < r3; e3++)
                  Mn.fromBufferAttribute(s3, e3), a2 && (xn.fromBufferAttribute(t2, e3), Mn.add(xn)), i2 = Math.max(i2, n2.distanceToSquared(Mn));
              }
            this.boundingSphere.radius = Math.sqrt(i2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const t2 = this.index, e2 = this.attributes;
          if (null === t2 || void 0 === e2.position || void 0 === e2.normal || void 0 === e2.uv)
            return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          const n2 = t2.array, i2 = e2.position.array, r2 = e2.normal.array, s2 = e2.uv.array, a2 = i2.length / 3;
          void 0 === e2.tangent && this.setAttribute("tangent", new en(new Float32Array(4 * a2), 4));
          const o3 = e2.tangent.array, l2 = [], c2 = [];
          for (let t3 = 0; t3 < a2; t3++)
            l2[t3] = new Rt(), c2[t3] = new Rt();
          const h2 = new Rt(), u2 = new Rt(), d2 = new Rt(), p2 = new vt(), m2 = new vt(), f2 = new vt(), g2 = new Rt(), v2 = new Rt();
          function y2(t3, e3, n3) {
            h2.fromArray(i2, 3 * t3), u2.fromArray(i2, 3 * e3), d2.fromArray(i2, 3 * n3), p2.fromArray(s2, 2 * t3), m2.fromArray(s2, 2 * e3), f2.fromArray(s2, 2 * n3), u2.sub(h2), d2.sub(h2), m2.sub(p2), f2.sub(p2);
            const r3 = 1 / (m2.x * f2.y - f2.x * m2.y);
            isFinite(r3) && (g2.copy(u2).multiplyScalar(f2.y).addScaledVector(d2, -m2.y).multiplyScalar(r3), v2.copy(d2).multiplyScalar(m2.x).addScaledVector(u2, -f2.x).multiplyScalar(r3), l2[t3].add(g2), l2[e3].add(g2), l2[n3].add(g2), c2[t3].add(v2), c2[e3].add(v2), c2[n3].add(v2));
          }
          let x2 = this.groups;
          0 === x2.length && (x2 = [{ start: 0, count: n2.length }]);
          for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
            const e4 = x2[t3], i3 = e4.start;
            for (let t4 = i3, r3 = i3 + e4.count; t4 < r3; t4 += 3)
              y2(n2[t4 + 0], n2[t4 + 1], n2[t4 + 2]);
          }
          const _2 = new Rt(), b2 = new Rt(), M2 = new Rt(), w2 = new Rt();
          function S2(t3) {
            M2.fromArray(r2, 3 * t3), w2.copy(M2);
            const e3 = l2[t3];
            _2.copy(e3), _2.sub(M2.multiplyScalar(M2.dot(e3))).normalize(), b2.crossVectors(w2, e3);
            const n3 = b2.dot(c2[t3]) < 0 ? -1 : 1;
            o3[4 * t3] = _2.x, o3[4 * t3 + 1] = _2.y, o3[4 * t3 + 2] = _2.z, o3[4 * t3 + 3] = n3;
          }
          for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
            const e4 = x2[t3], i3 = e4.start;
            for (let t4 = i3, r3 = i3 + e4.count; t4 < r3; t4 += 3)
              S2(n2[t4 + 0]), S2(n2[t4 + 1]), S2(n2[t4 + 2]);
          }
        }
        computeVertexNormals() {
          const t2 = this.index, e2 = this.getAttribute("position");
          if (void 0 !== e2) {
            let n2 = this.getAttribute("normal");
            if (void 0 === n2)
              n2 = new en(new Float32Array(3 * e2.count), 3), this.setAttribute("normal", n2);
            else
              for (let t3 = 0, e3 = n2.count; t3 < e3; t3++)
                n2.setXYZ(t3, 0, 0, 0);
            const i2 = new Rt(), r2 = new Rt(), s2 = new Rt(), a2 = new Rt(), o3 = new Rt(), l2 = new Rt(), c2 = new Rt(), h2 = new Rt();
            if (t2)
              for (let u2 = 0, d2 = t2.count; u2 < d2; u2 += 3) {
                const d3 = t2.getX(u2 + 0), p2 = t2.getX(u2 + 1), m2 = t2.getX(u2 + 2);
                i2.fromBufferAttribute(e2, d3), r2.fromBufferAttribute(e2, p2), s2.fromBufferAttribute(e2, m2), c2.subVectors(s2, r2), h2.subVectors(i2, r2), c2.cross(h2), a2.fromBufferAttribute(n2, d3), o3.fromBufferAttribute(n2, p2), l2.fromBufferAttribute(n2, m2), a2.add(c2), o3.add(c2), l2.add(c2), n2.setXYZ(d3, a2.x, a2.y, a2.z), n2.setXYZ(p2, o3.x, o3.y, o3.z), n2.setXYZ(m2, l2.x, l2.y, l2.z);
              }
            else
              for (let t3 = 0, a3 = e2.count; t3 < a3; t3 += 3)
                i2.fromBufferAttribute(e2, t3 + 0), r2.fromBufferAttribute(e2, t3 + 1), s2.fromBufferAttribute(e2, t3 + 2), c2.subVectors(s2, r2), h2.subVectors(i2, r2), c2.cross(h2), n2.setXYZ(t3 + 0, c2.x, c2.y, c2.z), n2.setXYZ(t3 + 1, c2.x, c2.y, c2.z), n2.setXYZ(t3 + 2, c2.x, c2.y, c2.z);
            this.normalizeNormals(), n2.needsUpdate = true;
          }
        }
        merge(t2, e2) {
          if (!t2 || !t2.isBufferGeometry)
            return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t2);
          void 0 === e2 && (e2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
          const n2 = this.attributes;
          for (const i2 in n2) {
            if (void 0 === t2.attributes[i2])
              continue;
            const r2 = n2[i2].array, s2 = t2.attributes[i2], a2 = s2.array, o3 = s2.itemSize * e2, l2 = Math.min(a2.length, r2.length - o3);
            for (let t3 = 0, e3 = o3; t3 < l2; t3++, e3++)
              r2[e3] = a2[t3];
          }
          return this;
        }
        normalizeNormals() {
          const t2 = this.attributes.normal;
          for (let e2 = 0, n2 = t2.count; e2 < n2; e2++)
            Mn.fromBufferAttribute(t2, e2), Mn.normalize(), t2.setXYZ(e2, Mn.x, Mn.y, Mn.z);
        }
        toNonIndexed() {
          function t2(t3, e3) {
            const n3 = t3.array, i3 = t3.itemSize, r3 = t3.normalized, s3 = new n3.constructor(e3.length * i3);
            let a2 = 0, o3 = 0;
            for (let r4 = 0, l2 = e3.length; r4 < l2; r4++) {
              a2 = t3.isInterleavedBufferAttribute ? e3[r4] * t3.data.stride + t3.offset : e3[r4] * i3;
              for (let t4 = 0; t4 < i3; t4++)
                s3[o3++] = n3[a2++];
            }
            return new en(s3, i3, r3);
          }
          if (null === this.index)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const e2 = new wn(), n2 = this.index.array, i2 = this.attributes;
          for (const r3 in i2) {
            const s3 = t2(i2[r3], n2);
            e2.setAttribute(r3, s3);
          }
          const r2 = this.morphAttributes;
          for (const i3 in r2) {
            const s3 = [], a2 = r2[i3];
            for (let e3 = 0, i4 = a2.length; e3 < i4; e3++) {
              const i5 = t2(a2[e3], n2);
              s3.push(i5);
            }
            e2.morphAttributes[i3] = s3;
          }
          e2.morphTargetsRelative = this.morphTargetsRelative;
          const s2 = this.groups;
          for (let t3 = 0, n3 = s2.length; t3 < n3; t3++) {
            const n4 = s2[t3];
            e2.addGroup(n4.start, n4.count, n4.materialIndex);
          }
          return e2;
        }
        toJSON() {
          const t2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
          if (t2.uuid = this.uuid, t2.type = this.type, "" !== this.name && (t2.name = this.name), Object.keys(this.userData).length > 0 && (t2.userData = this.userData), void 0 !== this.parameters) {
            const e3 = this.parameters;
            for (const n3 in e3)
              void 0 !== e3[n3] && (t2[n3] = e3[n3]);
            return t2;
          }
          t2.data = { attributes: {} };
          const e2 = this.index;
          null !== e2 && (t2.data.index = { type: e2.array.constructor.name, array: Array.prototype.slice.call(e2.array) });
          const n2 = this.attributes;
          for (const e3 in n2) {
            const i3 = n2[e3];
            t2.data.attributes[e3] = i3.toJSON(t2.data);
          }
          const i2 = {};
          let r2 = false;
          for (const e3 in this.morphAttributes) {
            const n3 = this.morphAttributes[e3], s3 = [];
            for (let e4 = 0, i3 = n3.length; e4 < i3; e4++) {
              const i4 = n3[e4];
              s3.push(i4.toJSON(t2.data));
            }
            s3.length > 0 && (i2[e3] = s3, r2 = true);
          }
          r2 && (t2.data.morphAttributes = i2, t2.data.morphTargetsRelative = this.morphTargetsRelative);
          const s2 = this.groups;
          s2.length > 0 && (t2.data.groups = JSON.parse(JSON.stringify(s2)));
          const a2 = this.boundingSphere;
          return null !== a2 && (t2.data.boundingSphere = { center: a2.center.toArray(), radius: a2.radius }), t2;
        }
        clone() {
          return new wn().copy(this);
        }
        copy(t2) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const e2 = {};
          this.name = t2.name;
          const n2 = t2.index;
          null !== n2 && this.setIndex(n2.clone(e2));
          const i2 = t2.attributes;
          for (const t3 in i2) {
            const n3 = i2[t3];
            this.setAttribute(t3, n3.clone(e2));
          }
          const r2 = t2.morphAttributes;
          for (const t3 in r2) {
            const n3 = [], i3 = r2[t3];
            for (let t4 = 0, r3 = i3.length; t4 < r3; t4++)
              n3.push(i3[t4].clone(e2));
            this.morphAttributes[t3] = n3;
          }
          this.morphTargetsRelative = t2.morphTargetsRelative;
          const s2 = t2.groups;
          for (let t3 = 0, e3 = s2.length; t3 < e3; t3++) {
            const e4 = s2[t3];
            this.addGroup(e4.start, e4.count, e4.materialIndex);
          }
          const a2 = t2.boundingBox;
          null !== a2 && (this.boundingBox = a2.clone());
          const o3 = t2.boundingSphere;
          return null !== o3 && (this.boundingSphere = o3.clone()), this.drawRange.start = t2.drawRange.start, this.drawRange.count = t2.drawRange.count, this.userData = t2.userData, this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      wn.prototype.isBufferGeometry = true;
      const Sn = new ae(), Tn = new se(), En = new Qt(), An = new Rt(), Ln = new Rt(), Rn = new Rt(), Cn = new Rt(), Pn = new Rt(), In = new Rt(), Dn = new Rt(), Nn = new Rt(), zn = new Rt(), Bn = new vt(), Fn = new vt(), On = new vt(), Un = new Rt(), Hn = new Rt();
      class Gn extends Pe {
        constructor(t2 = new wn(), e2 = new Ke()) {
          super(), this.type = "Mesh", this.geometry = t2, this.material = e2, this.updateMorphTargets();
        }
        copy(t2) {
          return super.copy(t2), void 0 !== t2.morphTargetInfluences && (this.morphTargetInfluences = t2.morphTargetInfluences.slice()), void 0 !== t2.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t2.morphTargetDictionary)), this.material = t2.material, this.geometry = t2.geometry, this;
        }
        updateMorphTargets() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry) {
            const e2 = t2.morphAttributes, n2 = Object.keys(e2);
            if (n2.length > 0) {
              const t3 = e2[n2[0]];
              if (void 0 !== t3) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
                  const n4 = t3[e3].name || String(e3);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
                }
              }
            }
          } else {
            const e2 = t2.morphTargets;
            void 0 !== e2 && e2.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        raycast(t2, e2) {
          const n2 = this.geometry, i2 = this.material, r2 = this.matrixWorld;
          if (void 0 === i2)
            return;
          if (null === n2.boundingSphere && n2.computeBoundingSphere(), En.copy(n2.boundingSphere), En.applyMatrix4(r2), false === t2.ray.intersectsSphere(En))
            return;
          if (Sn.copy(r2).invert(), Tn.copy(t2.ray).applyMatrix4(Sn), null !== n2.boundingBox && false === Tn.intersectsBox(n2.boundingBox))
            return;
          let s2;
          if (n2.isBufferGeometry) {
            const r3 = n2.index, a2 = n2.attributes.position, o3 = n2.morphAttributes.position, l2 = n2.morphTargetsRelative, c2 = n2.attributes.uv, h2 = n2.attributes.uv2, u2 = n2.groups, d2 = n2.drawRange;
            if (null !== r3)
              if (Array.isArray(i2))
                for (let n3 = 0, p2 = u2.length; n3 < p2; n3++) {
                  const p3 = u2[n3], m2 = i2[p3.materialIndex];
                  for (let n4 = Math.max(p3.start, d2.start), i3 = Math.min(p3.start + p3.count, d2.start + d2.count); n4 < i3; n4 += 3) {
                    const i4 = r3.getX(n4), u3 = r3.getX(n4 + 1), d3 = r3.getX(n4 + 2);
                    s2 = kn(this, m2, t2, Tn, a2, o3, l2, c2, h2, i4, u3, d3), s2 && (s2.faceIndex = Math.floor(n4 / 3), s2.face.materialIndex = p3.materialIndex, e2.push(s2));
                  }
                }
              else {
                for (let n3 = Math.max(0, d2.start), u3 = Math.min(r3.count, d2.start + d2.count); n3 < u3; n3 += 3) {
                  const u4 = r3.getX(n3), d3 = r3.getX(n3 + 1), p2 = r3.getX(n3 + 2);
                  s2 = kn(this, i2, t2, Tn, a2, o3, l2, c2, h2, u4, d3, p2), s2 && (s2.faceIndex = Math.floor(n3 / 3), e2.push(s2));
                }
              }
            else if (void 0 !== a2)
              if (Array.isArray(i2))
                for (let n3 = 0, r4 = u2.length; n3 < r4; n3++) {
                  const r5 = u2[n3], p2 = i2[r5.materialIndex];
                  for (let n4 = Math.max(r5.start, d2.start), i3 = Math.min(r5.start + r5.count, d2.start + d2.count); n4 < i3; n4 += 3) {
                    s2 = kn(this, p2, t2, Tn, a2, o3, l2, c2, h2, n4, n4 + 1, n4 + 2), s2 && (s2.faceIndex = Math.floor(n4 / 3), s2.face.materialIndex = r5.materialIndex, e2.push(s2));
                  }
                }
              else {
                for (let n3 = Math.max(0, d2.start), r4 = Math.min(a2.count, d2.start + d2.count); n3 < r4; n3 += 3) {
                  s2 = kn(this, i2, t2, Tn, a2, o3, l2, c2, h2, n3, n3 + 1, n3 + 2), s2 && (s2.faceIndex = Math.floor(n3 / 3), e2.push(s2));
                }
              }
          } else
            n2.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
      function kn(t2, e2, n2, i2, r2, s2, a2, o3, l2, c2, h2, u2) {
        An.fromBufferAttribute(r2, c2), Ln.fromBufferAttribute(r2, h2), Rn.fromBufferAttribute(r2, u2);
        const d2 = t2.morphTargetInfluences;
        if (s2 && d2) {
          Dn.set(0, 0, 0), Nn.set(0, 0, 0), zn.set(0, 0, 0);
          for (let t3 = 0, e3 = s2.length; t3 < e3; t3++) {
            const e4 = d2[t3], n3 = s2[t3];
            0 !== e4 && (Cn.fromBufferAttribute(n3, c2), Pn.fromBufferAttribute(n3, h2), In.fromBufferAttribute(n3, u2), a2 ? (Dn.addScaledVector(Cn, e4), Nn.addScaledVector(Pn, e4), zn.addScaledVector(In, e4)) : (Dn.addScaledVector(Cn.sub(An), e4), Nn.addScaledVector(Pn.sub(Ln), e4), zn.addScaledVector(In.sub(Rn), e4)));
          }
          An.add(Dn), Ln.add(Nn), Rn.add(zn);
        }
        t2.isSkinnedMesh && (t2.boneTransform(c2, An), t2.boneTransform(h2, Ln), t2.boneTransform(u2, Rn));
        const p2 = function(t3, e3, n3, i3, r3, s3, a3, o4) {
          let l3;
          if (l3 = 1 === e3.side ? i3.intersectTriangle(a3, s3, r3, true, o4) : i3.intersectTriangle(r3, s3, a3, 2 !== e3.side, o4), null === l3)
            return null;
          Hn.copy(o4), Hn.applyMatrix4(t3.matrixWorld);
          const c3 = n3.ray.origin.distanceTo(Hn);
          return c3 < n3.near || c3 > n3.far ? null : { distance: c3, point: Hn.clone(), object: t3 };
        }(t2, e2, n2, i2, An, Ln, Rn, Un);
        if (p2) {
          o3 && (Bn.fromBufferAttribute(o3, c2), Fn.fromBufferAttribute(o3, h2), On.fromBufferAttribute(o3, u2), p2.uv = ke.getUV(Un, An, Ln, Rn, Bn, Fn, On, new vt())), l2 && (Bn.fromBufferAttribute(l2, c2), Fn.fromBufferAttribute(l2, h2), On.fromBufferAttribute(l2, u2), p2.uv2 = ke.getUV(Un, An, Ln, Rn, Bn, Fn, On, new vt()));
          const t3 = { a: c2, b: h2, c: u2, normal: new Rt(), materialIndex: 0 };
          ke.getNormal(An, Ln, Rn, t3.normal), p2.face = t3;
        }
        return p2;
      }
      Gn.prototype.isMesh = true;
      class Vn extends wn {
        constructor(t2 = 1, e2 = 1, n2 = 1, i2 = 1, r2 = 1, s2 = 1) {
          super(), this.type = "BoxGeometry", this.parameters = { width: t2, height: e2, depth: n2, widthSegments: i2, heightSegments: r2, depthSegments: s2 };
          const a2 = this;
          i2 = Math.floor(i2), r2 = Math.floor(r2), s2 = Math.floor(s2);
          const o3 = [], l2 = [], c2 = [], h2 = [];
          let u2 = 0, d2 = 0;
          function p2(t3, e3, n3, i3, r3, s3, p3, m2, f2, g2, v2) {
            const y2 = s3 / f2, x2 = p3 / g2, _2 = s3 / 2, b2 = p3 / 2, M2 = m2 / 2, w2 = f2 + 1, S2 = g2 + 1;
            let T2 = 0, E2 = 0;
            const A2 = new Rt();
            for (let s4 = 0; s4 < S2; s4++) {
              const a3 = s4 * x2 - b2;
              for (let o4 = 0; o4 < w2; o4++) {
                const u3 = o4 * y2 - _2;
                A2[t3] = u3 * i3, A2[e3] = a3 * r3, A2[n3] = M2, l2.push(A2.x, A2.y, A2.z), A2[t3] = 0, A2[e3] = 0, A2[n3] = m2 > 0 ? 1 : -1, c2.push(A2.x, A2.y, A2.z), h2.push(o4 / f2), h2.push(1 - s4 / g2), T2 += 1;
              }
            }
            for (let t4 = 0; t4 < g2; t4++)
              for (let e4 = 0; e4 < f2; e4++) {
                const n4 = u2 + e4 + w2 * t4, i4 = u2 + e4 + w2 * (t4 + 1), r4 = u2 + (e4 + 1) + w2 * (t4 + 1), s4 = u2 + (e4 + 1) + w2 * t4;
                o3.push(n4, i4, s4), o3.push(i4, r4, s4), E2 += 6;
              }
            a2.addGroup(d2, E2, v2), d2 += E2, u2 += T2;
          }
          p2("z", "y", "x", -1, -1, n2, e2, t2, s2, r2, 0), p2("z", "y", "x", 1, -1, n2, e2, -t2, s2, r2, 1), p2("x", "z", "y", 1, 1, t2, n2, e2, i2, s2, 2), p2("x", "z", "y", 1, -1, t2, n2, -e2, i2, s2, 3), p2("x", "y", "z", 1, -1, t2, e2, n2, i2, r2, 4), p2("x", "y", "z", -1, -1, t2, e2, -n2, i2, r2, 5), this.setIndex(o3), this.setAttribute("position", new un(l2, 3)), this.setAttribute("normal", new un(c2, 3)), this.setAttribute("uv", new un(h2, 2));
        }
        static fromJSON(t2) {
          return new Vn(t2.width, t2.height, t2.depth, t2.widthSegments, t2.heightSegments, t2.depthSegments);
        }
      }
      function Wn(t2) {
        const e2 = {};
        for (const n2 in t2) {
          e2[n2] = {};
          for (const i2 in t2[n2]) {
            const r2 = t2[n2][i2];
            r2 && (r2.isColor || r2.isMatrix3 || r2.isMatrix4 || r2.isVector2 || r2.isVector3 || r2.isVector4 || r2.isTexture || r2.isQuaternion) ? e2[n2][i2] = r2.clone() : Array.isArray(r2) ? e2[n2][i2] = r2.slice() : e2[n2][i2] = r2;
          }
        }
        return e2;
      }
      function jn(t2) {
        const e2 = {};
        for (let n2 = 0; n2 < t2.length; n2++) {
          const i2 = Wn(t2[n2]);
          for (const t3 in i2)
            e2[t3] = i2[t3];
        }
        return e2;
      }
      const qn = { clone: Wn, merge: jn };
      class Xn extends We {
        constructor(t2) {
          super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== t2 && (void 0 !== t2.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t2));
        }
        copy(t2) {
          return super.copy(t2), this.fragmentShader = t2.fragmentShader, this.vertexShader = t2.vertexShader, this.uniforms = Wn(t2.uniforms), this.defines = Object.assign({}, t2.defines), this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.lights = t2.lights, this.clipping = t2.clipping, this.extensions = Object.assign({}, t2.extensions), this.glslVersion = t2.glslVersion, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          e2.glslVersion = this.glslVersion, e2.uniforms = {};
          for (const n3 in this.uniforms) {
            const i2 = this.uniforms[n3].value;
            i2 && i2.isTexture ? e2.uniforms[n3] = { type: "t", value: i2.toJSON(t2).uuid } : i2 && i2.isColor ? e2.uniforms[n3] = { type: "c", value: i2.getHex() } : i2 && i2.isVector2 ? e2.uniforms[n3] = { type: "v2", value: i2.toArray() } : i2 && i2.isVector3 ? e2.uniforms[n3] = { type: "v3", value: i2.toArray() } : i2 && i2.isVector4 ? e2.uniforms[n3] = { type: "v4", value: i2.toArray() } : i2 && i2.isMatrix3 ? e2.uniforms[n3] = { type: "m3", value: i2.toArray() } : i2 && i2.isMatrix4 ? e2.uniforms[n3] = { type: "m4", value: i2.toArray() } : e2.uniforms[n3] = { value: i2 };
          }
          Object.keys(this.defines).length > 0 && (e2.defines = this.defines), e2.vertexShader = this.vertexShader, e2.fragmentShader = this.fragmentShader;
          const n2 = {};
          for (const t3 in this.extensions)
            true === this.extensions[t3] && (n2[t3] = true);
          return Object.keys(n2).length > 0 && (e2.extensions = n2), e2;
        }
      }
      Xn.prototype.isShaderMaterial = true;
      class Yn extends Pe {
        constructor() {
          super(), this.type = "Camera", this.matrixWorldInverse = new ae(), this.projectionMatrix = new ae(), this.projectionMatrixInverse = new ae();
        }
        copy(t2, e2) {
          return super.copy(t2, e2), this.matrixWorldInverse.copy(t2.matrixWorldInverse), this.projectionMatrix.copy(t2.projectionMatrix), this.projectionMatrixInverse.copy(t2.projectionMatrixInverse), this;
        }
        getWorldDirection(t2) {
          this.updateWorldMatrix(true, false);
          const e2 = this.matrixWorld.elements;
          return t2.set(-e2[8], -e2[9], -e2[10]).normalize();
        }
        updateMatrixWorld(t2) {
          super.updateMatrixWorld(t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t2, e2) {
          super.updateWorldMatrix(t2, e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Yn.prototype.isCamera = true;
      class Jn extends Yn {
        constructor(t2 = 50, e2 = 1, n2 = 0.1, i2 = 2e3) {
          super(), this.type = "PerspectiveCamera", this.fov = t2, this.zoom = 1, this.near = n2, this.far = i2, this.focus = 10, this.aspect = e2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(t2, e2) {
          return super.copy(t2, e2), this.fov = t2.fov, this.zoom = t2.zoom, this.near = t2.near, this.far = t2.far, this.focus = t2.focus, this.aspect = t2.aspect, this.view = null === t2.view ? null : Object.assign({}, t2.view), this.filmGauge = t2.filmGauge, this.filmOffset = t2.filmOffset, this;
        }
        setFocalLength(t2) {
          const e2 = 0.5 * this.getFilmHeight() / t2;
          this.fov = 2 * lt * Math.atan(e2), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t2 = Math.tan(0.5 * ot * this.fov);
          return 0.5 * this.getFilmHeight() / t2;
        }
        getEffectiveFOV() {
          return 2 * lt * Math.atan(Math.tan(0.5 * ot * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(t2, e2, n2, i2, r2, s2) {
          this.aspect = t2 / e2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = n2, this.view.offsetY = i2, this.view.width = r2, this.view.height = s2, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t2 = this.near;
          let e2 = t2 * Math.tan(0.5 * ot * this.fov) / this.zoom, n2 = 2 * e2, i2 = this.aspect * n2, r2 = -0.5 * i2;
          const s2 = this.view;
          if (null !== this.view && this.view.enabled) {
            const t3 = s2.fullWidth, a3 = s2.fullHeight;
            r2 += s2.offsetX * i2 / t3, e2 -= s2.offsetY * n2 / a3, i2 *= s2.width / t3, n2 *= s2.height / a3;
          }
          const a2 = this.filmOffset;
          0 !== a2 && (r2 += t2 * a2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r2, r2 + i2, e2, e2 - n2, t2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.fov = this.fov, e2.object.zoom = this.zoom, e2.object.near = this.near, e2.object.far = this.far, e2.object.focus = this.focus, e2.object.aspect = this.aspect, null !== this.view && (e2.object.view = Object.assign({}, this.view)), e2.object.filmGauge = this.filmGauge, e2.object.filmOffset = this.filmOffset, e2;
        }
      }
      Jn.prototype.isPerspectiveCamera = true;
      const Zn = 90;
      class Qn extends Pe {
        constructor(t2, e2, n2) {
          if (super(), this.type = "CubeCamera", true !== n2.isWebGLCubeRenderTarget)
            return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
          this.renderTarget = n2;
          const i2 = new Jn(Zn, 1, t2, e2);
          i2.layers = this.layers, i2.up.set(0, -1, 0), i2.lookAt(new Rt(1, 0, 0)), this.add(i2);
          const r2 = new Jn(Zn, 1, t2, e2);
          r2.layers = this.layers, r2.up.set(0, -1, 0), r2.lookAt(new Rt(-1, 0, 0)), this.add(r2);
          const s2 = new Jn(Zn, 1, t2, e2);
          s2.layers = this.layers, s2.up.set(0, 0, 1), s2.lookAt(new Rt(0, 1, 0)), this.add(s2);
          const a2 = new Jn(Zn, 1, t2, e2);
          a2.layers = this.layers, a2.up.set(0, 0, -1), a2.lookAt(new Rt(0, -1, 0)), this.add(a2);
          const o3 = new Jn(Zn, 1, t2, e2);
          o3.layers = this.layers, o3.up.set(0, -1, 0), o3.lookAt(new Rt(0, 0, 1)), this.add(o3);
          const l2 = new Jn(Zn, 1, t2, e2);
          l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new Rt(0, 0, -1)), this.add(l2);
        }
        update(t2, e2) {
          null === this.parent && this.updateMatrixWorld();
          const n2 = this.renderTarget, [i2, r2, s2, a2, o3, l2] = this.children, c2 = t2.xr.enabled, h2 = t2.getRenderTarget();
          t2.xr.enabled = false;
          const u2 = n2.texture.generateMipmaps;
          n2.texture.generateMipmaps = false, t2.setRenderTarget(n2, 0), t2.render(e2, i2), t2.setRenderTarget(n2, 1), t2.render(e2, r2), t2.setRenderTarget(n2, 2), t2.render(e2, s2), t2.setRenderTarget(n2, 3), t2.render(e2, a2), t2.setRenderTarget(n2, 4), t2.render(e2, o3), n2.texture.generateMipmaps = u2, t2.setRenderTarget(n2, 5), t2.render(e2, l2), t2.setRenderTarget(h2), t2.xr.enabled = c2;
        }
      }
      class Kn extends Mt {
        constructor(t2, e2, n2, i2, s2, a2, o3, l2, c2, h2) {
          super(t2 = void 0 !== t2 ? t2 : [], e2 = void 0 !== e2 ? e2 : r, n2, i2, s2, a2, o3 = void 0 !== o3 ? o3 : T, l2, c2, h2), this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(t2) {
          this.image = t2;
        }
      }
      Kn.prototype.isCubeTexture = true;
      class $n extends Tt {
        constructor(t2, e2, n2) {
          Number.isInteger(e2) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e2 = n2), super(t2, t2, e2), e2 = e2 || {}, this.texture = new Kn(void 0, e2.mapping, e2.wrapS, e2.wrapT, e2.magFilter, e2.minFilter, e2.format, e2.type, e2.anisotropy, e2.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== e2.generateMipmaps && e2.generateMipmaps, this.texture.minFilter = void 0 !== e2.minFilter ? e2.minFilter : g, this.texture._needsFlipEnvMap = false;
        }
        fromEquirectangularTexture(t2, e2) {
          this.texture.type = e2.type, this.texture.format = E, this.texture.encoding = e2.encoding, this.texture.generateMipmaps = e2.generateMipmaps, this.texture.minFilter = e2.minFilter, this.texture.magFilter = e2.magFilter;
          const n2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, i2 = new Vn(5, 5, 5), r2 = new Xn({ name: "CubemapFromEquirect", uniforms: Wn(n2.uniforms), vertexShader: n2.vertexShader, fragmentShader: n2.fragmentShader, side: 1, blending: 0 });
          r2.uniforms.tEquirect.value = e2;
          const s2 = new Gn(i2, r2), a2 = e2.minFilter;
          e2.minFilter === y && (e2.minFilter = g);
          return new Qn(1, 10, this).update(t2, s2), e2.minFilter = a2, s2.geometry.dispose(), s2.material.dispose(), this;
        }
        clear(t2, e2, n2, i2) {
          const r2 = t2.getRenderTarget();
          for (let r3 = 0; r3 < 6; r3++)
            t2.setRenderTarget(this, r3), t2.clear(e2, n2, i2);
          t2.setRenderTarget(r2);
        }
      }
      $n.prototype.isWebGLCubeRenderTarget = true;
      const ti = new Rt(), ei = new Rt(), ni = new yt();
      class ii {
        constructor(t2 = new Rt(1, 0, 0), e2 = 0) {
          this.normal = t2, this.constant = e2;
        }
        set(t2, e2) {
          return this.normal.copy(t2), this.constant = e2, this;
        }
        setComponents(t2, e2, n2, i2) {
          return this.normal.set(t2, e2, n2), this.constant = i2, this;
        }
        setFromNormalAndCoplanarPoint(t2, e2) {
          return this.normal.copy(t2), this.constant = -e2.dot(this.normal), this;
        }
        setFromCoplanarPoints(t2, e2, n2) {
          const i2 = ti.subVectors(n2, e2).cross(ei.subVectors(t2, e2)).normalize();
          return this.setFromNormalAndCoplanarPoint(i2, t2), this;
        }
        copy(t2) {
          return this.normal.copy(t2.normal), this.constant = t2.constant, this;
        }
        normalize() {
          const t2 = 1 / this.normal.length();
          return this.normal.multiplyScalar(t2), this.constant *= t2, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(t2) {
          return this.normal.dot(t2) + this.constant;
        }
        distanceToSphere(t2) {
          return this.distanceToPoint(t2.center) - t2.radius;
        }
        projectPoint(t2, e2) {
          return e2.copy(this.normal).multiplyScalar(-this.distanceToPoint(t2)).add(t2);
        }
        intersectLine(t2, e2) {
          const n2 = t2.delta(ti), i2 = this.normal.dot(n2);
          if (0 === i2)
            return 0 === this.distanceToPoint(t2.start) ? e2.copy(t2.start) : null;
          const r2 = -(t2.start.dot(this.normal) + this.constant) / i2;
          return r2 < 0 || r2 > 1 ? null : e2.copy(n2).multiplyScalar(r2).add(t2.start);
        }
        intersectsLine(t2) {
          const e2 = this.distanceToPoint(t2.start), n2 = this.distanceToPoint(t2.end);
          return e2 < 0 && n2 > 0 || n2 < 0 && e2 > 0;
        }
        intersectsBox(t2) {
          return t2.intersectsPlane(this);
        }
        intersectsSphere(t2) {
          return t2.intersectsPlane(this);
        }
        coplanarPoint(t2) {
          return t2.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t2, e2) {
          const n2 = e2 || ni.getNormalMatrix(t2), i2 = this.coplanarPoint(ti).applyMatrix4(t2), r2 = this.normal.applyMatrix3(n2).normalize();
          return this.constant = -i2.dot(r2), this;
        }
        translate(t2) {
          return this.constant -= t2.dot(this.normal), this;
        }
        equals(t2) {
          return t2.normal.equals(this.normal) && t2.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      ii.prototype.isPlane = true;
      const ri = new Qt(), si = new Rt();
      class ai {
        constructor(t2 = new ii(), e2 = new ii(), n2 = new ii(), i2 = new ii(), r2 = new ii(), s2 = new ii()) {
          this.planes = [t2, e2, n2, i2, r2, s2];
        }
        set(t2, e2, n2, i2, r2, s2) {
          const a2 = this.planes;
          return a2[0].copy(t2), a2[1].copy(e2), a2[2].copy(n2), a2[3].copy(i2), a2[4].copy(r2), a2[5].copy(s2), this;
        }
        copy(t2) {
          const e2 = this.planes;
          for (let n2 = 0; n2 < 6; n2++)
            e2[n2].copy(t2.planes[n2]);
          return this;
        }
        setFromProjectionMatrix(t2) {
          const e2 = this.planes, n2 = t2.elements, i2 = n2[0], r2 = n2[1], s2 = n2[2], a2 = n2[3], o3 = n2[4], l2 = n2[5], c2 = n2[6], h2 = n2[7], u2 = n2[8], d2 = n2[9], p2 = n2[10], m2 = n2[11], f2 = n2[12], g2 = n2[13], v2 = n2[14], y2 = n2[15];
          return e2[0].setComponents(a2 - i2, h2 - o3, m2 - u2, y2 - f2).normalize(), e2[1].setComponents(a2 + i2, h2 + o3, m2 + u2, y2 + f2).normalize(), e2[2].setComponents(a2 + r2, h2 + l2, m2 + d2, y2 + g2).normalize(), e2[3].setComponents(a2 - r2, h2 - l2, m2 - d2, y2 - g2).normalize(), e2[4].setComponents(a2 - s2, h2 - c2, m2 - p2, y2 - v2).normalize(), e2[5].setComponents(a2 + s2, h2 + c2, m2 + p2, y2 + v2).normalize(), this;
        }
        intersectsObject(t2) {
          const e2 = t2.geometry;
          return null === e2.boundingSphere && e2.computeBoundingSphere(), ri.copy(e2.boundingSphere).applyMatrix4(t2.matrixWorld), this.intersectsSphere(ri);
        }
        intersectsSprite(t2) {
          return ri.center.set(0, 0, 0), ri.radius = 0.7071067811865476, ri.applyMatrix4(t2.matrixWorld), this.intersectsSphere(ri);
        }
        intersectsSphere(t2) {
          const e2 = this.planes, n2 = t2.center, i2 = -t2.radius;
          for (let t3 = 0; t3 < 6; t3++) {
            if (e2[t3].distanceToPoint(n2) < i2)
              return false;
          }
          return true;
        }
        intersectsBox(t2) {
          const e2 = this.planes;
          for (let n2 = 0; n2 < 6; n2++) {
            const i2 = e2[n2];
            if (si.x = i2.normal.x > 0 ? t2.max.x : t2.min.x, si.y = i2.normal.y > 0 ? t2.max.y : t2.min.y, si.z = i2.normal.z > 0 ? t2.max.z : t2.min.z, i2.distanceToPoint(si) < 0)
              return false;
          }
          return true;
        }
        containsPoint(t2) {
          const e2 = this.planes;
          for (let n2 = 0; n2 < 6; n2++)
            if (e2[n2].distanceToPoint(t2) < 0)
              return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function oi() {
        let t2 = null, e2 = false, n2 = null, i2 = null;
        function r2(e3, s2) {
          n2(e3, s2), i2 = t2.requestAnimationFrame(r2);
        }
        return { start: function() {
          true !== e2 && null !== n2 && (i2 = t2.requestAnimationFrame(r2), e2 = true);
        }, stop: function() {
          t2.cancelAnimationFrame(i2), e2 = false;
        }, setAnimationLoop: function(t3) {
          n2 = t3;
        }, setContext: function(e3) {
          t2 = e3;
        } };
      }
      function li(t2, e2) {
        const n2 = e2.isWebGL2, i2 = /* @__PURE__ */ new WeakMap();
        return { get: function(t3) {
          return t3.isInterleavedBufferAttribute && (t3 = t3.data), i2.get(t3);
        }, remove: function(e3) {
          e3.isInterleavedBufferAttribute && (e3 = e3.data);
          const n3 = i2.get(e3);
          n3 && (t2.deleteBuffer(n3.buffer), i2.delete(e3));
        }, update: function(e3, r2) {
          if (e3.isGLBufferAttribute) {
            const t3 = i2.get(e3);
            return void ((!t3 || t3.version < e3.version) && i2.set(e3, { buffer: e3.buffer, type: e3.type, bytesPerElement: e3.elementSize, version: e3.version }));
          }
          e3.isInterleavedBufferAttribute && (e3 = e3.data);
          const s2 = i2.get(e3);
          void 0 === s2 ? i2.set(e3, function(e4, i3) {
            const r3 = e4.array, s3 = e4.usage, a2 = t2.createBuffer();
            t2.bindBuffer(i3, a2), t2.bufferData(i3, r3, s3), e4.onUploadCallback();
            let o3 = 5126;
            return r3 instanceof Float32Array ? o3 = 5126 : r3 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r3 instanceof Uint16Array ? e4.isFloat16BufferAttribute ? n2 ? o3 = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o3 = 5123 : r3 instanceof Int16Array ? o3 = 5122 : r3 instanceof Uint32Array ? o3 = 5125 : r3 instanceof Int32Array ? o3 = 5124 : r3 instanceof Int8Array ? o3 = 5120 : (r3 instanceof Uint8Array || r3 instanceof Uint8ClampedArray) && (o3 = 5121), { buffer: a2, type: o3, bytesPerElement: r3.BYTES_PER_ELEMENT, version: e4.version };
          }(e3, r2)) : s2.version < e3.version && (!function(e4, i3, r3) {
            const s3 = i3.array, a2 = i3.updateRange;
            t2.bindBuffer(r3, e4), -1 === a2.count ? t2.bufferSubData(r3, 0, s3) : (n2 ? t2.bufferSubData(r3, a2.offset * s3.BYTES_PER_ELEMENT, s3, a2.offset, a2.count) : t2.bufferSubData(r3, a2.offset * s3.BYTES_PER_ELEMENT, s3.subarray(a2.offset, a2.offset + a2.count)), a2.count = -1);
          }(s2.buffer, e3, r2), s2.version = e3.version);
        } };
      }
      class ci extends wn {
        constructor(t2 = 1, e2 = 1, n2 = 1, i2 = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = { width: t2, height: e2, widthSegments: n2, heightSegments: i2 };
          const r2 = t2 / 2, s2 = e2 / 2, a2 = Math.floor(n2), o3 = Math.floor(i2), l2 = a2 + 1, c2 = o3 + 1, h2 = t2 / a2, u2 = e2 / o3, d2 = [], p2 = [], m2 = [], f2 = [];
          for (let t3 = 0; t3 < c2; t3++) {
            const e3 = t3 * u2 - s2;
            for (let n3 = 0; n3 < l2; n3++) {
              const i3 = n3 * h2 - r2;
              p2.push(i3, -e3, 0), m2.push(0, 0, 1), f2.push(n3 / a2), f2.push(1 - t3 / o3);
            }
          }
          for (let t3 = 0; t3 < o3; t3++)
            for (let e3 = 0; e3 < a2; e3++) {
              const n3 = e3 + l2 * t3, i3 = e3 + l2 * (t3 + 1), r3 = e3 + 1 + l2 * (t3 + 1), s3 = e3 + 1 + l2 * t3;
              d2.push(n3, i3, s3), d2.push(i3, r3, s3);
            }
          this.setIndex(d2), this.setAttribute("position", new un(p2, 3)), this.setAttribute("normal", new un(m2, 3)), this.setAttribute("uv", new un(f2, 2));
        }
        static fromJSON(t2) {
          return new ci(t2.width, t2.height, t2.widthSegments, t2.heightSegments);
        }
      }
      const hi = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotVH = saturate( dot( geometry.viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float NoH ) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float NoV, float NoL ) {\n	return saturate( 1.0 / ( 4.0 * ( NoL + NoV - NoL * NoV ) ) );\n}\nvec3 BRDF_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in GeometricContext geometry ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularTintFactor = specularTint;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARTINTMAP\n			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularTintFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenTint = sheenTint;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenTint;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(		0, 1,		0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( material.roughness, directLight.direction, geometry, material.sheenTint );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n							f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n							texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n							f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(	1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,	1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,	1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationTint, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = transmission.a;\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationTint;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularTint;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARTINTMAP\n		uniform sampler2D specularTintMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenTint;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}" }, ui = { common: { diffuse: { value: new Qe(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new yt() }, uv2Transform: { value: new yt() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new vt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Qe(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Qe(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new yt() } }, sprite: { diffuse: { value: new Qe(16777215) }, opacity: { value: 1 }, center: { value: new vt(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new yt() } } }, di = { basic: { uniforms: jn([ui.common, ui.specularmap, ui.envmap, ui.aomap, ui.lightmap, ui.fog]), vertexShader: hi.meshbasic_vert, fragmentShader: hi.meshbasic_frag }, lambert: { uniforms: jn([ui.common, ui.specularmap, ui.envmap, ui.aomap, ui.lightmap, ui.emissivemap, ui.fog, ui.lights, { emissive: { value: new Qe(0) } }]), vertexShader: hi.meshlambert_vert, fragmentShader: hi.meshlambert_frag }, phong: { uniforms: jn([ui.common, ui.specularmap, ui.envmap, ui.aomap, ui.lightmap, ui.emissivemap, ui.bumpmap, ui.normalmap, ui.displacementmap, ui.fog, ui.lights, { emissive: { value: new Qe(0) }, specular: { value: new Qe(1118481) }, shininess: { value: 30 } }]), vertexShader: hi.meshphong_vert, fragmentShader: hi.meshphong_frag }, standard: { uniforms: jn([ui.common, ui.envmap, ui.aomap, ui.lightmap, ui.emissivemap, ui.bumpmap, ui.normalmap, ui.displacementmap, ui.roughnessmap, ui.metalnessmap, ui.fog, ui.lights, { emissive: { value: new Qe(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: hi.meshphysical_vert, fragmentShader: hi.meshphysical_frag }, toon: { uniforms: jn([ui.common, ui.aomap, ui.lightmap, ui.emissivemap, ui.bumpmap, ui.normalmap, ui.displacementmap, ui.gradientmap, ui.fog, ui.lights, { emissive: { value: new Qe(0) } }]), vertexShader: hi.meshtoon_vert, fragmentShader: hi.meshtoon_frag }, matcap: { uniforms: jn([ui.common, ui.bumpmap, ui.normalmap, ui.displacementmap, ui.fog, { matcap: { value: null } }]), vertexShader: hi.meshmatcap_vert, fragmentShader: hi.meshmatcap_frag }, points: { uniforms: jn([ui.points, ui.fog]), vertexShader: hi.points_vert, fragmentShader: hi.points_frag }, dashed: { uniforms: jn([ui.common, ui.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: hi.linedashed_vert, fragmentShader: hi.linedashed_frag }, depth: { uniforms: jn([ui.common, ui.displacementmap]), vertexShader: hi.depth_vert, fragmentShader: hi.depth_frag }, normal: { uniforms: jn([ui.common, ui.bumpmap, ui.normalmap, ui.displacementmap, { opacity: { value: 1 } }]), vertexShader: hi.meshnormal_vert, fragmentShader: hi.meshnormal_frag }, sprite: { uniforms: jn([ui.sprite, ui.fog]), vertexShader: hi.sprite_vert, fragmentShader: hi.sprite_frag }, background: { uniforms: { uvTransform: { value: new yt() }, t2D: { value: null } }, vertexShader: hi.background_vert, fragmentShader: hi.background_frag }, cube: { uniforms: jn([ui.envmap, { opacity: { value: 1 } }]), vertexShader: hi.cube_vert, fragmentShader: hi.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: hi.equirect_vert, fragmentShader: hi.equirect_frag }, distanceRGBA: { uniforms: jn([ui.common, ui.displacementmap, { referencePosition: { value: new Rt() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: hi.distanceRGBA_vert, fragmentShader: hi.distanceRGBA_frag }, shadow: { uniforms: jn([ui.lights, ui.fog, { color: { value: new Qe(0) }, opacity: { value: 1 } }]), vertexShader: hi.shadow_vert, fragmentShader: hi.shadow_frag } };
      function pi(t2, e2, n2, i2, r2) {
        const s2 = new Qe(0);
        let a2, o3, c2 = 0, h2 = null, u2 = 0, d2 = null;
        function p2(t3, e3) {
          n2.buffers.color.setClear(t3.r, t3.g, t3.b, e3, r2);
        }
        return { getClearColor: function() {
          return s2;
        }, setClearColor: function(t3, e3 = 1) {
          s2.set(t3), c2 = e3, p2(s2, c2);
        }, getClearAlpha: function() {
          return c2;
        }, setClearAlpha: function(t3) {
          c2 = t3, p2(s2, c2);
        }, render: function(n3, r3) {
          let m2 = false, f2 = true === r3.isScene ? r3.background : null;
          f2 && f2.isTexture && (f2 = e2.get(f2));
          const g2 = t2.xr, v2 = g2.getSession && g2.getSession();
          v2 && "additive" === v2.environmentBlendMode && (f2 = null), null === f2 ? p2(s2, c2) : f2 && f2.isColor && (p2(f2, 1), m2 = true), (t2.autoClear || m2) && t2.clear(t2.autoClearColor, t2.autoClearDepth, t2.autoClearStencil), f2 && (f2.isCubeTexture || f2.mapping === l) ? (void 0 === o3 && (o3 = new Gn(new Vn(1, 1, 1), new Xn({ name: "BackgroundCubeMaterial", uniforms: Wn(di.cube.uniforms), vertexShader: di.cube.vertexShader, fragmentShader: di.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), o3.geometry.deleteAttribute("normal"), o3.geometry.deleteAttribute("uv"), o3.onBeforeRender = function(t3, e3, n4) {
            this.matrixWorld.copyPosition(n4.matrixWorld);
          }, Object.defineProperty(o3.material, "envMap", { get: function() {
            return this.uniforms.envMap.value;
          } }), i2.update(o3)), o3.material.uniforms.envMap.value = f2, o3.material.uniforms.flipEnvMap.value = f2.isCubeTexture && false === f2.isRenderTargetTexture ? -1 : 1, h2 === f2 && u2 === f2.version && d2 === t2.toneMapping || (o3.material.needsUpdate = true, h2 = f2, u2 = f2.version, d2 = t2.toneMapping), n3.unshift(o3, o3.geometry, o3.material, 0, 0, null)) : f2 && f2.isTexture && (void 0 === a2 && (a2 = new Gn(new ci(2, 2), new Xn({ name: "BackgroundMaterial", uniforms: Wn(di.background.uniforms), vertexShader: di.background.vertexShader, fragmentShader: di.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), a2.geometry.deleteAttribute("normal"), Object.defineProperty(a2.material, "map", { get: function() {
            return this.uniforms.t2D.value;
          } }), i2.update(a2)), a2.material.uniforms.t2D.value = f2, true === f2.matrixAutoUpdate && f2.updateMatrix(), a2.material.uniforms.uvTransform.value.copy(f2.matrix), h2 === f2 && u2 === f2.version && d2 === t2.toneMapping || (a2.material.needsUpdate = true, h2 = f2, u2 = f2.version, d2 = t2.toneMapping), n3.unshift(a2, a2.geometry, a2.material, 0, 0, null));
        } };
      }
      function mi(t2, e2, n2, i2) {
        const r2 = t2.getParameter(34921), s2 = i2.isWebGL2 ? null : e2.get("OES_vertex_array_object"), a2 = i2.isWebGL2 || null !== s2, o3 = {}, l2 = d2(null);
        let c2 = l2;
        function h2(e3) {
          return i2.isWebGL2 ? t2.bindVertexArray(e3) : s2.bindVertexArrayOES(e3);
        }
        function u2(e3) {
          return i2.isWebGL2 ? t2.deleteVertexArray(e3) : s2.deleteVertexArrayOES(e3);
        }
        function d2(t3) {
          const e3 = [], n3 = [], i3 = [];
          for (let t4 = 0; t4 < r2; t4++)
            e3[t4] = 0, n3[t4] = 0, i3[t4] = 0;
          return { geometry: null, program: null, wireframe: false, newAttributes: e3, enabledAttributes: n3, attributeDivisors: i3, object: t3, attributes: {}, index: null };
        }
        function p2() {
          const t3 = c2.newAttributes;
          for (let e3 = 0, n3 = t3.length; e3 < n3; e3++)
            t3[e3] = 0;
        }
        function m2(t3) {
          f2(t3, 0);
        }
        function f2(n3, r3) {
          const s3 = c2.newAttributes, a3 = c2.enabledAttributes, o4 = c2.attributeDivisors;
          if (s3[n3] = 1, 0 === a3[n3] && (t2.enableVertexAttribArray(n3), a3[n3] = 1), o4[n3] !== r3) {
            (i2.isWebGL2 ? t2 : e2.get("ANGLE_instanced_arrays"))[i2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n3, r3), o4[n3] = r3;
          }
        }
        function g2() {
          const e3 = c2.newAttributes, n3 = c2.enabledAttributes;
          for (let i3 = 0, r3 = n3.length; i3 < r3; i3++)
            n3[i3] !== e3[i3] && (t2.disableVertexAttribArray(i3), n3[i3] = 0);
        }
        function v2(e3, n3, r3, s3, a3, o4) {
          true !== i2.isWebGL2 || 5124 !== r3 && 5125 !== r3 ? t2.vertexAttribPointer(e3, n3, r3, s3, a3, o4) : t2.vertexAttribIPointer(e3, n3, r3, a3, o4);
        }
        function y2() {
          x2(), c2 !== l2 && (c2 = l2, h2(c2.object));
        }
        function x2() {
          l2.geometry = null, l2.program = null, l2.wireframe = false;
        }
        return { setup: function(r3, l3, u3, y3, x3) {
          let _2 = false;
          if (a2) {
            const e3 = function(e4, n3, r4) {
              const a3 = true === r4.wireframe;
              let l4 = o3[e4.id];
              void 0 === l4 && (l4 = {}, o3[e4.id] = l4);
              let c3 = l4[n3.id];
              void 0 === c3 && (c3 = {}, l4[n3.id] = c3);
              let h3 = c3[a3];
              void 0 === h3 && (h3 = d2(i2.isWebGL2 ? t2.createVertexArray() : s2.createVertexArrayOES()), c3[a3] = h3);
              return h3;
            }(y3, u3, l3);
            c2 !== e3 && (c2 = e3, h2(c2.object)), _2 = function(t3, e4) {
              const n3 = c2.attributes, i3 = t3.attributes;
              let r4 = 0;
              for (const t4 in i3) {
                const e5 = n3[t4], s3 = i3[t4];
                if (void 0 === e5)
                  return true;
                if (e5.attribute !== s3)
                  return true;
                if (e5.data !== s3.data)
                  return true;
                r4++;
              }
              return c2.attributesNum !== r4 || c2.index !== e4;
            }(y3, x3), _2 && function(t3, e4) {
              const n3 = {}, i3 = t3.attributes;
              let r4 = 0;
              for (const t4 in i3) {
                const e5 = i3[t4], s3 = {};
                s3.attribute = e5, e5.data && (s3.data = e5.data), n3[t4] = s3, r4++;
              }
              c2.attributes = n3, c2.attributesNum = r4, c2.index = e4;
            }(y3, x3);
          } else {
            const t3 = true === l3.wireframe;
            c2.geometry === y3.id && c2.program === u3.id && c2.wireframe === t3 || (c2.geometry = y3.id, c2.program = u3.id, c2.wireframe = t3, _2 = true);
          }
          true === r3.isInstancedMesh && (_2 = true), null !== x3 && n2.update(x3, 34963), _2 && (!function(r4, s3, a3, o4) {
            if (false === i2.isWebGL2 && (r4.isInstancedMesh || o4.isInstancedBufferGeometry) && null === e2.get("ANGLE_instanced_arrays"))
              return;
            p2();
            const l4 = o4.attributes, c3 = a3.getAttributes(), h3 = s3.defaultAttributeValues;
            for (const e3 in c3) {
              const i3 = c3[e3];
              if (i3.location >= 0) {
                let s4 = l4[e3];
                if (void 0 === s4 && ("instanceMatrix" === e3 && r4.instanceMatrix && (s4 = r4.instanceMatrix), "instanceColor" === e3 && r4.instanceColor && (s4 = r4.instanceColor)), void 0 !== s4) {
                  const e4 = s4.normalized, a4 = s4.itemSize, l5 = n2.get(s4);
                  if (void 0 === l5)
                    continue;
                  const c4 = l5.buffer, h4 = l5.type, u4 = l5.bytesPerElement;
                  if (s4.isInterleavedBufferAttribute) {
                    const n3 = s4.data, l6 = n3.stride, d3 = s4.offset;
                    if (n3 && n3.isInstancedInterleavedBuffer) {
                      for (let t3 = 0; t3 < i3.locationSize; t3++)
                        f2(i3.location + t3, n3.meshPerAttribute);
                      true !== r4.isInstancedMesh && void 0 === o4._maxInstanceCount && (o4._maxInstanceCount = n3.meshPerAttribute * n3.count);
                    } else
                      for (let t3 = 0; t3 < i3.locationSize; t3++)
                        m2(i3.location + t3);
                    t2.bindBuffer(34962, c4);
                    for (let t3 = 0; t3 < i3.locationSize; t3++)
                      v2(i3.location + t3, a4 / i3.locationSize, h4, e4, l6 * u4, (d3 + a4 / i3.locationSize * t3) * u4);
                  } else {
                    if (s4.isInstancedBufferAttribute) {
                      for (let t3 = 0; t3 < i3.locationSize; t3++)
                        f2(i3.location + t3, s4.meshPerAttribute);
                      true !== r4.isInstancedMesh && void 0 === o4._maxInstanceCount && (o4._maxInstanceCount = s4.meshPerAttribute * s4.count);
                    } else
                      for (let t3 = 0; t3 < i3.locationSize; t3++)
                        m2(i3.location + t3);
                    t2.bindBuffer(34962, c4);
                    for (let t3 = 0; t3 < i3.locationSize; t3++)
                      v2(i3.location + t3, a4 / i3.locationSize, h4, e4, a4 * u4, a4 / i3.locationSize * t3 * u4);
                  }
                } else if (void 0 !== h3) {
                  const n3 = h3[e3];
                  if (void 0 !== n3)
                    switch (n3.length) {
                      case 2:
                        t2.vertexAttrib2fv(i3.location, n3);
                        break;
                      case 3:
                        t2.vertexAttrib3fv(i3.location, n3);
                        break;
                      case 4:
                        t2.vertexAttrib4fv(i3.location, n3);
                        break;
                      default:
                        t2.vertexAttrib1fv(i3.location, n3);
                    }
                }
              }
            }
            g2();
          }(r3, l3, u3, y3), null !== x3 && t2.bindBuffer(34963, n2.get(x3).buffer));
        }, reset: y2, resetDefaultState: x2, dispose: function() {
          y2();
          for (const t3 in o3) {
            const e3 = o3[t3];
            for (const t4 in e3) {
              const n3 = e3[t4];
              for (const t5 in n3)
                u2(n3[t5].object), delete n3[t5];
              delete e3[t4];
            }
            delete o3[t3];
          }
        }, releaseStatesOfGeometry: function(t3) {
          if (void 0 === o3[t3.id])
            return;
          const e3 = o3[t3.id];
          for (const t4 in e3) {
            const n3 = e3[t4];
            for (const t5 in n3)
              u2(n3[t5].object), delete n3[t5];
            delete e3[t4];
          }
          delete o3[t3.id];
        }, releaseStatesOfProgram: function(t3) {
          for (const e3 in o3) {
            const n3 = o3[e3];
            if (void 0 === n3[t3.id])
              continue;
            const i3 = n3[t3.id];
            for (const t4 in i3)
              u2(i3[t4].object), delete i3[t4];
            delete n3[t3.id];
          }
        }, initAttributes: p2, enableAttribute: m2, disableUnusedAttributes: g2 };
      }
      function fi(t2, e2, n2, i2) {
        const r2 = i2.isWebGL2;
        let s2;
        this.setMode = function(t3) {
          s2 = t3;
        }, this.render = function(e3, i3) {
          t2.drawArrays(s2, e3, i3), n2.update(i3, s2, 1);
        }, this.renderInstances = function(i3, a2, o3) {
          if (0 === o3)
            return;
          let l2, c2;
          if (r2)
            l2 = t2, c2 = "drawArraysInstanced";
          else if (l2 = e2.get("ANGLE_instanced_arrays"), c2 = "drawArraysInstancedANGLE", null === l2)
            return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          l2[c2](s2, i3, a2, o3), n2.update(a2, s2, o3);
        };
      }
      function gi(t2, e2, n2) {
        let i2;
        function r2(e3) {
          if ("highp" === e3) {
            if (t2.getShaderPrecisionFormat(35633, 36338).precision > 0 && t2.getShaderPrecisionFormat(35632, 36338).precision > 0)
              return "highp";
            e3 = "mediump";
          }
          return "mediump" === e3 && t2.getShaderPrecisionFormat(35633, 36337).precision > 0 && t2.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
        }
        const s2 = "undefined" != typeof WebGL2RenderingContext && t2 instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t2 instanceof WebGL2ComputeRenderingContext;
        let a2 = void 0 !== n2.precision ? n2.precision : "highp";
        const o3 = r2(a2);
        o3 !== a2 && (console.warn("THREE.WebGLRenderer:", a2, "not supported, using", o3, "instead."), a2 = o3);
        const l2 = s2 || e2.has("WEBGL_draw_buffers"), c2 = true === n2.logarithmicDepthBuffer, h2 = t2.getParameter(34930), u2 = t2.getParameter(35660), d2 = t2.getParameter(3379), p2 = t2.getParameter(34076), m2 = t2.getParameter(34921), f2 = t2.getParameter(36347), g2 = t2.getParameter(36348), v2 = t2.getParameter(36349), y2 = u2 > 0, x2 = s2 || e2.has("OES_texture_float");
        return { isWebGL2: s2, drawBuffers: l2, getMaxAnisotropy: function() {
          if (void 0 !== i2)
            return i2;
          if (true === e2.has("EXT_texture_filter_anisotropic")) {
            const n3 = e2.get("EXT_texture_filter_anisotropic");
            i2 = t2.getParameter(n3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else
            i2 = 0;
          return i2;
        }, getMaxPrecision: r2, precision: a2, logarithmicDepthBuffer: c2, maxTextures: h2, maxVertexTextures: u2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: m2, maxVertexUniforms: f2, maxVaryings: g2, maxFragmentUniforms: v2, vertexTextures: y2, floatFragmentTextures: x2, floatVertexTextures: y2 && x2, maxSamples: s2 ? t2.getParameter(36183) : 0 };
      }
      function vi(t2) {
        const e2 = this;
        let n2 = null, i2 = 0, r2 = false, s2 = false;
        const a2 = new ii(), o3 = new yt(), l2 = { value: null, needsUpdate: false };
        function c2() {
          l2.value !== n2 && (l2.value = n2, l2.needsUpdate = i2 > 0), e2.numPlanes = i2, e2.numIntersection = 0;
        }
        function h2(t3, n3, i3, r3) {
          const s3 = null !== t3 ? t3.length : 0;
          let c3 = null;
          if (0 !== s3) {
            if (c3 = l2.value, true !== r3 || null === c3) {
              const e3 = i3 + 4 * s3, r4 = n3.matrixWorldInverse;
              o3.getNormalMatrix(r4), (null === c3 || c3.length < e3) && (c3 = new Float32Array(e3));
              for (let e4 = 0, n4 = i3; e4 !== s3; ++e4, n4 += 4)
                a2.copy(t3[e4]).applyMatrix4(r4, o3), a2.normal.toArray(c3, n4), c3[n4 + 3] = a2.constant;
            }
            l2.value = c3, l2.needsUpdate = true;
          }
          return e2.numPlanes = s3, e2.numIntersection = 0, c3;
        }
        this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t3, e3, s3) {
          const a3 = 0 !== t3.length || e3 || 0 !== i2 || r2;
          return r2 = e3, n2 = h2(t3, s3, 0), i2 = t3.length, a3;
        }, this.beginShadows = function() {
          s2 = true, h2(null);
        }, this.endShadows = function() {
          s2 = false, c2();
        }, this.setState = function(e3, a3, o4) {
          const u2 = e3.clippingPlanes, d2 = e3.clipIntersection, p2 = e3.clipShadows, m2 = t2.get(e3);
          if (!r2 || null === u2 || 0 === u2.length || s2 && !p2)
            s2 ? h2(null) : c2();
          else {
            const t3 = s2 ? 0 : i2, e4 = 4 * t3;
            let r3 = m2.clippingState || null;
            l2.value = r3, r3 = h2(u2, a3, e4, o4);
            for (let t4 = 0; t4 !== e4; ++t4)
              r3[t4] = n2[t4];
            m2.clippingState = r3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += t3;
          }
        };
      }
      function yi(t2) {
        let e2 = /* @__PURE__ */ new WeakMap();
        function n2(t3, e3) {
          return e3 === a ? t3.mapping = r : e3 === o2 && (t3.mapping = s), t3;
        }
        function i2(t3) {
          const n3 = t3.target;
          n3.removeEventListener("dispose", i2);
          const r2 = e2.get(n3);
          void 0 !== r2 && (e2.delete(n3), r2.dispose());
        }
        return { get: function(r2) {
          if (r2 && r2.isTexture && false === r2.isRenderTargetTexture) {
            const s2 = r2.mapping;
            if (s2 === a || s2 === o2) {
              if (e2.has(r2)) {
                return n2(e2.get(r2).texture, r2.mapping);
              }
              {
                const s3 = r2.image;
                if (s3 && s3.height > 0) {
                  const a2 = t2.getRenderTarget(), o3 = new $n(s3.height / 2);
                  return o3.fromEquirectangularTexture(t2, r2), e2.set(r2, o3), t2.setRenderTarget(a2), r2.addEventListener("dispose", i2), n2(o3.texture, r2.mapping);
                }
                return null;
              }
            }
          }
          return r2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      di.physical = { uniforms: jn([di.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new vt(1, 1) }, clearcoatNormalMap: { value: null }, sheenTint: { value: new Qe(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new vt() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationTint: { value: new Qe(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularTint: { value: new Qe(1, 1, 1) }, specularTintMap: { value: null } }]), vertexShader: hi.meshphysical_vert, fragmentShader: hi.meshphysical_frag };
      class xi extends Yn {
        constructor(t2 = -1, e2 = 1, n2 = 1, i2 = -1, r2 = 0.1, s2 = 2e3) {
          super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t2, this.right = e2, this.top = n2, this.bottom = i2, this.near = r2, this.far = s2, this.updateProjectionMatrix();
        }
        copy(t2, e2) {
          return super.copy(t2, e2), this.left = t2.left, this.right = t2.right, this.top = t2.top, this.bottom = t2.bottom, this.near = t2.near, this.far = t2.far, this.zoom = t2.zoom, this.view = null === t2.view ? null : Object.assign({}, t2.view), this;
        }
        setViewOffset(t2, e2, n2, i2, r2, s2) {
          null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = n2, this.view.offsetY = i2, this.view.width = r2, this.view.height = s2, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t2 = (this.right - this.left) / (2 * this.zoom), e2 = (this.top - this.bottom) / (2 * this.zoom), n2 = (this.right + this.left) / 2, i2 = (this.top + this.bottom) / 2;
          let r2 = n2 - t2, s2 = n2 + t2, a2 = i2 + e2, o3 = i2 - e2;
          if (null !== this.view && this.view.enabled) {
            const t3 = (this.right - this.left) / this.view.fullWidth / this.zoom, e3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r2 += t3 * this.view.offsetX, s2 = r2 + t3 * this.view.width, a2 -= e3 * this.view.offsetY, o3 = a2 - e3 * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(r2, s2, a2, o3, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.zoom = this.zoom, e2.object.left = this.left, e2.object.right = this.right, e2.object.top = this.top, e2.object.bottom = this.bottom, e2.object.near = this.near, e2.object.far = this.far, null !== this.view && (e2.object.view = Object.assign({}, this.view)), e2;
        }
      }
      xi.prototype.isOrthographicCamera = true;
      class _i extends Xn {
        constructor(t2) {
          super(t2), this.type = "RawShaderMaterial";
        }
      }
      _i.prototype.isRawShaderMaterial = true;
      const bi = Math.pow(2, 8), Mi = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], wi = 5 + Mi.length, Si = 20, Ti = { [X]: 0, [Y]: 1, [Z]: 2, [Q]: 3, [K]: 4, [$]: 5, [J]: 6 }, Ei = new xi(), { _lodPlanes: Ai, _sizeLods: Li, _sigmas: Ri } = Fi(), Ci = new Qe();
      let Pi = null;
      const Ii = (1 + Math.sqrt(5)) / 2, Di = 1 / Ii, Ni = [new Rt(1, 1, 1), new Rt(-1, 1, 1), new Rt(1, 1, -1), new Rt(-1, 1, -1), new Rt(0, Ii, Di), new Rt(0, Ii, -Di), new Rt(Di, 0, Ii), new Rt(-Di, 0, Ii), new Rt(Ii, Di, 0), new Rt(-Ii, Di, 0)];
      class zi {
        constructor(t2) {
          this._renderer = t2, this._pingPongRenderTarget = null, this._blurMaterial = function(t3) {
            const e2 = new Float32Array(t3), n2 = new Rt(0, 1, 0);
            return new _i({ name: "SphericalGaussianBlur", defines: { n: t3 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e2 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: n2 }, inputEncoding: { value: Ti[3e3] }, outputEncoding: { value: Ti[3e3] } }, vertexShader: ki(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Vi()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: false, depthWrite: false });
          }(Si), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(t2, e2 = 0, n2 = 0.1, i2 = 100) {
          Pi = this._renderer.getRenderTarget();
          const r2 = this._allocateTargets();
          return this._sceneToCubeUV(t2, n2, i2, r2), e2 > 0 && this._blur(r2, 0, 0, e2), this._applyPMREM(r2), this._cleanup(r2), r2;
        }
        fromEquirectangular(t2) {
          return this._fromTexture(t2);
        }
        fromCubemap(t2) {
          return this._fromTexture(t2);
        }
        compileCubemapShader() {
          null === this._cubemapShader && (this._cubemapShader = Gi(), this._compileMaterial(this._cubemapShader));
        }
        compileEquirectangularShader() {
          null === this._equirectShader && (this._equirectShader = Hi(), this._compileMaterial(this._equirectShader));
        }
        dispose() {
          this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
          for (let t2 = 0; t2 < Ai.length; t2++)
            Ai[t2].dispose();
        }
        _cleanup(t2) {
          this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Pi), t2.scissorTest = false, Ui(t2, 0, 0, t2.width, t2.height);
        }
        _fromTexture(t2) {
          Pi = this._renderer.getRenderTarget();
          const e2 = this._allocateTargets(t2);
          return this._textureToCubeUV(t2, e2), this._applyPMREM(e2), this._cleanup(e2), e2;
        }
        _allocateTargets(t2) {
          const e2 = { magFilter: p, minFilter: p, generateMipmaps: false, type: x, format: 1023, encoding: Bi(t2) ? t2.encoding : Z, depthBuffer: false }, n2 = Oi(e2);
          return n2.depthBuffer = !t2, this._pingPongRenderTarget = Oi(e2), n2;
        }
        _compileMaterial(t2) {
          const e2 = new Gn(Ai[0], t2);
          this._renderer.compile(e2, Ei);
        }
        _sceneToCubeUV(t2, e2, n2, i2) {
          const r2 = new Jn(90, 1, e2, n2), s2 = [1, -1, 1, 1, 1, 1], a2 = [1, 1, 1, -1, -1, -1], o3 = this._renderer, l2 = o3.autoClear, c2 = o3.outputEncoding, h2 = o3.toneMapping;
          o3.getClearColor(Ci), o3.toneMapping = 0, o3.outputEncoding = X, o3.autoClear = false;
          const u2 = new Ke({ name: "PMREM.Background", side: 1, depthWrite: false, depthTest: false }), d2 = new Gn(new Vn(), u2);
          let p2 = false;
          const m2 = t2.background;
          m2 ? m2.isColor && (u2.color.copy(m2), t2.background = null, p2 = true) : (u2.color.copy(Ci), p2 = true);
          for (let e3 = 0; e3 < 6; e3++) {
            const n3 = e3 % 3;
            0 == n3 ? (r2.up.set(0, s2[e3], 0), r2.lookAt(a2[e3], 0, 0)) : 1 == n3 ? (r2.up.set(0, 0, s2[e3]), r2.lookAt(0, a2[e3], 0)) : (r2.up.set(0, s2[e3], 0), r2.lookAt(0, 0, a2[e3])), Ui(i2, n3 * bi, e3 > 2 ? bi : 0, bi, bi), o3.setRenderTarget(i2), p2 && o3.render(d2, r2), o3.render(t2, r2);
          }
          d2.geometry.dispose(), d2.material.dispose(), o3.toneMapping = h2, o3.outputEncoding = c2, o3.autoClear = l2, t2.background = m2;
        }
        _textureToCubeUV(t2, e2) {
          const n2 = this._renderer;
          t2.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Gi()) : null == this._equirectShader && (this._equirectShader = Hi());
          const i2 = t2.isCubeTexture ? this._cubemapShader : this._equirectShader, r2 = new Gn(Ai[0], i2), s2 = i2.uniforms;
          s2.envMap.value = t2, t2.isCubeTexture || s2.texelSize.value.set(1 / t2.image.width, 1 / t2.image.height), s2.inputEncoding.value = Ti[t2.encoding], s2.outputEncoding.value = Ti[e2.texture.encoding], Ui(e2, 0, 0, 3 * bi, 2 * bi), n2.setRenderTarget(e2), n2.render(r2, Ei);
        }
        _applyPMREM(t2) {
          const e2 = this._renderer, n2 = e2.autoClear;
          e2.autoClear = false;
          for (let e3 = 1; e3 < wi; e3++) {
            const n3 = Math.sqrt(Ri[e3] * Ri[e3] - Ri[e3 - 1] * Ri[e3 - 1]), i2 = Ni[(e3 - 1) % Ni.length];
            this._blur(t2, e3 - 1, e3, n3, i2);
          }
          e2.autoClear = n2;
        }
        _blur(t2, e2, n2, i2, r2) {
          const s2 = this._pingPongRenderTarget;
          this._halfBlur(t2, s2, e2, n2, i2, "latitudinal", r2), this._halfBlur(s2, t2, n2, n2, i2, "longitudinal", r2);
        }
        _halfBlur(t2, e2, n2, i2, r2, s2, a2) {
          const o3 = this._renderer, l2 = this._blurMaterial;
          "latitudinal" !== s2 && "longitudinal" !== s2 && console.error("blur direction must be either latitudinal or longitudinal!");
          const c2 = new Gn(Ai[i2], l2), h2 = l2.uniforms, u2 = Li[n2] - 1, d2 = isFinite(r2) ? Math.PI / (2 * u2) : 2 * Math.PI / 39, p2 = r2 / d2, m2 = isFinite(r2) ? 1 + Math.floor(3 * p2) : Si;
          m2 > Si && console.warn(`sigmaRadians, ${r2}, is too large and will clip, as it requested ${m2} samples when the maximum is set to 20`);
          const f2 = [];
          let g2 = 0;
          for (let t3 = 0; t3 < Si; ++t3) {
            const e3 = t3 / p2, n3 = Math.exp(-e3 * e3 / 2);
            f2.push(n3), 0 == t3 ? g2 += n3 : t3 < m2 && (g2 += 2 * n3);
          }
          for (let t3 = 0; t3 < f2.length; t3++)
            f2[t3] = f2[t3] / g2;
          h2.envMap.value = t2.texture, h2.samples.value = m2, h2.weights.value = f2, h2.latitudinal.value = "latitudinal" === s2, a2 && (h2.poleAxis.value = a2), h2.dTheta.value = d2, h2.mipInt.value = 8 - n2, h2.inputEncoding.value = Ti[t2.texture.encoding], h2.outputEncoding.value = Ti[t2.texture.encoding];
          const v2 = Li[i2];
          Ui(e2, 3 * Math.max(0, bi - 2 * v2), (0 === i2 ? 0 : 2 * bi) + 2 * v2 * (i2 > 4 ? i2 - 8 + 4 : 0), 3 * v2, 2 * v2), o3.setRenderTarget(e2), o3.render(c2, Ei);
        }
      }
      function Bi(t2) {
        return void 0 !== t2 && t2.type === x && (t2.encoding === X || t2.encoding === Y || t2.encoding === J);
      }
      function Fi() {
        const t2 = [], e2 = [], n2 = [];
        let i2 = 8;
        for (let r2 = 0; r2 < wi; r2++) {
          const s2 = Math.pow(2, i2);
          e2.push(s2);
          let a2 = 1 / s2;
          r2 > 4 ? a2 = Mi[r2 - 8 + 4 - 1] : 0 == r2 && (a2 = 0), n2.push(a2);
          const o3 = 1 / (s2 - 1), l2 = -o3 / 2, c2 = 1 + o3 / 2, h2 = [l2, l2, c2, l2, c2, c2, l2, l2, c2, c2, l2, c2], u2 = 6, d2 = 6, p2 = 3, m2 = 2, f2 = 1, g2 = new Float32Array(p2 * d2 * u2), v2 = new Float32Array(m2 * d2 * u2), y2 = new Float32Array(f2 * d2 * u2);
          for (let t3 = 0; t3 < u2; t3++) {
            const e3 = t3 % 3 * 2 / 3 - 1, n3 = t3 > 2 ? 0 : -1, i3 = [e3, n3, 0, e3 + 2 / 3, n3, 0, e3 + 2 / 3, n3 + 1, 0, e3, n3, 0, e3 + 2 / 3, n3 + 1, 0, e3, n3 + 1, 0];
            g2.set(i3, p2 * d2 * t3), v2.set(h2, m2 * d2 * t3);
            const r3 = [t3, t3, t3, t3, t3, t3];
            y2.set(r3, f2 * d2 * t3);
          }
          const x2 = new wn();
          x2.setAttribute("position", new en(g2, p2)), x2.setAttribute("uv", new en(v2, m2)), x2.setAttribute("faceIndex", new en(y2, f2)), t2.push(x2), i2 > 4 && i2--;
        }
        return { _lodPlanes: t2, _sizeLods: e2, _sigmas: n2 };
      }
      function Oi(t2) {
        const e2 = new Tt(3 * bi, 3 * bi, t2);
        return e2.texture.mapping = l, e2.texture.name = "PMREM.cubeUv", e2.scissorTest = true, e2;
      }
      function Ui(t2, e2, n2, i2, r2) {
        t2.viewport.set(e2, n2, i2, r2), t2.scissor.set(e2, n2, i2, r2);
      }
      function Hi() {
        const t2 = new vt(1, 1);
        return new _i({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: t2 }, inputEncoding: { value: Ti[3e3] }, outputEncoding: { value: Ti[3e3] } }, vertexShader: ki(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Vi()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: false, depthWrite: false });
      }
      function Gi() {
        return new _i({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Ti[3e3] }, outputEncoding: { value: Ti[3e3] } }, vertexShader: ki(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Vi()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: false, depthWrite: false });
      }
      function ki() {
        return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
      }
      function Vi() {
        return "\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	";
      }
      function Wi(t2) {
        let e2 = /* @__PURE__ */ new WeakMap(), n2 = null;
        function i2(t3) {
          const n3 = t3.target;
          n3.removeEventListener("dispose", i2);
          const r2 = e2.get(n3);
          void 0 !== r2 && (e2.delete(n3), r2.dispose());
        }
        return { get: function(l2) {
          if (l2 && l2.isTexture && false === l2.isRenderTargetTexture) {
            const c2 = l2.mapping, h2 = c2 === a || c2 === o2, u2 = c2 === r || c2 === s;
            if (h2 || u2) {
              if (e2.has(l2))
                return e2.get(l2).texture;
              {
                const r2 = l2.image;
                if (h2 && r2 && r2.height > 0 || u2 && r2 && function(t3) {
                  let e3 = 0;
                  const n3 = 6;
                  for (let i3 = 0; i3 < n3; i3++)
                    void 0 !== t3[i3] && e3++;
                  return e3 === n3;
                }(r2)) {
                  const r3 = t2.getRenderTarget();
                  null === n2 && (n2 = new zi(t2));
                  const s2 = h2 ? n2.fromEquirectangular(l2) : n2.fromCubemap(l2);
                  return e2.set(l2, s2), t2.setRenderTarget(r3), l2.addEventListener("dispose", i2), s2.texture;
                }
                return null;
              }
            }
          }
          return l2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap(), null !== n2 && (n2.dispose(), n2 = null);
        } };
      }
      function ji(t2) {
        const e2 = {};
        function n2(n3) {
          if (void 0 !== e2[n3])
            return e2[n3];
          let i2;
          switch (n3) {
            case "WEBGL_depth_texture":
              i2 = t2.getExtension("WEBGL_depth_texture") || t2.getExtension("MOZ_WEBGL_depth_texture") || t2.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i2 = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i2 = t2.getExtension("WEBGL_compressed_texture_s3tc") || t2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i2 = t2.getExtension("WEBGL_compressed_texture_pvrtc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i2 = t2.getExtension(n3);
          }
          return e2[n3] = i2, i2;
        }
        return { has: function(t3) {
          return null !== n2(t3);
        }, init: function(t3) {
          t3.isWebGL2 ? n2("EXT_color_buffer_float") : (n2("WEBGL_depth_texture"), n2("OES_texture_float"), n2("OES_texture_half_float"), n2("OES_texture_half_float_linear"), n2("OES_standard_derivatives"), n2("OES_element_index_uint"), n2("OES_vertex_array_object"), n2("ANGLE_instanced_arrays")), n2("OES_texture_float_linear"), n2("EXT_color_buffer_half_float");
        }, get: function(t3) {
          const e3 = n2(t3);
          return null === e3 && console.warn("THREE.WebGLRenderer: " + t3 + " extension not supported."), e3;
        } };
      }
      function qi(t2, e2, n2, i2) {
        const r2 = {}, s2 = /* @__PURE__ */ new WeakMap();
        function a2(t3) {
          const o4 = t3.target;
          null !== o4.index && e2.remove(o4.index);
          for (const t4 in o4.attributes)
            e2.remove(o4.attributes[t4]);
          o4.removeEventListener("dispose", a2), delete r2[o4.id];
          const l2 = s2.get(o4);
          l2 && (e2.remove(l2), s2.delete(o4)), i2.releaseStatesOfGeometry(o4), true === o4.isInstancedBufferGeometry && delete o4._maxInstanceCount, n2.memory.geometries--;
        }
        function o3(t3) {
          const n3 = [], i3 = t3.index, r3 = t3.attributes.position;
          let a3 = 0;
          if (null !== i3) {
            const t4 = i3.array;
            a3 = i3.version;
            for (let e3 = 0, i4 = t4.length; e3 < i4; e3 += 3) {
              const i5 = t4[e3 + 0], r4 = t4[e3 + 1], s3 = t4[e3 + 2];
              n3.push(i5, r4, r4, s3, s3, i5);
            }
          } else {
            const t4 = r3.array;
            a3 = r3.version;
            for (let e3 = 0, i4 = t4.length / 3 - 1; e3 < i4; e3 += 3) {
              const t5 = e3 + 0, i5 = e3 + 1, r4 = e3 + 2;
              n3.push(t5, i5, i5, r4, r4, t5);
            }
          }
          const o4 = new (pn(n3) > 65535 ? cn : on)(n3, 1);
          o4.version = a3;
          const l2 = s2.get(t3);
          l2 && e2.remove(l2), s2.set(t3, o4);
        }
        return { get: function(t3, e3) {
          return true === r2[e3.id] || (e3.addEventListener("dispose", a2), r2[e3.id] = true, n2.memory.geometries++), e3;
        }, update: function(t3) {
          const n3 = t3.attributes;
          for (const t4 in n3)
            e2.update(n3[t4], 34962);
          const i3 = t3.morphAttributes;
          for (const t4 in i3) {
            const n4 = i3[t4];
            for (let t5 = 0, i4 = n4.length; t5 < i4; t5++)
              e2.update(n4[t5], 34962);
          }
        }, getWireframeAttribute: function(t3) {
          const e3 = s2.get(t3);
          if (e3) {
            const n3 = t3.index;
            null !== n3 && e3.version < n3.version && o3(t3);
          } else
            o3(t3);
          return s2.get(t3);
        } };
      }
      function Xi(t2, e2, n2, i2) {
        const r2 = i2.isWebGL2;
        let s2, a2, o3;
        this.setMode = function(t3) {
          s2 = t3;
        }, this.setIndex = function(t3) {
          a2 = t3.type, o3 = t3.bytesPerElement;
        }, this.render = function(e3, i3) {
          t2.drawElements(s2, i3, a2, e3 * o3), n2.update(i3, s2, 1);
        }, this.renderInstances = function(i3, l2, c2) {
          if (0 === c2)
            return;
          let h2, u2;
          if (r2)
            h2 = t2, u2 = "drawElementsInstanced";
          else if (h2 = e2.get("ANGLE_instanced_arrays"), u2 = "drawElementsInstancedANGLE", null === h2)
            return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          h2[u2](s2, l2, a2, i3 * o3, c2), n2.update(l2, s2, c2);
        };
      }
      function Yi(t2) {
        const e2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return { memory: { geometries: 0, textures: 0 }, render: e2, programs: null, autoReset: true, reset: function() {
          e2.frame++, e2.calls = 0, e2.triangles = 0, e2.points = 0, e2.lines = 0;
        }, update: function(t3, n2, i2) {
          switch (e2.calls++, n2) {
            case 4:
              e2.triangles += i2 * (t3 / 3);
              break;
            case 1:
              e2.lines += i2 * (t3 / 2);
              break;
            case 3:
              e2.lines += i2 * (t3 - 1);
              break;
            case 2:
              e2.lines += i2 * t3;
              break;
            case 0:
              e2.points += i2 * t3;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n2);
          }
        } };
      }
      function Ji(t2, e2) {
        return t2[0] - e2[0];
      }
      function Zi(t2, e2) {
        return Math.abs(e2[1]) - Math.abs(t2[1]);
      }
      function Qi(t2) {
        const e2 = {}, n2 = new Float32Array(8), i2 = [];
        for (let t3 = 0; t3 < 8; t3++)
          i2[t3] = [t3, 0];
        return { update: function(r2, s2, a2, o3) {
          const l2 = r2.morphTargetInfluences, c2 = void 0 === l2 ? 0 : l2.length;
          let h2 = e2[s2.id];
          if (void 0 === h2 || h2.length !== c2) {
            h2 = [];
            for (let t3 = 0; t3 < c2; t3++)
              h2[t3] = [t3, 0];
            e2[s2.id] = h2;
          }
          for (let t3 = 0; t3 < c2; t3++) {
            const e3 = h2[t3];
            e3[0] = t3, e3[1] = l2[t3];
          }
          h2.sort(Zi);
          for (let t3 = 0; t3 < 8; t3++)
            t3 < c2 && h2[t3][1] ? (i2[t3][0] = h2[t3][0], i2[t3][1] = h2[t3][1]) : (i2[t3][0] = Number.MAX_SAFE_INTEGER, i2[t3][1] = 0);
          i2.sort(Ji);
          const u2 = s2.morphAttributes.position, d2 = s2.morphAttributes.normal;
          let p2 = 0;
          for (let t3 = 0; t3 < 8; t3++) {
            const e3 = i2[t3], r3 = e3[0], a3 = e3[1];
            r3 !== Number.MAX_SAFE_INTEGER && a3 ? (u2 && s2.getAttribute("morphTarget" + t3) !== u2[r3] && s2.setAttribute("morphTarget" + t3, u2[r3]), d2 && s2.getAttribute("morphNormal" + t3) !== d2[r3] && s2.setAttribute("morphNormal" + t3, d2[r3]), n2[t3] = a3, p2 += a3) : (u2 && true === s2.hasAttribute("morphTarget" + t3) && s2.deleteAttribute("morphTarget" + t3), d2 && true === s2.hasAttribute("morphNormal" + t3) && s2.deleteAttribute("morphNormal" + t3), n2[t3] = 0);
          }
          const m2 = s2.morphTargetsRelative ? 1 : 1 - p2;
          o3.getUniforms().setValue(t2, "morphTargetBaseInfluence", m2), o3.getUniforms().setValue(t2, "morphTargetInfluences", n2);
        } };
      }
      function Ki(t2, e2, n2, i2) {
        let r2 = /* @__PURE__ */ new WeakMap();
        function s2(t3) {
          const e3 = t3.target;
          e3.removeEventListener("dispose", s2), n2.remove(e3.instanceMatrix), null !== e3.instanceColor && n2.remove(e3.instanceColor);
        }
        return { update: function(t3) {
          const a2 = i2.render.frame, o3 = t3.geometry, l2 = e2.get(t3, o3);
          return r2.get(l2) !== a2 && (e2.update(l2), r2.set(l2, a2)), t3.isInstancedMesh && (false === t3.hasEventListener("dispose", s2) && t3.addEventListener("dispose", s2), n2.update(t3.instanceMatrix, 34962), null !== t3.instanceColor && n2.update(t3.instanceColor, 34962)), l2;
        }, dispose: function() {
          r2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      class $i extends Mt {
        constructor(t2 = null, e2 = 1, n2 = 1, i2 = 1) {
          super(null), this.image = { data: t2, width: e2, height: n2, depth: i2 }, this.magFilter = p, this.minFilter = p, this.wrapR = u, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
        }
      }
      $i.prototype.isDataTexture2DArray = true;
      class tr extends Mt {
        constructor(t2 = null, e2 = 1, n2 = 1, i2 = 1) {
          super(null), this.image = { data: t2, width: e2, height: n2, depth: i2 }, this.magFilter = p, this.minFilter = p, this.wrapR = u, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
        }
      }
      tr.prototype.isDataTexture3D = true;
      const er = new Mt(), nr = new $i(), ir = new tr(), rr = new Kn(), sr = [], ar = [], or = new Float32Array(16), lr = new Float32Array(9), cr = new Float32Array(4);
      function hr(t2, e2, n2) {
        const i2 = t2[0];
        if (i2 <= 0 || i2 > 0)
          return t2;
        const r2 = e2 * n2;
        let s2 = sr[r2];
        if (void 0 === s2 && (s2 = new Float32Array(r2), sr[r2] = s2), 0 !== e2) {
          i2.toArray(s2, 0);
          for (let i3 = 1, r3 = 0; i3 !== e2; ++i3)
            r3 += n2, t2[i3].toArray(s2, r3);
        }
        return s2;
      }
      function ur(t2, e2) {
        if (t2.length !== e2.length)
          return false;
        for (let n2 = 0, i2 = t2.length; n2 < i2; n2++)
          if (t2[n2] !== e2[n2])
            return false;
        return true;
      }
      function dr(t2, e2) {
        for (let n2 = 0, i2 = e2.length; n2 < i2; n2++)
          t2[n2] = e2[n2];
      }
      function pr(t2, e2) {
        let n2 = ar[e2];
        void 0 === n2 && (n2 = new Int32Array(e2), ar[e2] = n2);
        for (let i2 = 0; i2 !== e2; ++i2)
          n2[i2] = t2.allocateTextureUnit();
        return n2;
      }
      function mr(t2, e2) {
        const n2 = this.cache;
        n2[0] !== e2 && (t2.uniform1f(this.addr, e2), n2[0] = e2);
      }
      function fr(t2, e2) {
        const n2 = this.cache;
        if (void 0 !== e2.x)
          n2[0] === e2.x && n2[1] === e2.y || (t2.uniform2f(this.addr, e2.x, e2.y), n2[0] = e2.x, n2[1] = e2.y);
        else {
          if (ur(n2, e2))
            return;
          t2.uniform2fv(this.addr, e2), dr(n2, e2);
        }
      }
      function gr(t2, e2) {
        const n2 = this.cache;
        if (void 0 !== e2.x)
          n2[0] === e2.x && n2[1] === e2.y && n2[2] === e2.z || (t2.uniform3f(this.addr, e2.x, e2.y, e2.z), n2[0] = e2.x, n2[1] = e2.y, n2[2] = e2.z);
        else if (void 0 !== e2.r)
          n2[0] === e2.r && n2[1] === e2.g && n2[2] === e2.b || (t2.uniform3f(this.addr, e2.r, e2.g, e2.b), n2[0] = e2.r, n2[1] = e2.g, n2[2] = e2.b);
        else {
          if (ur(n2, e2))
            return;
          t2.uniform3fv(this.addr, e2), dr(n2, e2);
        }
      }
      function vr(t2, e2) {
        const n2 = this.cache;
        if (void 0 !== e2.x)
          n2[0] === e2.x && n2[1] === e2.y && n2[2] === e2.z && n2[3] === e2.w || (t2.uniform4f(this.addr, e2.x, e2.y, e2.z, e2.w), n2[0] = e2.x, n2[1] = e2.y, n2[2] = e2.z, n2[3] = e2.w);
        else {
          if (ur(n2, e2))
            return;
          t2.uniform4fv(this.addr, e2), dr(n2, e2);
        }
      }
      function yr(t2, e2) {
        const n2 = this.cache, i2 = e2.elements;
        if (void 0 === i2) {
          if (ur(n2, e2))
            return;
          t2.uniformMatrix2fv(this.addr, false, e2), dr(n2, e2);
        } else {
          if (ur(n2, i2))
            return;
          cr.set(i2), t2.uniformMatrix2fv(this.addr, false, cr), dr(n2, i2);
        }
      }
      function xr(t2, e2) {
        const n2 = this.cache, i2 = e2.elements;
        if (void 0 === i2) {
          if (ur(n2, e2))
            return;
          t2.uniformMatrix3fv(this.addr, false, e2), dr(n2, e2);
        } else {
          if (ur(n2, i2))
            return;
          lr.set(i2), t2.uniformMatrix3fv(this.addr, false, lr), dr(n2, i2);
        }
      }
      function _r(t2, e2) {
        const n2 = this.cache, i2 = e2.elements;
        if (void 0 === i2) {
          if (ur(n2, e2))
            return;
          t2.uniformMatrix4fv(this.addr, false, e2), dr(n2, e2);
        } else {
          if (ur(n2, i2))
            return;
          or.set(i2), t2.uniformMatrix4fv(this.addr, false, or), dr(n2, i2);
        }
      }
      function br(t2, e2) {
        const n2 = this.cache;
        n2[0] !== e2 && (t2.uniform1i(this.addr, e2), n2[0] = e2);
      }
      function Mr(t2, e2) {
        const n2 = this.cache;
        ur(n2, e2) || (t2.uniform2iv(this.addr, e2), dr(n2, e2));
      }
      function wr(t2, e2) {
        const n2 = this.cache;
        ur(n2, e2) || (t2.uniform3iv(this.addr, e2), dr(n2, e2));
      }
      function Sr(t2, e2) {
        const n2 = this.cache;
        ur(n2, e2) || (t2.uniform4iv(this.addr, e2), dr(n2, e2));
      }
      function Tr(t2, e2) {
        const n2 = this.cache;
        n2[0] !== e2 && (t2.uniform1ui(this.addr, e2), n2[0] = e2);
      }
      function Er(t2, e2) {
        const n2 = this.cache;
        ur(n2, e2) || (t2.uniform2uiv(this.addr, e2), dr(n2, e2));
      }
      function Ar(t2, e2) {
        const n2 = this.cache;
        ur(n2, e2) || (t2.uniform3uiv(this.addr, e2), dr(n2, e2));
      }
      function Lr(t2, e2) {
        const n2 = this.cache;
        ur(n2, e2) || (t2.uniform4uiv(this.addr, e2), dr(n2, e2));
      }
      function Rr(t2, e2, n2) {
        const i2 = this.cache, r2 = n2.allocateTextureUnit();
        i2[0] !== r2 && (t2.uniform1i(this.addr, r2), i2[0] = r2), n2.safeSetTexture2D(e2 || er, r2);
      }
      function Cr(t2, e2, n2) {
        const i2 = this.cache, r2 = n2.allocateTextureUnit();
        i2[0] !== r2 && (t2.uniform1i(this.addr, r2), i2[0] = r2), n2.setTexture3D(e2 || ir, r2);
      }
      function Pr(t2, e2, n2) {
        const i2 = this.cache, r2 = n2.allocateTextureUnit();
        i2[0] !== r2 && (t2.uniform1i(this.addr, r2), i2[0] = r2), n2.safeSetTextureCube(e2 || rr, r2);
      }
      function Ir(t2, e2, n2) {
        const i2 = this.cache, r2 = n2.allocateTextureUnit();
        i2[0] !== r2 && (t2.uniform1i(this.addr, r2), i2[0] = r2), n2.setTexture2DArray(e2 || nr, r2);
      }
      function Dr(t2, e2) {
        t2.uniform1fv(this.addr, e2);
      }
      function Nr(t2, e2) {
        const n2 = hr(e2, this.size, 2);
        t2.uniform2fv(this.addr, n2);
      }
      function zr(t2, e2) {
        const n2 = hr(e2, this.size, 3);
        t2.uniform3fv(this.addr, n2);
      }
      function Br(t2, e2) {
        const n2 = hr(e2, this.size, 4);
        t2.uniform4fv(this.addr, n2);
      }
      function Fr(t2, e2) {
        const n2 = hr(e2, this.size, 4);
        t2.uniformMatrix2fv(this.addr, false, n2);
      }
      function Or(t2, e2) {
        const n2 = hr(e2, this.size, 9);
        t2.uniformMatrix3fv(this.addr, false, n2);
      }
      function Ur(t2, e2) {
        const n2 = hr(e2, this.size, 16);
        t2.uniformMatrix4fv(this.addr, false, n2);
      }
      function Hr(t2, e2) {
        t2.uniform1iv(this.addr, e2);
      }
      function Gr(t2, e2) {
        t2.uniform2iv(this.addr, e2);
      }
      function kr(t2, e2) {
        t2.uniform3iv(this.addr, e2);
      }
      function Vr(t2, e2) {
        t2.uniform4iv(this.addr, e2);
      }
      function Wr(t2, e2) {
        t2.uniform1uiv(this.addr, e2);
      }
      function jr(t2, e2) {
        t2.uniform2uiv(this.addr, e2);
      }
      function qr(t2, e2) {
        t2.uniform3uiv(this.addr, e2);
      }
      function Xr(t2, e2) {
        t2.uniform4uiv(this.addr, e2);
      }
      function Yr(t2, e2, n2) {
        const i2 = e2.length, r2 = pr(n2, i2);
        t2.uniform1iv(this.addr, r2);
        for (let t3 = 0; t3 !== i2; ++t3)
          n2.safeSetTexture2D(e2[t3] || er, r2[t3]);
      }
      function Jr(t2, e2, n2) {
        const i2 = e2.length, r2 = pr(n2, i2);
        t2.uniform1iv(this.addr, r2);
        for (let t3 = 0; t3 !== i2; ++t3)
          n2.safeSetTextureCube(e2[t3] || rr, r2[t3]);
      }
      function Zr(t2, e2, n2) {
        this.id = t2, this.addr = n2, this.cache = [], this.setValue = function(t3) {
          switch (t3) {
            case 5126:
              return mr;
            case 35664:
              return fr;
            case 35665:
              return gr;
            case 35666:
              return vr;
            case 35674:
              return yr;
            case 35675:
              return xr;
            case 35676:
              return _r;
            case 5124:
            case 35670:
              return br;
            case 35667:
            case 35671:
              return Mr;
            case 35668:
            case 35672:
              return wr;
            case 35669:
            case 35673:
              return Sr;
            case 5125:
              return Tr;
            case 36294:
              return Er;
            case 36295:
              return Ar;
            case 36296:
              return Lr;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Rr;
            case 35679:
            case 36299:
            case 36307:
              return Cr;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Pr;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Ir;
          }
        }(e2.type);
      }
      function Qr(t2, e2, n2) {
        this.id = t2, this.addr = n2, this.cache = [], this.size = e2.size, this.setValue = function(t3) {
          switch (t3) {
            case 5126:
              return Dr;
            case 35664:
              return Nr;
            case 35665:
              return zr;
            case 35666:
              return Br;
            case 35674:
              return Fr;
            case 35675:
              return Or;
            case 35676:
              return Ur;
            case 5124:
            case 35670:
              return Hr;
            case 35667:
            case 35671:
              return Gr;
            case 35668:
            case 35672:
              return kr;
            case 35669:
            case 35673:
              return Vr;
            case 5125:
              return Wr;
            case 36294:
              return jr;
            case 36295:
              return qr;
            case 36296:
              return Xr;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Yr;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Jr;
          }
        }(e2.type);
      }
      function Kr(t2) {
        this.id = t2, this.seq = [], this.map = {};
      }
      Qr.prototype.updateCache = function(t2) {
        const e2 = this.cache;
        t2 instanceof Float32Array && e2.length !== t2.length && (this.cache = new Float32Array(t2.length)), dr(e2, t2);
      }, Kr.prototype.setValue = function(t2, e2, n2) {
        const i2 = this.seq;
        for (let r2 = 0, s2 = i2.length; r2 !== s2; ++r2) {
          const s3 = i2[r2];
          s3.setValue(t2, e2[s3.id], n2);
        }
      };
      const $r = /(\w+)(\])?(\[|\.)?/g;
      function ts(t2, e2) {
        t2.seq.push(e2), t2.map[e2.id] = e2;
      }
      function es(t2, e2, n2) {
        const i2 = t2.name, r2 = i2.length;
        for ($r.lastIndex = 0; ; ) {
          const s2 = $r.exec(i2), a2 = $r.lastIndex;
          let o3 = s2[1];
          const l2 = "]" === s2[2], c2 = s2[3];
          if (l2 && (o3 |= 0), void 0 === c2 || "[" === c2 && a2 + 2 === r2) {
            ts(n2, void 0 === c2 ? new Zr(o3, t2, e2) : new Qr(o3, t2, e2));
            break;
          }
          {
            let t3 = n2.map[o3];
            void 0 === t3 && (t3 = new Kr(o3), ts(n2, t3)), n2 = t3;
          }
        }
      }
      function ns(t2, e2) {
        this.seq = [], this.map = {};
        const n2 = t2.getProgramParameter(e2, 35718);
        for (let i2 = 0; i2 < n2; ++i2) {
          const n3 = t2.getActiveUniform(e2, i2);
          es(n3, t2.getUniformLocation(e2, n3.name), this);
        }
      }
      function is(t2, e2, n2) {
        const i2 = t2.createShader(e2);
        return t2.shaderSource(i2, n2), t2.compileShader(i2), i2;
      }
      ns.prototype.setValue = function(t2, e2, n2, i2) {
        const r2 = this.map[e2];
        void 0 !== r2 && r2.setValue(t2, n2, i2);
      }, ns.prototype.setOptional = function(t2, e2, n2) {
        const i2 = e2[n2];
        void 0 !== i2 && this.setValue(t2, n2, i2);
      }, ns.upload = function(t2, e2, n2, i2) {
        for (let r2 = 0, s2 = e2.length; r2 !== s2; ++r2) {
          const s3 = e2[r2], a2 = n2[s3.id];
          false !== a2.needsUpdate && s3.setValue(t2, a2.value, i2);
        }
      }, ns.seqWithValue = function(t2, e2) {
        const n2 = [];
        for (let i2 = 0, r2 = t2.length; i2 !== r2; ++i2) {
          const r3 = t2[i2];
          r3.id in e2 && n2.push(r3);
        }
        return n2;
      };
      let rs = 0;
      function ss(t2) {
        switch (t2) {
          case X:
            return ["Linear", "( value )"];
          case Y:
            return ["sRGB", "( value )"];
          case Z:
            return ["RGBE", "( value )"];
          case Q:
            return ["RGBM", "( value, 7.0 )"];
          case K:
            return ["RGBM", "( value, 16.0 )"];
          case $:
            return ["RGBD", "( value, 256.0 )"];
          case J:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case 3003:
            return ["LogLuv", "( value )"];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t2), ["Linear", "( value )"];
        }
      }
      function as(t2, e2, n2) {
        const i2 = t2.getShaderParameter(e2, 35713), r2 = t2.getShaderInfoLog(e2).trim();
        return i2 && "" === r2 ? "" : n2.toUpperCase() + "\n\n" + r2 + "\n\n" + function(t3) {
          const e3 = t3.split("\n");
          for (let t4 = 0; t4 < e3.length; t4++)
            e3[t4] = t4 + 1 + ": " + e3[t4];
          return e3.join("\n");
        }(t2.getShaderSource(e2));
      }
      function os(t2, e2) {
        const n2 = ss(e2);
        return "vec4 " + t2 + "( vec4 value ) { return " + n2[0] + "ToLinear" + n2[1] + "; }";
      }
      function ls(t2, e2) {
        const n2 = ss(e2);
        return "vec4 " + t2 + "( vec4 value ) { return LinearTo" + n2[0] + n2[1] + "; }";
      }
      function cs(t2, e2) {
        let n2;
        switch (e2) {
          case 1:
            n2 = "Linear";
            break;
          case 2:
            n2 = "Reinhard";
            break;
          case 3:
            n2 = "OptimizedCineon";
            break;
          case 4:
            n2 = "ACESFilmic";
            break;
          case 5:
            n2 = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e2), n2 = "Linear";
        }
        return "vec3 " + t2 + "( vec3 color ) { return " + n2 + "ToneMapping( color ); }";
      }
      function hs(t2) {
        return "" !== t2;
      }
      function us(t2, e2) {
        return t2.replace(/NUM_DIR_LIGHTS/g, e2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e2.numPointLightShadows);
      }
      function ds(t2, e2) {
        return t2.replace(/NUM_CLIPPING_PLANES/g, e2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e2.numClippingPlanes - e2.numClipIntersection);
      }
      const ps = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function ms(t2) {
        return t2.replace(ps, fs);
      }
      function fs(t2, e2) {
        const n2 = hi[e2];
        if (void 0 === n2)
          throw new Error("Can not resolve #include <" + e2 + ">");
        return ms(n2);
      }
      const gs = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, vs = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function ys(t2) {
        return t2.replace(vs, _s).replace(gs, xs);
      }
      function xs(t2, e2, n2, i2) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), _s(t2, e2, n2, i2);
      }
      function _s(t2, e2, n2, i2) {
        let r2 = "";
        for (let t3 = parseInt(e2); t3 < parseInt(n2); t3++)
          r2 += i2.replace(/\[\s*i\s*\]/g, "[ " + t3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t3);
        return r2;
      }
      function bs(t2) {
        let e2 = "precision " + t2.precision + " float;\nprecision " + t2.precision + " int;";
        return "highp" === t2.precision ? e2 += "\n#define HIGH_PRECISION" : "mediump" === t2.precision ? e2 += "\n#define MEDIUM_PRECISION" : "lowp" === t2.precision && (e2 += "\n#define LOW_PRECISION"), e2;
      }
      function Ms(t2, e2, n2, i2) {
        const a2 = t2.getContext(), o3 = n2.defines;
        let h2 = n2.vertexShader, u2 = n2.fragmentShader;
        const d2 = function(t3) {
          let e3 = "SHADOWMAP_TYPE_BASIC";
          return 1 === t3.shadowMapType ? e3 = "SHADOWMAP_TYPE_PCF" : 2 === t3.shadowMapType ? e3 = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t3.shadowMapType && (e3 = "SHADOWMAP_TYPE_VSM"), e3;
        }(n2), p2 = function(t3) {
          let e3 = "ENVMAP_TYPE_CUBE";
          if (t3.envMap)
            switch (t3.envMapMode) {
              case r:
              case s:
                e3 = "ENVMAP_TYPE_CUBE";
                break;
              case l:
              case c:
                e3 = "ENVMAP_TYPE_CUBE_UV";
            }
          return e3;
        }(n2), m2 = function(t3) {
          let e3 = "ENVMAP_MODE_REFLECTION";
          if (t3.envMap)
            switch (t3.envMapMode) {
              case s:
              case c:
                e3 = "ENVMAP_MODE_REFRACTION";
            }
          return e3;
        }(n2), f2 = function(t3) {
          let e3 = "ENVMAP_BLENDING_NONE";
          if (t3.envMap)
            switch (t3.combine) {
              case 0:
                e3 = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                e3 = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                e3 = "ENVMAP_BLENDING_ADD";
            }
          return e3;
        }(n2), g2 = t2.gammaFactor > 0 ? t2.gammaFactor : 1, v2 = n2.isWebGL2 ? "" : function(t3) {
          return [t3.extensionDerivatives || t3.envMapCubeUV || t3.bumpMap || t3.tangentSpaceNormalMap || t3.clearcoatNormalMap || t3.flatShading || "physical" === t3.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t3.extensionFragDepth || t3.logarithmicDepthBuffer) && t3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t3.extensionDrawBuffers && t3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t3.extensionShaderTextureLOD || t3.envMap || t3.transmission) && t3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(hs).join("\n");
        }(n2), y2 = function(t3) {
          const e3 = [];
          for (const n3 in t3) {
            const i3 = t3[n3];
            false !== i3 && e3.push("#define " + n3 + " " + i3);
          }
          return e3.join("\n");
        }(o3), x2 = a2.createProgram();
        let _2, b2, M2 = n2.glslVersion ? "#version " + n2.glslVersion + "\n" : "";
        n2.isRawShaderMaterial ? (_2 = [y2].filter(hs).join("\n"), _2.length > 0 && (_2 += "\n"), b2 = [v2, y2].filter(hs).join("\n"), b2.length > 0 && (b2 += "\n")) : (_2 = [bs(n2), "#define SHADER_NAME " + n2.shaderName, y2, n2.instancing ? "#define USE_INSTANCING" : "", n2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g2, "#define MAX_BONES " + n2.maxBones, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + m2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.displacementMap && n2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n2.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.transmission ? "#define USE_TRANSMISSION" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.thicknessMap ? "#define USE_THICKNESSMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.skinning ? "#define USE_SKINNING" : "", n2.useVertexTexture ? "#define BONE_TEXTURE" : "", n2.morphTargets ? "#define USE_MORPHTARGETS" : "", n2.morphNormals && false === n2.flatShading ? "#define USE_MORPHNORMALS" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + d2 : "", n2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(hs).join("\n"), b2 = [v2, bs(n2), "#define SHADER_NAME " + n2.shaderName, y2, "#define GAMMA_FACTOR " + g2, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.matcap ? "#define USE_MATCAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + p2 : "", n2.envMap ? "#define " + m2 : "", n2.envMap ? "#define " + f2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoat ? "#define USE_CLEARCOAT" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n2.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.alphaTest ? "#define USE_ALPHATEST" : "", n2.sheenTint ? "#define USE_SHEEN" : "", n2.transmission ? "#define USE_TRANSMISSION" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.thicknessMap ? "#define USE_THICKNESSMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors || n2.instancingColor ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.gradientMap ? "#define USE_GRADIENTMAP" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + d2 : "", n2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n2.extensionShaderTextureLOD || n2.envMap) && n2.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n2.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n2.toneMapping ? hi.tonemapping_pars_fragment : "", 0 !== n2.toneMapping ? cs("toneMapping", n2.toneMapping) : "", n2.dithering ? "#define DITHERING" : "", n2.format === T ? "#define OPAQUE" : "", hi.encodings_pars_fragment, n2.map ? os("mapTexelToLinear", n2.mapEncoding) : "", n2.matcap ? os("matcapTexelToLinear", n2.matcapEncoding) : "", n2.envMap ? os("envMapTexelToLinear", n2.envMapEncoding) : "", n2.emissiveMap ? os("emissiveMapTexelToLinear", n2.emissiveMapEncoding) : "", n2.specularTintMap ? os("specularTintMapTexelToLinear", n2.specularTintMapEncoding) : "", n2.lightMap ? os("lightMapTexelToLinear", n2.lightMapEncoding) : "", ls("linearToOutputTexel", n2.outputEncoding), n2.depthPacking ? "#define DEPTH_PACKING " + n2.depthPacking : "", "\n"].filter(hs).join("\n")), h2 = ms(h2), h2 = us(h2, n2), h2 = ds(h2, n2), u2 = ms(u2), u2 = us(u2, n2), u2 = ds(u2, n2), h2 = ys(h2), u2 = ys(u2), n2.isWebGL2 && true !== n2.isRawShaderMaterial && (M2 = "#version 300 es\n", _2 = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + _2, b2 = ["#define varying in", n2.glslVersion === it ? "" : "out highp vec4 pc_fragColor;", n2.glslVersion === it ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b2);
        const w2 = M2 + b2 + u2, S2 = is(a2, 35633, M2 + _2 + h2), E2 = is(a2, 35632, w2);
        if (a2.attachShader(x2, S2), a2.attachShader(x2, E2), void 0 !== n2.index0AttributeName ? a2.bindAttribLocation(x2, 0, n2.index0AttributeName) : true === n2.morphTargets && a2.bindAttribLocation(x2, 0, "position"), a2.linkProgram(x2), t2.debug.checkShaderErrors) {
          const t3 = a2.getProgramInfoLog(x2).trim(), e3 = a2.getShaderInfoLog(S2).trim(), n3 = a2.getShaderInfoLog(E2).trim();
          let i3 = true, r2 = true;
          if (false === a2.getProgramParameter(x2, 35714)) {
            i3 = false;
            const e4 = as(a2, S2, "vertex"), n4 = as(a2, E2, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + a2.getError() + " - VALIDATE_STATUS " + a2.getProgramParameter(x2, 35715) + "\n\nProgram Info Log: " + t3 + "\n" + e4 + "\n" + n4);
          } else
            "" !== t3 ? console.warn("THREE.WebGLProgram: Program Info Log:", t3) : "" !== e3 && "" !== n3 || (r2 = false);
          r2 && (this.diagnostics = { runnable: i3, programLog: t3, vertexShader: { log: e3, prefix: _2 }, fragmentShader: { log: n3, prefix: b2 } });
        }
        let A2, L2;
        return a2.deleteShader(S2), a2.deleteShader(E2), this.getUniforms = function() {
          return void 0 === A2 && (A2 = new ns(a2, x2)), A2;
        }, this.getAttributes = function() {
          return void 0 === L2 && (L2 = function(t3, e3) {
            const n3 = {}, i3 = t3.getProgramParameter(e3, 35721);
            for (let r2 = 0; r2 < i3; r2++) {
              const i4 = t3.getActiveAttrib(e3, r2), s2 = i4.name;
              let a3 = 1;
              35674 === i4.type && (a3 = 2), 35675 === i4.type && (a3 = 3), 35676 === i4.type && (a3 = 4), n3[s2] = { type: i4.type, location: t3.getAttribLocation(e3, s2), locationSize: a3 };
            }
            return n3;
          }(a2, x2)), L2;
        }, this.destroy = function() {
          i2.releaseStatesOfProgram(this), a2.deleteProgram(x2), this.program = void 0;
        }, this.name = n2.shaderName, this.id = rs++, this.cacheKey = e2, this.usedTimes = 1, this.program = x2, this.vertexShader = S2, this.fragmentShader = E2, this;
      }
      function ws(t2, e2, n2, i2, r2, s2, a2) {
        const o3 = [], h2 = r2.isWebGL2, u2 = r2.logarithmicDepthBuffer, d2 = r2.floatVertexTextures, p2 = r2.maxVertexUniforms, m2 = r2.vertexTextures;
        let f2 = r2.precision;
        const g2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, v2 = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheenTint", "transmission", "transmissionMap", "thicknessMap"];
        function y2(t3) {
          let e3;
          return t3 && t3.isTexture ? e3 = t3.encoding : t3 && t3.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e3 = t3.texture.encoding) : e3 = X, e3;
        }
        return { getParameters: function(s3, o4, v3, x2, _2) {
          const b2 = x2.fog, M2 = s3.isMeshStandardMaterial ? x2.environment : null, w2 = (s3.isMeshStandardMaterial ? n2 : e2).get(s3.envMap || M2), S2 = g2[s3.type], T2 = _2.isSkinnedMesh ? function(t3) {
            const e3 = t3.skeleton.bones;
            if (d2)
              return 1024;
            {
              const t4 = p2, n3 = Math.floor((t4 - 20) / 4), i3 = Math.min(n3, e3.length);
              return i3 < e3.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e3.length + " bones. This GPU supports " + i3 + "."), 0) : i3;
            }
          }(_2) : 0;
          let E2, A2;
          if (null !== s3.precision && (f2 = r2.getMaxPrecision(s3.precision), f2 !== s3.precision && console.warn("THREE.WebGLProgram.getParameters:", s3.precision, "not supported, using", f2, "instead.")), S2) {
            const t3 = di[S2];
            E2 = t3.vertexShader, A2 = t3.fragmentShader;
          } else
            E2 = s3.vertexShader, A2 = s3.fragmentShader;
          const L2 = t2.getRenderTarget(), R2 = s3.alphaTest > 0, C2 = s3.clearcoat > 0;
          return { isWebGL2: h2, shaderID: S2, shaderName: s3.type, vertexShader: E2, fragmentShader: A2, defines: s3.defines, isRawShaderMaterial: true === s3.isRawShaderMaterial, glslVersion: s3.glslVersion, precision: f2, instancing: true === _2.isInstancedMesh, instancingColor: true === _2.isInstancedMesh && null !== _2.instanceColor, supportsVertexTextures: m2, outputEncoding: null !== L2 ? y2(L2.texture) : t2.outputEncoding, map: !!s3.map, mapEncoding: y2(s3.map), matcap: !!s3.matcap, matcapEncoding: y2(s3.matcap), envMap: !!w2, envMapMode: w2 && w2.mapping, envMapEncoding: y2(w2), envMapCubeUV: !!w2 && (w2.mapping === l || w2.mapping === c), lightMap: !!s3.lightMap, lightMapEncoding: y2(s3.lightMap), aoMap: !!s3.aoMap, emissiveMap: !!s3.emissiveMap, emissiveMapEncoding: y2(s3.emissiveMap), bumpMap: !!s3.bumpMap, normalMap: !!s3.normalMap, objectSpaceNormalMap: 1 === s3.normalMapType, tangentSpaceNormalMap: 0 === s3.normalMapType, clearcoat: C2, clearcoatMap: C2 && !!s3.clearcoatMap, clearcoatRoughnessMap: C2 && !!s3.clearcoatRoughnessMap, clearcoatNormalMap: C2 && !!s3.clearcoatNormalMap, displacementMap: !!s3.displacementMap, roughnessMap: !!s3.roughnessMap, metalnessMap: !!s3.metalnessMap, specularMap: !!s3.specularMap, specularIntensityMap: !!s3.specularIntensityMap, specularTintMap: !!s3.specularTintMap, specularTintMapEncoding: y2(s3.specularTintMap), alphaMap: !!s3.alphaMap, alphaTest: R2, gradientMap: !!s3.gradientMap, sheenTint: !!s3.sheenTint && (s3.sheenTint.r > 0 || s3.sheenTint.g > 0 || s3.sheenTint.b > 0), transmission: s3.transmission > 0, transmissionMap: !!s3.transmissionMap, thicknessMap: !!s3.thicknessMap, combine: s3.combine, vertexTangents: !!s3.normalMap && !!_2.geometry && !!_2.geometry.attributes.tangent, vertexColors: s3.vertexColors, vertexAlphas: true === s3.vertexColors && !!_2.geometry && !!_2.geometry.attributes.color && 4 === _2.geometry.attributes.color.itemSize, vertexUvs: !!(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatMap || s3.clearcoatRoughnessMap || s3.clearcoatNormalMap || s3.displacementMap || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularTintMap), uvsVertexOnly: !(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatNormalMap || s3.transmission > 0 || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularTintMap || !s3.displacementMap), fog: !!b2, useFog: s3.fog, fogExp2: b2 && b2.isFogExp2, flatShading: !!s3.flatShading, sizeAttenuation: s3.sizeAttenuation, logarithmicDepthBuffer: u2, skinning: true === _2.isSkinnedMesh && T2 > 0, maxBones: T2, useVertexTexture: d2, morphTargets: !!_2.geometry && !!_2.geometry.morphAttributes.position, morphNormals: !!_2.geometry && !!_2.geometry.morphAttributes.normal, numDirLights: o4.directional.length, numPointLights: o4.point.length, numSpotLights: o4.spot.length, numRectAreaLights: o4.rectArea.length, numHemiLights: o4.hemi.length, numDirLightShadows: o4.directionalShadowMap.length, numPointLightShadows: o4.pointShadowMap.length, numSpotLightShadows: o4.spotShadowMap.length, numClippingPlanes: a2.numPlanes, numClipIntersection: a2.numIntersection, format: s3.format, dithering: s3.dithering, shadowMapEnabled: t2.shadowMap.enabled && v3.length > 0, shadowMapType: t2.shadowMap.type, toneMapping: s3.toneMapped ? t2.toneMapping : 0, physicallyCorrectLights: t2.physicallyCorrectLights, premultipliedAlpha: s3.premultipliedAlpha, doubleSided: 2 === s3.side, flipSided: 1 === s3.side, depthPacking: void 0 !== s3.depthPacking && s3.depthPacking, index0AttributeName: s3.index0AttributeName, extensionDerivatives: s3.extensions && s3.extensions.derivatives, extensionFragDepth: s3.extensions && s3.extensions.fragDepth, extensionDrawBuffers: s3.extensions && s3.extensions.drawBuffers, extensionShaderTextureLOD: s3.extensions && s3.extensions.shaderTextureLOD, rendererExtensionFragDepth: h2 || i2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h2 || i2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h2 || i2.has("EXT_shader_texture_lod"), customProgramCacheKey: s3.customProgramCacheKey() };
        }, getProgramCacheKey: function(e3) {
          const n3 = [];
          if (e3.shaderID ? n3.push(e3.shaderID) : (n3.push(e3.fragmentShader), n3.push(e3.vertexShader)), void 0 !== e3.defines)
            for (const t3 in e3.defines)
              n3.push(t3), n3.push(e3.defines[t3]);
          if (false === e3.isRawShaderMaterial) {
            for (let t3 = 0; t3 < v2.length; t3++)
              n3.push(e3[v2[t3]]);
            n3.push(t2.outputEncoding), n3.push(t2.gammaFactor);
          }
          return n3.push(e3.customProgramCacheKey), n3.join();
        }, getUniforms: function(t3) {
          const e3 = g2[t3.type];
          let n3;
          if (e3) {
            const t4 = di[e3];
            n3 = qn.clone(t4.uniforms);
          } else
            n3 = t3.uniforms;
          return n3;
        }, acquireProgram: function(e3, n3) {
          let i3;
          for (let t3 = 0, e4 = o3.length; t3 < e4; t3++) {
            const e5 = o3[t3];
            if (e5.cacheKey === n3) {
              i3 = e5, ++i3.usedTimes;
              break;
            }
          }
          return void 0 === i3 && (i3 = new Ms(t2, n3, e3, s2), o3.push(i3)), i3;
        }, releaseProgram: function(t3) {
          if (0 == --t3.usedTimes) {
            const e3 = o3.indexOf(t3);
            o3[e3] = o3[o3.length - 1], o3.pop(), t3.destroy();
          }
        }, programs: o3 };
      }
      function Ss() {
        let t2 = /* @__PURE__ */ new WeakMap();
        return { get: function(e2) {
          let n2 = t2.get(e2);
          return void 0 === n2 && (n2 = {}, t2.set(e2, n2)), n2;
        }, remove: function(e2) {
          t2.delete(e2);
        }, update: function(e2, n2, i2) {
          t2.get(e2)[n2] = i2;
        }, dispose: function() {
          t2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function Ts(t2, e2) {
        return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.program !== e2.program ? t2.program.id - e2.program.id : t2.material.id !== e2.material.id ? t2.material.id - e2.material.id : t2.z !== e2.z ? t2.z - e2.z : t2.id - e2.id;
      }
      function Es(t2, e2) {
        return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.z !== e2.z ? e2.z - t2.z : t2.id - e2.id;
      }
      function As(t2) {
        const e2 = [];
        let n2 = 0;
        const i2 = [], r2 = [], s2 = [], a2 = { id: -1 };
        function o3(i3, r3, s3, o4, l2, c2) {
          let h2 = e2[n2];
          const u2 = t2.get(s3);
          return void 0 === h2 ? (h2 = { id: i3.id, object: i3, geometry: r3, material: s3, program: u2.program || a2, groupOrder: o4, renderOrder: i3.renderOrder, z: l2, group: c2 }, e2[n2] = h2) : (h2.id = i3.id, h2.object = i3, h2.geometry = r3, h2.material = s3, h2.program = u2.program || a2, h2.groupOrder = o4, h2.renderOrder = i3.renderOrder, h2.z = l2, h2.group = c2), n2++, h2;
        }
        return { opaque: i2, transmissive: r2, transparent: s2, init: function() {
          n2 = 0, i2.length = 0, r2.length = 0, s2.length = 0;
        }, push: function(t3, e3, n3, a3, l2, c2) {
          const h2 = o3(t3, e3, n3, a3, l2, c2);
          n3.transmission > 0 ? r2.push(h2) : true === n3.transparent ? s2.push(h2) : i2.push(h2);
        }, unshift: function(t3, e3, n3, a3, l2, c2) {
          const h2 = o3(t3, e3, n3, a3, l2, c2);
          n3.transmission > 0 ? r2.unshift(h2) : true === n3.transparent ? s2.unshift(h2) : i2.unshift(h2);
        }, finish: function() {
          for (let t3 = n2, i3 = e2.length; t3 < i3; t3++) {
            const n3 = e2[t3];
            if (null === n3.id)
              break;
            n3.id = null, n3.object = null, n3.geometry = null, n3.material = null, n3.program = null, n3.group = null;
          }
        }, sort: function(t3, e3) {
          i2.length > 1 && i2.sort(t3 || Ts), r2.length > 1 && r2.sort(e3 || Es), s2.length > 1 && s2.sort(e3 || Es);
        } };
      }
      function Ls(t2) {
        let e2 = /* @__PURE__ */ new WeakMap();
        return { get: function(n2, i2) {
          let r2;
          return false === e2.has(n2) ? (r2 = new As(t2), e2.set(n2, [r2])) : i2 >= e2.get(n2).length ? (r2 = new As(t2), e2.get(n2).push(r2)) : r2 = e2.get(n2)[i2], r2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function Rs() {
        const t2 = {};
        return { get: function(e2) {
          if (void 0 !== t2[e2.id])
            return t2[e2.id];
          let n2;
          switch (e2.type) {
            case "DirectionalLight":
              n2 = { direction: new Rt(), color: new Qe() };
              break;
            case "SpotLight":
              n2 = { position: new Rt(), direction: new Rt(), color: new Qe(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
              break;
            case "PointLight":
              n2 = { position: new Rt(), color: new Qe(), distance: 0, decay: 0 };
              break;
            case "HemisphereLight":
              n2 = { direction: new Rt(), skyColor: new Qe(), groundColor: new Qe() };
              break;
            case "RectAreaLight":
              n2 = { color: new Qe(), position: new Rt(), halfWidth: new Rt(), halfHeight: new Rt() };
          }
          return t2[e2.id] = n2, n2;
        } };
      }
      let Cs = 0;
      function Ps(t2, e2) {
        return (e2.castShadow ? 1 : 0) - (t2.castShadow ? 1 : 0);
      }
      function Is(t2, e2) {
        const n2 = new Rs(), i2 = function() {
          const t3 = {};
          return { get: function(e3) {
            if (void 0 !== t3[e3.id])
              return t3[e3.id];
            let n3;
            switch (e3.type) {
              case "DirectionalLight":
              case "SpotLight":
                n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new vt() };
                break;
              case "PointLight":
                n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new vt(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
            }
            return t3[e3.id] = n3, n3;
          } };
        }(), r2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
        for (let t3 = 0; t3 < 9; t3++)
          r2.probe.push(new Rt());
        const s2 = new Rt(), a2 = new ae(), o3 = new ae();
        return { setup: function(s3, a3) {
          let o4 = 0, l2 = 0, c2 = 0;
          for (let t3 = 0; t3 < 9; t3++)
            r2.probe[t3].set(0, 0, 0);
          let h2 = 0, u2 = 0, d2 = 0, p2 = 0, m2 = 0, f2 = 0, g2 = 0, v2 = 0;
          s3.sort(Ps);
          const y2 = true !== a3 ? Math.PI : 1;
          for (let t3 = 0, e3 = s3.length; t3 < e3; t3++) {
            const e4 = s3[t3], a4 = e4.color, x3 = e4.intensity, _2 = e4.distance, b2 = e4.shadow && e4.shadow.map ? e4.shadow.map.texture : null;
            if (e4.isAmbientLight)
              o4 += a4.r * x3 * y2, l2 += a4.g * x3 * y2, c2 += a4.b * x3 * y2;
            else if (e4.isLightProbe)
              for (let t4 = 0; t4 < 9; t4++)
                r2.probe[t4].addScaledVector(e4.sh.coefficients[t4], x3);
            else if (e4.isDirectionalLight) {
              const t4 = n2.get(e4);
              if (t4.color.copy(e4.color).multiplyScalar(e4.intensity * y2), e4.castShadow) {
                const t5 = e4.shadow, n3 = i2.get(e4);
                n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, r2.directionalShadow[h2] = n3, r2.directionalShadowMap[h2] = b2, r2.directionalShadowMatrix[h2] = e4.shadow.matrix, f2++;
              }
              r2.directional[h2] = t4, h2++;
            } else if (e4.isSpotLight) {
              const t4 = n2.get(e4);
              if (t4.position.setFromMatrixPosition(e4.matrixWorld), t4.color.copy(a4).multiplyScalar(x3 * y2), t4.distance = _2, t4.coneCos = Math.cos(e4.angle), t4.penumbraCos = Math.cos(e4.angle * (1 - e4.penumbra)), t4.decay = e4.decay, e4.castShadow) {
                const t5 = e4.shadow, n3 = i2.get(e4);
                n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, r2.spotShadow[d2] = n3, r2.spotShadowMap[d2] = b2, r2.spotShadowMatrix[d2] = e4.shadow.matrix, v2++;
              }
              r2.spot[d2] = t4, d2++;
            } else if (e4.isRectAreaLight) {
              const t4 = n2.get(e4);
              t4.color.copy(a4).multiplyScalar(x3), t4.halfWidth.set(0.5 * e4.width, 0, 0), t4.halfHeight.set(0, 0.5 * e4.height, 0), r2.rectArea[p2] = t4, p2++;
            } else if (e4.isPointLight) {
              const t4 = n2.get(e4);
              if (t4.color.copy(e4.color).multiplyScalar(e4.intensity * y2), t4.distance = e4.distance, t4.decay = e4.decay, e4.castShadow) {
                const t5 = e4.shadow, n3 = i2.get(e4);
                n3.shadowBias = t5.bias, n3.shadowNormalBias = t5.normalBias, n3.shadowRadius = t5.radius, n3.shadowMapSize = t5.mapSize, n3.shadowCameraNear = t5.camera.near, n3.shadowCameraFar = t5.camera.far, r2.pointShadow[u2] = n3, r2.pointShadowMap[u2] = b2, r2.pointShadowMatrix[u2] = e4.shadow.matrix, g2++;
              }
              r2.point[u2] = t4, u2++;
            } else if (e4.isHemisphereLight) {
              const t4 = n2.get(e4);
              t4.skyColor.copy(e4.color).multiplyScalar(x3 * y2), t4.groundColor.copy(e4.groundColor).multiplyScalar(x3 * y2), r2.hemi[m2] = t4, m2++;
            }
          }
          p2 > 0 && (e2.isWebGL2 || true === t2.has("OES_texture_float_linear") ? (r2.rectAreaLTC1 = ui.LTC_FLOAT_1, r2.rectAreaLTC2 = ui.LTC_FLOAT_2) : true === t2.has("OES_texture_half_float_linear") ? (r2.rectAreaLTC1 = ui.LTC_HALF_1, r2.rectAreaLTC2 = ui.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r2.ambient[0] = o4, r2.ambient[1] = l2, r2.ambient[2] = c2;
          const x2 = r2.hash;
          x2.directionalLength === h2 && x2.pointLength === u2 && x2.spotLength === d2 && x2.rectAreaLength === p2 && x2.hemiLength === m2 && x2.numDirectionalShadows === f2 && x2.numPointShadows === g2 && x2.numSpotShadows === v2 || (r2.directional.length = h2, r2.spot.length = d2, r2.rectArea.length = p2, r2.point.length = u2, r2.hemi.length = m2, r2.directionalShadow.length = f2, r2.directionalShadowMap.length = f2, r2.pointShadow.length = g2, r2.pointShadowMap.length = g2, r2.spotShadow.length = v2, r2.spotShadowMap.length = v2, r2.directionalShadowMatrix.length = f2, r2.pointShadowMatrix.length = g2, r2.spotShadowMatrix.length = v2, x2.directionalLength = h2, x2.pointLength = u2, x2.spotLength = d2, x2.rectAreaLength = p2, x2.hemiLength = m2, x2.numDirectionalShadows = f2, x2.numPointShadows = g2, x2.numSpotShadows = v2, r2.version = Cs++);
        }, setupView: function(t3, e3) {
          let n3 = 0, i3 = 0, l2 = 0, c2 = 0, h2 = 0;
          const u2 = e3.matrixWorldInverse;
          for (let e4 = 0, d2 = t3.length; e4 < d2; e4++) {
            const d3 = t3[e4];
            if (d3.isDirectionalLight) {
              const t4 = r2.directional[n3];
              t4.direction.setFromMatrixPosition(d3.matrixWorld), s2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(s2), t4.direction.transformDirection(u2), n3++;
            } else if (d3.isSpotLight) {
              const t4 = r2.spot[l2];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(u2), t4.direction.setFromMatrixPosition(d3.matrixWorld), s2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(s2), t4.direction.transformDirection(u2), l2++;
            } else if (d3.isRectAreaLight) {
              const t4 = r2.rectArea[c2];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(u2), o3.identity(), a2.copy(d3.matrixWorld), a2.premultiply(u2), o3.extractRotation(a2), t4.halfWidth.set(0.5 * d3.width, 0, 0), t4.halfHeight.set(0, 0.5 * d3.height, 0), t4.halfWidth.applyMatrix4(o3), t4.halfHeight.applyMatrix4(o3), c2++;
            } else if (d3.isPointLight) {
              const t4 = r2.point[i3];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(u2), i3++;
            } else if (d3.isHemisphereLight) {
              const t4 = r2.hemi[h2];
              t4.direction.setFromMatrixPosition(d3.matrixWorld), t4.direction.transformDirection(u2), t4.direction.normalize(), h2++;
            }
          }
        }, state: r2 };
      }
      function Ds(t2, e2) {
        const n2 = new Is(t2, e2), i2 = [], r2 = [];
        return { init: function() {
          i2.length = 0, r2.length = 0;
        }, state: { lightsArray: i2, shadowsArray: r2, lights: n2 }, setupLights: function(t3) {
          n2.setup(i2, t3);
        }, setupLightsView: function(t3) {
          n2.setupView(i2, t3);
        }, pushLight: function(t3) {
          i2.push(t3);
        }, pushShadow: function(t3) {
          r2.push(t3);
        } };
      }
      function Ns(t2, e2) {
        let n2 = /* @__PURE__ */ new WeakMap();
        return { get: function(i2, r2 = 0) {
          let s2;
          return false === n2.has(i2) ? (s2 = new Ds(t2, e2), n2.set(i2, [s2])) : r2 >= n2.get(i2).length ? (s2 = new Ds(t2, e2), n2.get(i2).push(s2)) : s2 = n2.get(i2)[r2], s2;
        }, dispose: function() {
          n2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      class zs extends We {
        constructor(t2) {
          super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.depthPacking = t2.depthPacking, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this;
        }
      }
      zs.prototype.isMeshDepthMaterial = true;
      class Bs extends We {
        constructor(t2) {
          super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Rt(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.referencePosition.copy(t2.referencePosition), this.nearDistance = t2.nearDistance, this.farDistance = t2.farDistance, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this;
        }
      }
      Bs.prototype.isMeshDistanceMaterial = true;
      function Fs(t2, e2, n2) {
        let i2 = new ai();
        const r2 = new vt(), s2 = new vt(), a2 = new St(), o3 = new zs({ depthPacking: 3201 }), l2 = new Bs(), c2 = {}, h2 = n2.maxTextureSize, u2 = { 0: 1, 1: 0, 2: 2 }, d2 = new Xn({ uniforms: { shadow_pass: { value: null }, resolution: { value: new vt() }, radius: { value: 4 }, samples: { value: 8 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), m2 = d2.clone();
        m2.defines.HORIZONTAL_PASS = 1;
        const f2 = new wn();
        f2.setAttribute("position", new en(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const v2 = new Gn(f2, d2), y2 = this;
        function x2(n3, i3) {
          const r3 = e2.update(v2);
          d2.uniforms.shadow_pass.value = n3.map.texture, d2.uniforms.resolution.value = n3.mapSize, d2.uniforms.radius.value = n3.radius, d2.uniforms.samples.value = n3.blurSamples, t2.setRenderTarget(n3.mapPass), t2.clear(), t2.renderBufferDirect(i3, null, r3, d2, v2, null), m2.uniforms.shadow_pass.value = n3.mapPass.texture, m2.uniforms.resolution.value = n3.mapSize, m2.uniforms.radius.value = n3.radius, m2.uniforms.samples.value = n3.blurSamples, t2.setRenderTarget(n3.map), t2.clear(), t2.renderBufferDirect(i3, null, r3, m2, v2, null);
        }
        function _2(e3, n3, i3, r3, s3, a3, h3) {
          let d3 = null;
          const p2 = true === r3.isPointLight ? e3.customDistanceMaterial : e3.customDepthMaterial;
          if (d3 = void 0 !== p2 ? p2 : true === r3.isPointLight ? l2 : o3, t2.localClippingEnabled && true === i3.clipShadows && 0 !== i3.clippingPlanes.length || i3.displacementMap && 0 !== i3.displacementScale || i3.alphaMap && i3.alphaTest > 0) {
            const t3 = d3.uuid, e4 = i3.uuid;
            let n4 = c2[t3];
            void 0 === n4 && (n4 = {}, c2[t3] = n4);
            let r4 = n4[e4];
            void 0 === r4 && (r4 = d3.clone(), n4[e4] = r4), d3 = r4;
          }
          return d3.visible = i3.visible, d3.wireframe = i3.wireframe, d3.side = 3 === h3 ? null !== i3.shadowSide ? i3.shadowSide : i3.side : null !== i3.shadowSide ? i3.shadowSide : u2[i3.side], d3.alphaMap = i3.alphaMap, d3.alphaTest = i3.alphaTest, d3.clipShadows = i3.clipShadows, d3.clippingPlanes = i3.clippingPlanes, d3.clipIntersection = i3.clipIntersection, d3.displacementMap = i3.displacementMap, d3.displacementScale = i3.displacementScale, d3.displacementBias = i3.displacementBias, d3.wireframeLinewidth = i3.wireframeLinewidth, d3.linewidth = i3.linewidth, true === r3.isPointLight && true === d3.isMeshDistanceMaterial && (d3.referencePosition.setFromMatrixPosition(r3.matrixWorld), d3.nearDistance = s3, d3.farDistance = a3), d3;
        }
        function b2(n3, r3, s3, a3, o4) {
          if (false === n3.visible)
            return;
          if (n3.layers.test(r3.layers) && (n3.isMesh || n3.isLine || n3.isPoints) && (n3.castShadow || n3.receiveShadow && 3 === o4) && (!n3.frustumCulled || i2.intersectsObject(n3))) {
            n3.modelViewMatrix.multiplyMatrices(s3.matrixWorldInverse, n3.matrixWorld);
            const i3 = e2.update(n3), r4 = n3.material;
            if (Array.isArray(r4)) {
              const e3 = i3.groups;
              for (let l4 = 0, c3 = e3.length; l4 < c3; l4++) {
                const c4 = e3[l4], h3 = r4[c4.materialIndex];
                if (h3 && h3.visible) {
                  const e4 = _2(n3, 0, h3, a3, s3.near, s3.far, o4);
                  t2.renderBufferDirect(s3, null, i3, e4, n3, c4);
                }
              }
            } else if (r4.visible) {
              const e3 = _2(n3, 0, r4, a3, s3.near, s3.far, o4);
              t2.renderBufferDirect(s3, null, i3, e3, n3, null);
            }
          }
          const l3 = n3.children;
          for (let t3 = 0, e3 = l3.length; t3 < e3; t3++)
            b2(l3[t3], r3, s3, a3, o4);
        }
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(e3, n3, o4) {
          if (false === y2.enabled)
            return;
          if (false === y2.autoUpdate && false === y2.needsUpdate)
            return;
          if (0 === e3.length)
            return;
          const l3 = t2.getRenderTarget(), c3 = t2.getActiveCubeFace(), u3 = t2.getActiveMipmapLevel(), d3 = t2.state;
          d3.setBlending(0), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
          for (let l4 = 0, c4 = e3.length; l4 < c4; l4++) {
            const c5 = e3[l4], u4 = c5.shadow;
            if (void 0 === u4) {
              console.warn("THREE.WebGLShadowMap:", c5, "has no shadow.");
              continue;
            }
            if (false === u4.autoUpdate && false === u4.needsUpdate)
              continue;
            r2.copy(u4.mapSize);
            const m3 = u4.getFrameExtents();
            if (r2.multiply(m3), s2.copy(u4.mapSize), (r2.x > h2 || r2.y > h2) && (r2.x > h2 && (s2.x = Math.floor(h2 / m3.x), r2.x = s2.x * m3.x, u4.mapSize.x = s2.x), r2.y > h2 && (s2.y = Math.floor(h2 / m3.y), r2.y = s2.y * m3.y, u4.mapSize.y = s2.y)), null === u4.map && !u4.isPointLightShadow && 3 === this.type) {
              const t3 = { minFilter: g, magFilter: g, format: E };
              u4.map = new Tt(r2.x, r2.y, t3), u4.map.texture.name = c5.name + ".shadowMap", u4.mapPass = new Tt(r2.x, r2.y, t3), u4.camera.updateProjectionMatrix();
            }
            if (null === u4.map) {
              const t3 = { minFilter: p, magFilter: p, format: E };
              u4.map = new Tt(r2.x, r2.y, t3), u4.map.texture.name = c5.name + ".shadowMap", u4.camera.updateProjectionMatrix();
            }
            t2.setRenderTarget(u4.map), t2.clear();
            const f3 = u4.getViewportCount();
            for (let t3 = 0; t3 < f3; t3++) {
              const e4 = u4.getViewport(t3);
              a2.set(s2.x * e4.x, s2.y * e4.y, s2.x * e4.z, s2.y * e4.w), d3.viewport(a2), u4.updateMatrices(c5, t3), i2 = u4.getFrustum(), b2(n3, o4, u4.camera, c5, this.type);
            }
            u4.isPointLightShadow || 3 !== this.type || x2(u4, o4), u4.needsUpdate = false;
          }
          y2.needsUpdate = false, t2.setRenderTarget(l3, c3, u3);
        };
      }
      function Os(t2, e2, i2) {
        const r2 = i2.isWebGL2;
        const s2 = new function() {
          let e3 = false;
          const n2 = new St();
          let i3 = null;
          const r3 = new St(0, 0, 0, 0);
          return { setMask: function(n3) {
            i3 === n3 || e3 || (t2.colorMask(n3, n3, n3, n3), i3 = n3);
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4, i4, s3, a3, o4) {
            true === o4 && (e4 *= a3, i4 *= a3, s3 *= a3), n2.set(e4, i4, s3, a3), false === r3.equals(n2) && (t2.clearColor(e4, i4, s3, a3), r3.copy(n2));
          }, reset: function() {
            e3 = false, i3 = null, r3.set(-1, 0, 0, 0);
          } };
        }(), a2 = new function() {
          let e3 = false, n2 = null, i3 = null, r3 = null;
          return { setTest: function(t3) {
            t3 ? O2(2929) : U2(2929);
          }, setMask: function(i4) {
            n2 === i4 || e3 || (t2.depthMask(i4), n2 = i4);
          }, setFunc: function(e4) {
            if (i3 !== e4) {
              if (e4)
                switch (e4) {
                  case 0:
                    t2.depthFunc(512);
                    break;
                  case 1:
                    t2.depthFunc(519);
                    break;
                  case 2:
                    t2.depthFunc(513);
                    break;
                  case 3:
                    t2.depthFunc(515);
                    break;
                  case 4:
                    t2.depthFunc(514);
                    break;
                  case 5:
                    t2.depthFunc(518);
                    break;
                  case 6:
                    t2.depthFunc(516);
                    break;
                  case 7:
                    t2.depthFunc(517);
                    break;
                  default:
                    t2.depthFunc(515);
                }
              else
                t2.depthFunc(515);
              i3 = e4;
            }
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4) {
            r3 !== e4 && (t2.clearDepth(e4), r3 = e4);
          }, reset: function() {
            e3 = false, n2 = null, i3 = null, r3 = null;
          } };
        }(), o3 = new function() {
          let e3 = false, n2 = null, i3 = null, r3 = null, s3 = null, a3 = null, o4 = null, l3 = null, c3 = null;
          return { setTest: function(t3) {
            e3 || (t3 ? O2(2960) : U2(2960));
          }, setMask: function(i4) {
            n2 === i4 || e3 || (t2.stencilMask(i4), n2 = i4);
          }, setFunc: function(e4, n3, a4) {
            i3 === e4 && r3 === n3 && s3 === a4 || (t2.stencilFunc(e4, n3, a4), i3 = e4, r3 = n3, s3 = a4);
          }, setOp: function(e4, n3, i4) {
            a3 === e4 && o4 === n3 && l3 === i4 || (t2.stencilOp(e4, n3, i4), a3 = e4, o4 = n3, l3 = i4);
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4) {
            c3 !== e4 && (t2.clearStencil(e4), c3 = e4);
          }, reset: function() {
            e3 = false, n2 = null, i3 = null, r3 = null, s3 = null, a3 = null, o4 = null, l3 = null, c3 = null;
          } };
        }();
        let l2 = {}, c2 = null, h2 = {}, u2 = null, d2 = false, p2 = null, m2 = null, f2 = null, g2 = null, v2 = null, y2 = null, x2 = null, _2 = false, b2 = null, M2 = null, w2 = null, S2 = null, T2 = null;
        const E2 = t2.getParameter(35661);
        let A2 = false, L2 = 0;
        const R2 = t2.getParameter(7938);
        -1 !== R2.indexOf("WebGL") ? (L2 = parseFloat(/^WebGL (\d)/.exec(R2)[1]), A2 = L2 >= 1) : -1 !== R2.indexOf("OpenGL ES") && (L2 = parseFloat(/^OpenGL ES (\d)/.exec(R2)[1]), A2 = L2 >= 2);
        let C2 = null, P2 = {};
        const I2 = t2.getParameter(3088), D2 = t2.getParameter(2978), N2 = new St().fromArray(I2), z2 = new St().fromArray(D2);
        function B2(e3, n2, i3) {
          const r3 = new Uint8Array(4), s3 = t2.createTexture();
          t2.bindTexture(e3, s3), t2.texParameteri(e3, 10241, 9728), t2.texParameteri(e3, 10240, 9728);
          for (let e4 = 0; e4 < i3; e4++)
            t2.texImage2D(n2 + e4, 0, 6408, 1, 1, 0, 6408, 5121, r3);
          return s3;
        }
        const F2 = {};
        function O2(e3) {
          true !== l2[e3] && (t2.enable(e3), l2[e3] = true);
        }
        function U2(e3) {
          false !== l2[e3] && (t2.disable(e3), l2[e3] = false);
        }
        F2[3553] = B2(3553, 3553, 1), F2[34067] = B2(34067, 34069, 6), s2.setClear(0, 0, 0, 1), a2.setClear(1), o3.setClear(0), O2(2929), a2.setFunc(3), V2(false), W2(1), O2(2884), k2(0);
        const H2 = { [n]: 32774, 101: 32778, 102: 32779 };
        if (r2)
          H2[103] = 32775, H2[104] = 32776;
        else {
          const t3 = e2.get("EXT_blend_minmax");
          null !== t3 && (H2[103] = t3.MIN_EXT, H2[104] = t3.MAX_EXT);
        }
        const G2 = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
        function k2(e3, i3, r3, s3, a3, o4, l3, c3) {
          if (0 !== e3) {
            if (false === d2 && (O2(3042), d2 = true), 5 === e3)
              a3 = a3 || i3, o4 = o4 || r3, l3 = l3 || s3, i3 === m2 && a3 === v2 || (t2.blendEquationSeparate(H2[i3], H2[a3]), m2 = i3, v2 = a3), r3 === f2 && s3 === g2 && o4 === y2 && l3 === x2 || (t2.blendFuncSeparate(G2[r3], G2[s3], G2[o4], G2[l3]), f2 = r3, g2 = s3, y2 = o4, x2 = l3), p2 = e3, _2 = null;
            else if (e3 !== p2 || c3 !== _2) {
              if (m2 === n && v2 === n || (t2.blendEquation(32774), m2 = n, v2 = n), c3)
                switch (e3) {
                  case 1:
                    t2.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case 2:
                    t2.blendFunc(1, 1);
                    break;
                  case 3:
                    t2.blendFuncSeparate(0, 0, 769, 771);
                    break;
                  case 4:
                    t2.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e3);
                }
              else
                switch (e3) {
                  case 1:
                    t2.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case 2:
                    t2.blendFunc(770, 1);
                    break;
                  case 3:
                    t2.blendFunc(0, 769);
                    break;
                  case 4:
                    t2.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e3);
                }
              f2 = null, g2 = null, y2 = null, x2 = null, p2 = e3, _2 = c3;
            }
          } else
            true === d2 && (U2(3042), d2 = false);
        }
        function V2(e3) {
          b2 !== e3 && (e3 ? t2.frontFace(2304) : t2.frontFace(2305), b2 = e3);
        }
        function W2(e3) {
          0 !== e3 ? (O2(2884), e3 !== M2 && (1 === e3 ? t2.cullFace(1029) : 2 === e3 ? t2.cullFace(1028) : t2.cullFace(1032))) : U2(2884), M2 = e3;
        }
        function j2(e3, n2, i3) {
          e3 ? (O2(32823), S2 === n2 && T2 === i3 || (t2.polygonOffset(n2, i3), S2 = n2, T2 = i3)) : U2(32823);
        }
        function q2(e3) {
          void 0 === e3 && (e3 = 33984 + E2 - 1), C2 !== e3 && (t2.activeTexture(e3), C2 = e3);
        }
        return { buffers: { color: s2, depth: a2, stencil: o3 }, enable: O2, disable: U2, bindFramebuffer: function(e3, n2) {
          return null === n2 && null !== c2 && (n2 = c2), h2[e3] !== n2 && (t2.bindFramebuffer(e3, n2), h2[e3] = n2, r2 && (36009 === e3 && (h2[36160] = n2), 36160 === e3 && (h2[36009] = n2)), true);
        }, bindXRFramebuffer: function(e3) {
          e3 !== c2 && (t2.bindFramebuffer(36160, e3), c2 = e3);
        }, useProgram: function(e3) {
          return u2 !== e3 && (t2.useProgram(e3), u2 = e3, true);
        }, setBlending: k2, setMaterial: function(t3, e3) {
          2 === t3.side ? U2(2884) : O2(2884);
          let n2 = 1 === t3.side;
          e3 && (n2 = !n2), V2(n2), 1 === t3.blending && false === t3.transparent ? k2(0) : k2(t3.blending, t3.blendEquation, t3.blendSrc, t3.blendDst, t3.blendEquationAlpha, t3.blendSrcAlpha, t3.blendDstAlpha, t3.premultipliedAlpha), a2.setFunc(t3.depthFunc), a2.setTest(t3.depthTest), a2.setMask(t3.depthWrite), s2.setMask(t3.colorWrite);
          const i3 = t3.stencilWrite;
          o3.setTest(i3), i3 && (o3.setMask(t3.stencilWriteMask), o3.setFunc(t3.stencilFunc, t3.stencilRef, t3.stencilFuncMask), o3.setOp(t3.stencilFail, t3.stencilZFail, t3.stencilZPass)), j2(t3.polygonOffset, t3.polygonOffsetFactor, t3.polygonOffsetUnits), true === t3.alphaToCoverage ? O2(32926) : U2(32926);
        }, setFlipSided: V2, setCullFace: W2, setLineWidth: function(e3) {
          e3 !== w2 && (A2 && t2.lineWidth(e3), w2 = e3);
        }, setPolygonOffset: j2, setScissorTest: function(t3) {
          t3 ? O2(3089) : U2(3089);
        }, activeTexture: q2, bindTexture: function(e3, n2) {
          null === C2 && q2();
          let i3 = P2[C2];
          void 0 === i3 && (i3 = { type: void 0, texture: void 0 }, P2[C2] = i3), i3.type === e3 && i3.texture === n2 || (t2.bindTexture(e3, n2 || F2[e3]), i3.type = e3, i3.texture = n2);
        }, unbindTexture: function() {
          const e3 = P2[C2];
          void 0 !== e3 && void 0 !== e3.type && (t2.bindTexture(e3.type, null), e3.type = void 0, e3.texture = void 0);
        }, compressedTexImage2D: function() {
          try {
            t2.compressedTexImage2D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texImage2D: function() {
          try {
            t2.texImage2D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texImage3D: function() {
          try {
            t2.texImage3D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, scissor: function(e3) {
          false === N2.equals(e3) && (t2.scissor(e3.x, e3.y, e3.z, e3.w), N2.copy(e3));
        }, viewport: function(e3) {
          false === z2.equals(e3) && (t2.viewport(e3.x, e3.y, e3.z, e3.w), z2.copy(e3));
        }, reset: function() {
          t2.disable(3042), t2.disable(2884), t2.disable(2929), t2.disable(32823), t2.disable(3089), t2.disable(2960), t2.disable(32926), t2.blendEquation(32774), t2.blendFunc(1, 0), t2.blendFuncSeparate(1, 0, 1, 0), t2.colorMask(true, true, true, true), t2.clearColor(0, 0, 0, 0), t2.depthMask(true), t2.depthFunc(513), t2.clearDepth(1), t2.stencilMask(4294967295), t2.stencilFunc(519, 0, 4294967295), t2.stencilOp(7680, 7680, 7680), t2.clearStencil(0), t2.cullFace(1029), t2.frontFace(2305), t2.polygonOffset(0, 0), t2.activeTexture(33984), t2.bindFramebuffer(36160, null), true === r2 && (t2.bindFramebuffer(36009, null), t2.bindFramebuffer(36008, null)), t2.useProgram(null), t2.lineWidth(1), t2.scissor(0, 0, t2.canvas.width, t2.canvas.height), t2.viewport(0, 0, t2.canvas.width, t2.canvas.height), l2 = {}, C2 = null, P2 = {}, c2 = null, h2 = {}, u2 = null, d2 = false, p2 = null, m2 = null, f2 = null, g2 = null, v2 = null, y2 = null, x2 = null, _2 = false, b2 = null, M2 = null, w2 = null, S2 = null, T2 = null, N2.set(0, 0, t2.canvas.width, t2.canvas.height), z2.set(0, 0, t2.canvas.width, t2.canvas.height), s2.reset(), a2.reset(), o3.reset();
        } };
      }
      function Us(t2, e2, n2, i2, r2, s2, a2) {
        const o3 = r2.isWebGL2, l2 = r2.maxTextures, c2 = r2.maxCubemapSize, x2 = r2.maxTextureSize, R2 = r2.maxSamples, C2 = /* @__PURE__ */ new WeakMap();
        let P2, I2 = false;
        try {
          I2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (t3) {
        }
        function D2(t3, e3) {
          return I2 ? new OffscreenCanvas(t3, e3) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        }
        function N2(t3, e3, n3, i3) {
          let r3 = 1;
          if ((t3.width > i3 || t3.height > i3) && (r3 = i3 / Math.max(t3.width, t3.height)), r3 < 1 || true === e3) {
            if ("undefined" != typeof HTMLImageElement && t3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap) {
              const i4 = e3 ? ft : Math.floor, s3 = i4(r3 * t3.width), a3 = i4(r3 * t3.height);
              void 0 === P2 && (P2 = D2(s3, a3));
              const o4 = n3 ? D2(s3, a3) : P2;
              o4.width = s3, o4.height = a3;
              return o4.getContext("2d").drawImage(t3, 0, 0, s3, a3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t3.width + "x" + t3.height + ") to (" + s3 + "x" + a3 + ")."), o4;
            }
            return "data" in t3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t3.width + "x" + t3.height + ")."), t3;
          }
          return t3;
        }
        function z2(t3) {
          return pt(t3.width) && pt(t3.height);
        }
        function B2(t3, e3) {
          return t3.generateMipmaps && e3 && t3.minFilter !== p && t3.minFilter !== g;
        }
        function F2(e3, n3, r3, s3, a3 = 1) {
          t2.generateMipmap(e3);
          i2.get(n3).__maxMipLevel = Math.log2(Math.max(r3, s3, a3));
        }
        function O2(n3, i3, r3) {
          if (false === o3)
            return i3;
          if (null !== n3) {
            if (void 0 !== t2[n3])
              return t2[n3];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n3 + "'");
          }
          let s3 = i3;
          return 6403 === i3 && (5126 === r3 && (s3 = 33326), 5131 === r3 && (s3 = 33325), 5121 === r3 && (s3 = 33321)), 6407 === i3 && (5126 === r3 && (s3 = 34837), 5131 === r3 && (s3 = 34843), 5121 === r3 && (s3 = 32849)), 6408 === i3 && (5126 === r3 && (s3 = 34836), 5131 === r3 && (s3 = 34842), 5121 === r3 && (s3 = 32856)), 33325 !== s3 && 33326 !== s3 && 34842 !== s3 && 34836 !== s3 || e2.get("EXT_color_buffer_float"), s3;
        }
        function U2(t3) {
          return t3 === p || t3 === m || t3 === f ? 9728 : 9729;
        }
        function H2(e3) {
          const n3 = e3.target;
          n3.removeEventListener("dispose", H2), function(e4) {
            const n4 = i2.get(e4);
            if (void 0 === n4.__webglInit)
              return;
            t2.deleteTexture(n4.__webglTexture), i2.remove(e4);
          }(n3), n3.isVideoTexture && C2.delete(n3), a2.memory.textures--;
        }
        function G2(e3) {
          const n3 = e3.target;
          n3.removeEventListener("dispose", G2), function(e4) {
            const n4 = e4.texture, r3 = i2.get(e4), s3 = i2.get(n4);
            if (!e4)
              return;
            void 0 !== s3.__webglTexture && (t2.deleteTexture(s3.__webglTexture), a2.memory.textures--);
            e4.depthTexture && e4.depthTexture.dispose();
            if (e4.isWebGLCubeRenderTarget)
              for (let e5 = 0; e5 < 6; e5++)
                t2.deleteFramebuffer(r3.__webglFramebuffer[e5]), r3.__webglDepthbuffer && t2.deleteRenderbuffer(r3.__webglDepthbuffer[e5]);
            else
              t2.deleteFramebuffer(r3.__webglFramebuffer), r3.__webglDepthbuffer && t2.deleteRenderbuffer(r3.__webglDepthbuffer), r3.__webglMultisampledFramebuffer && t2.deleteFramebuffer(r3.__webglMultisampledFramebuffer), r3.__webglColorRenderbuffer && t2.deleteRenderbuffer(r3.__webglColorRenderbuffer), r3.__webglDepthRenderbuffer && t2.deleteRenderbuffer(r3.__webglDepthRenderbuffer);
            if (e4.isWebGLMultipleRenderTargets)
              for (let e5 = 0, r4 = n4.length; e5 < r4; e5++) {
                const r5 = i2.get(n4[e5]);
                r5.__webglTexture && (t2.deleteTexture(r5.__webglTexture), a2.memory.textures--), i2.remove(n4[e5]);
              }
            i2.remove(n4), i2.remove(e4);
          }(n3);
        }
        let k2 = 0;
        function V2(t3, e3) {
          const r3 = i2.get(t3);
          if (t3.isVideoTexture && function(t4) {
            const e4 = a2.render.frame;
            C2.get(t4) !== e4 && (C2.set(t4, e4), t4.update());
          }(t3), t3.version > 0 && r3.__version !== t3.version) {
            const n3 = t3.image;
            if (void 0 === n3)
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            else {
              if (false !== n3.complete)
                return void J2(r3, t3, e3);
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
          }
          n2.activeTexture(33984 + e3), n2.bindTexture(3553, r3.__webglTexture);
        }
        function W2(e3, r3) {
          const a3 = i2.get(e3);
          e3.version > 0 && a3.__version !== e3.version ? function(e4, i3, r4) {
            if (6 !== i3.image.length)
              return;
            Y2(e4, i3), n2.activeTexture(33984 + r4), n2.bindTexture(34067, e4.__webglTexture), t2.pixelStorei(37440, i3.flipY), t2.pixelStorei(37441, i3.premultiplyAlpha), t2.pixelStorei(3317, i3.unpackAlignment), t2.pixelStorei(37443, 0);
            const a4 = i3 && (i3.isCompressedTexture || i3.image[0].isCompressedTexture), l3 = i3.image[0] && i3.image[0].isDataTexture, h2 = [];
            for (let t3 = 0; t3 < 6; t3++)
              h2[t3] = a4 || l3 ? l3 ? i3.image[t3].image : i3.image[t3] : N2(i3.image[t3], false, true, c2);
            const u2 = h2[0], d2 = z2(u2) || o3, p2 = s2.convert(i3.format), m2 = s2.convert(i3.type), f2 = O2(i3.internalFormat, p2, m2);
            let g2;
            if (X2(34067, i3, d2), a4) {
              for (let t3 = 0; t3 < 6; t3++) {
                g2 = h2[t3].mipmaps;
                for (let e5 = 0; e5 < g2.length; e5++) {
                  const r5 = g2[e5];
                  i3.format !== E && i3.format !== T ? null !== p2 ? n2.compressedTexImage2D(34069 + t3, e5, f2, r5.width, r5.height, 0, r5.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n2.texImage2D(34069 + t3, e5, f2, r5.width, r5.height, 0, p2, m2, r5.data);
                }
              }
              e4.__maxMipLevel = g2.length - 1;
            } else {
              g2 = i3.mipmaps;
              for (let t3 = 0; t3 < 6; t3++)
                if (l3) {
                  n2.texImage2D(34069 + t3, 0, f2, h2[t3].width, h2[t3].height, 0, p2, m2, h2[t3].data);
                  for (let e5 = 0; e5 < g2.length; e5++) {
                    const i4 = g2[e5].image[t3].image;
                    n2.texImage2D(34069 + t3, e5 + 1, f2, i4.width, i4.height, 0, p2, m2, i4.data);
                  }
                } else {
                  n2.texImage2D(34069 + t3, 0, f2, p2, m2, h2[t3]);
                  for (let e5 = 0; e5 < g2.length; e5++) {
                    const i4 = g2[e5];
                    n2.texImage2D(34069 + t3, e5 + 1, f2, p2, m2, i4.image[t3]);
                  }
                }
              e4.__maxMipLevel = g2.length;
            }
            B2(i3, d2) && F2(34067, i3, u2.width, u2.height);
            e4.__version = i3.version, i3.onUpdate && i3.onUpdate(i3);
          }(a3, e3, r3) : (n2.activeTexture(33984 + r3), n2.bindTexture(34067, a3.__webglTexture));
        }
        const j2 = { [h]: 10497, [u]: 33071, [d]: 33648 }, q2 = { [p]: 9728, [m]: 9984, [f]: 9986, [g]: 9729, [v]: 9985, [y]: 9987 };
        function X2(n3, s3, a3) {
          if (a3 ? (t2.texParameteri(n3, 10242, j2[s3.wrapS]), t2.texParameteri(n3, 10243, j2[s3.wrapT]), 32879 !== n3 && 35866 !== n3 || t2.texParameteri(n3, 32882, j2[s3.wrapR]), t2.texParameteri(n3, 10240, q2[s3.magFilter]), t2.texParameteri(n3, 10241, q2[s3.minFilter])) : (t2.texParameteri(n3, 10242, 33071), t2.texParameteri(n3, 10243, 33071), 32879 !== n3 && 35866 !== n3 || t2.texParameteri(n3, 32882, 33071), s3.wrapS === u && s3.wrapT === u || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t2.texParameteri(n3, 10240, U2(s3.magFilter)), t2.texParameteri(n3, 10241, U2(s3.minFilter)), s3.minFilter !== p && s3.minFilter !== g && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === e2.has("EXT_texture_filter_anisotropic")) {
            const a4 = e2.get("EXT_texture_filter_anisotropic");
            if (s3.type === M && false === e2.has("OES_texture_float_linear"))
              return;
            if (false === o3 && s3.type === w && false === e2.has("OES_texture_half_float_linear"))
              return;
            (s3.anisotropy > 1 || i2.get(s3).__currentAnisotropy) && (t2.texParameterf(n3, a4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s3.anisotropy, r2.getMaxAnisotropy())), i2.get(s3).__currentAnisotropy = s3.anisotropy);
          }
        }
        function Y2(e3, n3) {
          void 0 === e3.__webglInit && (e3.__webglInit = true, n3.addEventListener("dispose", H2), e3.__webglTexture = t2.createTexture(), a2.memory.textures++);
        }
        function J2(e3, i3, r3) {
          let a3 = 3553;
          i3.isDataTexture2DArray && (a3 = 35866), i3.isDataTexture3D && (a3 = 32879), Y2(e3, i3), n2.activeTexture(33984 + r3), n2.bindTexture(a3, e3.__webglTexture), t2.pixelStorei(37440, i3.flipY), t2.pixelStorei(37441, i3.premultiplyAlpha), t2.pixelStorei(3317, i3.unpackAlignment), t2.pixelStorei(37443, 0);
          const l3 = function(t3) {
            return !o3 && (t3.wrapS !== u || t3.wrapT !== u || t3.minFilter !== p && t3.minFilter !== g);
          }(i3) && false === z2(i3.image), c3 = N2(i3.image, l3, false, x2), h2 = z2(c3) || o3, d2 = s2.convert(i3.format);
          let m2, f2 = s2.convert(i3.type), v2 = O2(i3.internalFormat, d2, f2);
          X2(a3, i3, h2);
          const y2 = i3.mipmaps;
          if (i3.isDepthTexture)
            v2 = 6402, o3 ? v2 = i3.type === M ? 36012 : i3.type === b ? 33190 : i3.type === S ? 35056 : 33189 : i3.type === M && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i3.format === A && 6402 === v2 && i3.type !== _ && i3.type !== b && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i3.type = _, f2 = s2.convert(i3.type)), i3.format === L && 6402 === v2 && (v2 = 34041, i3.type !== S && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i3.type = S, f2 = s2.convert(i3.type))), n2.texImage2D(3553, 0, v2, c3.width, c3.height, 0, d2, f2, null);
          else if (i3.isDataTexture)
            if (y2.length > 0 && h2) {
              for (let t3 = 0, e4 = y2.length; t3 < e4; t3++)
                m2 = y2[t3], n2.texImage2D(3553, t3, v2, m2.width, m2.height, 0, d2, f2, m2.data);
              i3.generateMipmaps = false, e3.__maxMipLevel = y2.length - 1;
            } else
              n2.texImage2D(3553, 0, v2, c3.width, c3.height, 0, d2, f2, c3.data), e3.__maxMipLevel = 0;
          else if (i3.isCompressedTexture) {
            for (let t3 = 0, e4 = y2.length; t3 < e4; t3++)
              m2 = y2[t3], i3.format !== E && i3.format !== T ? null !== d2 ? n2.compressedTexImage2D(3553, t3, v2, m2.width, m2.height, 0, m2.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n2.texImage2D(3553, t3, v2, m2.width, m2.height, 0, d2, f2, m2.data);
            e3.__maxMipLevel = y2.length - 1;
          } else if (i3.isDataTexture2DArray)
            n2.texImage3D(35866, 0, v2, c3.width, c3.height, c3.depth, 0, d2, f2, c3.data), e3.__maxMipLevel = 0;
          else if (i3.isDataTexture3D)
            n2.texImage3D(32879, 0, v2, c3.width, c3.height, c3.depth, 0, d2, f2, c3.data), e3.__maxMipLevel = 0;
          else if (y2.length > 0 && h2) {
            for (let t3 = 0, e4 = y2.length; t3 < e4; t3++)
              m2 = y2[t3], n2.texImage2D(3553, t3, v2, d2, f2, m2);
            i3.generateMipmaps = false, e3.__maxMipLevel = y2.length - 1;
          } else
            n2.texImage2D(3553, 0, v2, d2, f2, c3), e3.__maxMipLevel = 0;
          B2(i3, h2) && F2(a3, i3, c3.width, c3.height), e3.__version = i3.version, i3.onUpdate && i3.onUpdate(i3);
        }
        function Z2(e3, r3, a3, o4, l3) {
          const c3 = s2.convert(a3.format), h2 = s2.convert(a3.type), u2 = O2(a3.internalFormat, c3, h2);
          32879 === l3 || 35866 === l3 ? n2.texImage3D(l3, 0, u2, r3.width, r3.height, r3.depth, 0, c3, h2, null) : n2.texImage2D(l3, 0, u2, r3.width, r3.height, 0, c3, h2, null), n2.bindFramebuffer(36160, e3), t2.framebufferTexture2D(36160, o4, l3, i2.get(a3).__webglTexture, 0), n2.bindFramebuffer(36160, null);
        }
        function Q2(e3, n3, i3) {
          if (t2.bindRenderbuffer(36161, e3), n3.depthBuffer && !n3.stencilBuffer) {
            let r3 = 33189;
            if (i3) {
              const e4 = n3.depthTexture;
              e4 && e4.isDepthTexture && (e4.type === M ? r3 = 36012 : e4.type === b && (r3 = 33190));
              const i4 = $2(n3);
              t2.renderbufferStorageMultisample(36161, i4, r3, n3.width, n3.height);
            } else
              t2.renderbufferStorage(36161, r3, n3.width, n3.height);
            t2.framebufferRenderbuffer(36160, 36096, 36161, e3);
          } else if (n3.depthBuffer && n3.stencilBuffer) {
            if (i3) {
              const e4 = $2(n3);
              t2.renderbufferStorageMultisample(36161, e4, 35056, n3.width, n3.height);
            } else
              t2.renderbufferStorage(36161, 34041, n3.width, n3.height);
            t2.framebufferRenderbuffer(36160, 33306, 36161, e3);
          } else {
            const e4 = true === n3.isWebGLMultipleRenderTargets ? n3.texture[0] : n3.texture, r3 = s2.convert(e4.format), a3 = s2.convert(e4.type), o4 = O2(e4.internalFormat, r3, a3);
            if (i3) {
              const e5 = $2(n3);
              t2.renderbufferStorageMultisample(36161, e5, o4, n3.width, n3.height);
            } else
              t2.renderbufferStorage(36161, o4, n3.width, n3.height);
          }
          t2.bindRenderbuffer(36161, null);
        }
        function K2(e3) {
          const r3 = i2.get(e3), s3 = true === e3.isWebGLCubeRenderTarget;
          if (e3.depthTexture) {
            if (s3)
              throw new Error("target.depthTexture not supported in Cube render targets");
            !function(e4, r4) {
              if (r4 && r4.isWebGLCubeRenderTarget)
                throw new Error("Depth Texture with cube render targets is not supported");
              if (n2.bindFramebuffer(36160, e4), !r4.depthTexture || !r4.depthTexture.isDepthTexture)
                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              i2.get(r4.depthTexture).__webglTexture && r4.depthTexture.image.width === r4.width && r4.depthTexture.image.height === r4.height || (r4.depthTexture.image.width = r4.width, r4.depthTexture.image.height = r4.height, r4.depthTexture.needsUpdate = true), V2(r4.depthTexture, 0);
              const s4 = i2.get(r4.depthTexture).__webglTexture;
              if (r4.depthTexture.format === A)
                t2.framebufferTexture2D(36160, 36096, 3553, s4, 0);
              else {
                if (r4.depthTexture.format !== L)
                  throw new Error("Unknown depthTexture format");
                t2.framebufferTexture2D(36160, 33306, 3553, s4, 0);
              }
            }(r3.__webglFramebuffer, e3);
          } else if (s3) {
            r3.__webglDepthbuffer = [];
            for (let i3 = 0; i3 < 6; i3++)
              n2.bindFramebuffer(36160, r3.__webglFramebuffer[i3]), r3.__webglDepthbuffer[i3] = t2.createRenderbuffer(), Q2(r3.__webglDepthbuffer[i3], e3, false);
          } else
            n2.bindFramebuffer(36160, r3.__webglFramebuffer), r3.__webglDepthbuffer = t2.createRenderbuffer(), Q2(r3.__webglDepthbuffer, e3, false);
          n2.bindFramebuffer(36160, null);
        }
        function $2(t3) {
          return o3 && t3.isWebGLMultisampleRenderTarget ? Math.min(R2, t3.samples) : 0;
        }
        let tt2 = false, et2 = false;
        this.allocateTextureUnit = function() {
          const t3 = k2;
          return t3 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + t3 + " texture units while this GPU supports only " + l2), k2 += 1, t3;
        }, this.resetTextureUnits = function() {
          k2 = 0;
        }, this.setTexture2D = V2, this.setTexture2DArray = function(t3, e3) {
          const r3 = i2.get(t3);
          t3.version > 0 && r3.__version !== t3.version ? J2(r3, t3, e3) : (n2.activeTexture(33984 + e3), n2.bindTexture(35866, r3.__webglTexture));
        }, this.setTexture3D = function(t3, e3) {
          const r3 = i2.get(t3);
          t3.version > 0 && r3.__version !== t3.version ? J2(r3, t3, e3) : (n2.activeTexture(33984 + e3), n2.bindTexture(32879, r3.__webglTexture));
        }, this.setTextureCube = W2, this.setupRenderTarget = function(e3) {
          const l3 = e3.texture, c3 = i2.get(e3), h2 = i2.get(l3);
          e3.addEventListener("dispose", G2), true !== e3.isWebGLMultipleRenderTargets && (h2.__webglTexture = t2.createTexture(), h2.__version = l3.version, a2.memory.textures++);
          const u2 = true === e3.isWebGLCubeRenderTarget, d2 = true === e3.isWebGLMultipleRenderTargets, p2 = true === e3.isWebGLMultisampleRenderTarget, m2 = l3.isDataTexture3D || l3.isDataTexture2DArray, f2 = z2(e3) || o3;
          if (!o3 || l3.format !== T || l3.type !== M && l3.type !== w || (l3.format = E, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u2) {
            c3.__webglFramebuffer = [];
            for (let e4 = 0; e4 < 6; e4++)
              c3.__webglFramebuffer[e4] = t2.createFramebuffer();
          } else if (c3.__webglFramebuffer = t2.createFramebuffer(), d2)
            if (r2.drawBuffers) {
              const n3 = e3.texture;
              for (let e4 = 0, r3 = n3.length; e4 < r3; e4++) {
                const r4 = i2.get(n3[e4]);
                void 0 === r4.__webglTexture && (r4.__webglTexture = t2.createTexture(), a2.memory.textures++);
              }
            } else
              console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          else if (p2)
            if (o3) {
              c3.__webglMultisampledFramebuffer = t2.createFramebuffer(), c3.__webglColorRenderbuffer = t2.createRenderbuffer(), t2.bindRenderbuffer(36161, c3.__webglColorRenderbuffer);
              const i3 = s2.convert(l3.format), r3 = s2.convert(l3.type), a3 = O2(l3.internalFormat, i3, r3), o4 = $2(e3);
              t2.renderbufferStorageMultisample(36161, o4, a3, e3.width, e3.height), n2.bindFramebuffer(36160, c3.__webglMultisampledFramebuffer), t2.framebufferRenderbuffer(36160, 36064, 36161, c3.__webglColorRenderbuffer), t2.bindRenderbuffer(36161, null), e3.depthBuffer && (c3.__webglDepthRenderbuffer = t2.createRenderbuffer(), Q2(c3.__webglDepthRenderbuffer, e3, true)), n2.bindFramebuffer(36160, null);
            } else
              console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          if (u2) {
            n2.bindTexture(34067, h2.__webglTexture), X2(34067, l3, f2);
            for (let t3 = 0; t3 < 6; t3++)
              Z2(c3.__webglFramebuffer[t3], e3, l3, 36064, 34069 + t3);
            B2(l3, f2) && F2(34067, l3, e3.width, e3.height), n2.unbindTexture();
          } else if (d2) {
            const t3 = e3.texture;
            for (let r3 = 0, s3 = t3.length; r3 < s3; r3++) {
              const s4 = t3[r3], a3 = i2.get(s4);
              n2.bindTexture(3553, a3.__webglTexture), X2(3553, s4, f2), Z2(c3.__webglFramebuffer, e3, s4, 36064 + r3, 3553), B2(s4, f2) && F2(3553, s4, e3.width, e3.height);
            }
            n2.unbindTexture();
          } else {
            let t3 = 3553;
            if (m2)
              if (o3) {
                t3 = l3.isDataTexture3D ? 32879 : 35866;
              } else
                console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
            n2.bindTexture(t3, h2.__webglTexture), X2(t3, l3, f2), Z2(c3.__webglFramebuffer, e3, l3, 36064, t3), B2(l3, f2) && F2(t3, l3, e3.width, e3.height, e3.depth), n2.unbindTexture();
          }
          e3.depthBuffer && K2(e3);
        }, this.updateRenderTargetMipmap = function(t3) {
          const e3 = z2(t3) || o3, r3 = true === t3.isWebGLMultipleRenderTargets ? t3.texture : [t3.texture];
          for (let s3 = 0, a3 = r3.length; s3 < a3; s3++) {
            const a4 = r3[s3];
            if (B2(a4, e3)) {
              const e4 = t3.isWebGLCubeRenderTarget ? 34067 : 3553, r4 = i2.get(a4).__webglTexture;
              n2.bindTexture(e4, r4), F2(e4, a4, t3.width, t3.height), n2.unbindTexture();
            }
          }
        }, this.updateMultisampleRenderTarget = function(e3) {
          if (e3.isWebGLMultisampleRenderTarget)
            if (o3) {
              const r3 = e3.width, s3 = e3.height;
              let a3 = 16384;
              e3.depthBuffer && (a3 |= 256), e3.stencilBuffer && (a3 |= 1024);
              const o4 = i2.get(e3);
              n2.bindFramebuffer(36008, o4.__webglMultisampledFramebuffer), n2.bindFramebuffer(36009, o4.__webglFramebuffer), t2.blitFramebuffer(0, 0, r3, s3, 0, 0, r3, s3, a3, 9728), n2.bindFramebuffer(36008, null), n2.bindFramebuffer(36009, o4.__webglMultisampledFramebuffer);
            } else
              console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }, this.safeSetTexture2D = function(t3, e3) {
          t3 && t3.isWebGLRenderTarget && (false === tt2 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), tt2 = true), t3 = t3.texture), V2(t3, e3);
        }, this.safeSetTextureCube = function(t3, e3) {
          t3 && t3.isWebGLCubeRenderTarget && (false === et2 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), et2 = true), t3 = t3.texture), W2(t3, e3);
        };
      }
      function Hs(t2, e2, n2) {
        const i2 = n2.isWebGL2;
        return { convert: function(t3) {
          let n3;
          if (t3 === x)
            return 5121;
          if (1017 === t3)
            return 32819;
          if (1018 === t3)
            return 32820;
          if (1019 === t3)
            return 33635;
          if (1010 === t3)
            return 5120;
          if (1011 === t3)
            return 5122;
          if (t3 === _)
            return 5123;
          if (1013 === t3)
            return 5124;
          if (t3 === b)
            return 5125;
          if (t3 === M)
            return 5126;
          if (t3 === w)
            return i2 ? 5131 : (n3 = e2.get("OES_texture_half_float"), null !== n3 ? n3.HALF_FLOAT_OES : null);
          if (1021 === t3)
            return 6406;
          if (t3 === T)
            return 6407;
          if (t3 === E)
            return 6408;
          if (1024 === t3)
            return 6409;
          if (1025 === t3)
            return 6410;
          if (t3 === A)
            return 6402;
          if (t3 === L)
            return 34041;
          if (1028 === t3)
            return 6403;
          if (1029 === t3)
            return 36244;
          if (1030 === t3)
            return 33319;
          if (1031 === t3)
            return 33320;
          if (1032 === t3)
            return 36248;
          if (1033 === t3)
            return 36249;
          if (t3 === R || t3 === C || t3 === P || t3 === I) {
            if (n3 = e2.get("WEBGL_compressed_texture_s3tc"), null === n3)
              return null;
            if (t3 === R)
              return n3.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (t3 === C)
              return n3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (t3 === P)
              return n3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (t3 === I)
              return n3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (t3 === D || t3 === N || t3 === z || t3 === B) {
            if (n3 = e2.get("WEBGL_compressed_texture_pvrtc"), null === n3)
              return null;
            if (t3 === D)
              return n3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (t3 === N)
              return n3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (t3 === z)
              return n3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (t3 === B)
              return n3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (36196 === t3)
            return n3 = e2.get("WEBGL_compressed_texture_etc1"), null !== n3 ? n3.COMPRESSED_RGB_ETC1_WEBGL : null;
          if ((t3 === F || t3 === O) && (n3 = e2.get("WEBGL_compressed_texture_etc"), null !== n3)) {
            if (t3 === F)
              return n3.COMPRESSED_RGB8_ETC2;
            if (t3 === O)
              return n3.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return 37808 === t3 || 37809 === t3 || 37810 === t3 || 37811 === t3 || 37812 === t3 || 37813 === t3 || 37814 === t3 || 37815 === t3 || 37816 === t3 || 37817 === t3 || 37818 === t3 || 37819 === t3 || 37820 === t3 || 37821 === t3 || 37840 === t3 || 37841 === t3 || 37842 === t3 || 37843 === t3 || 37844 === t3 || 37845 === t3 || 37846 === t3 || 37847 === t3 || 37848 === t3 || 37849 === t3 || 37850 === t3 || 37851 === t3 || 37852 === t3 || 37853 === t3 ? (n3 = e2.get("WEBGL_compressed_texture_astc"), null !== n3 ? t3 : null) : 36492 === t3 ? (n3 = e2.get("EXT_texture_compression_bptc"), null !== n3 ? t3 : null) : t3 === S ? i2 ? 34042 : (n3 = e2.get("WEBGL_depth_texture"), null !== n3 ? n3.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
        } };
      }
      class Gs extends Jn {
        constructor(t2 = []) {
          super(), this.cameras = t2;
        }
      }
      Gs.prototype.isArrayCamera = true;
      class ks extends Pe {
        constructor() {
          super(), this.type = "Group";
        }
      }
      ks.prototype.isGroup = true;
      const Vs = { type: "move" };
      class Ws {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return null === this._hand && (this._hand = new ks(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
        }
        getTargetRaySpace() {
          return null === this._targetRay && (this._targetRay = new ks(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new Rt(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new Rt()), this._targetRay;
        }
        getGripSpace() {
          return null === this._grip && (this._grip = new ks(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new Rt(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new Rt()), this._grip;
        }
        dispatchEvent(t2) {
          return null !== this._targetRay && this._targetRay.dispatchEvent(t2), null !== this._grip && this._grip.dispatchEvent(t2), null !== this._hand && this._hand.dispatchEvent(t2), this;
        }
        disconnect(t2) {
          return this.dispatchEvent({ type: "disconnected", data: t2 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
        }
        update(t2, e2, n2) {
          let i2 = null, r2 = null, s2 = null;
          const a2 = this._targetRay, o3 = this._grip, l2 = this._hand;
          if (t2 && "visible-blurred" !== e2.session.visibilityState)
            if (null !== a2 && (i2 = e2.getPose(t2.targetRaySpace, n2), null !== i2 && (a2.matrix.fromArray(i2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), i2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(i2.linearVelocity)) : a2.hasLinearVelocity = false, i2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(i2.angularVelocity)) : a2.hasAngularVelocity = false, this.dispatchEvent(Vs))), l2 && t2.hand) {
              s2 = true;
              for (const i4 of t2.hand.values()) {
                const t3 = e2.getJointPose(i4, n2);
                if (void 0 === l2.joints[i4.jointName]) {
                  const t4 = new ks();
                  t4.matrixAutoUpdate = false, t4.visible = false, l2.joints[i4.jointName] = t4, l2.add(t4);
                }
                const r4 = l2.joints[i4.jointName];
                null !== t3 && (r4.matrix.fromArray(t3.transform.matrix), r4.matrix.decompose(r4.position, r4.rotation, r4.scale), r4.jointRadius = t3.radius), r4.visible = null !== t3;
              }
              const i3 = l2.joints["index-finger-tip"], r3 = l2.joints["thumb-tip"], a3 = i3.position.distanceTo(r3.position), o4 = 0.02, c2 = 5e-3;
              l2.inputState.pinching && a3 > o4 + c2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t2.handedness, target: this })) : !l2.inputState.pinching && a3 <= o4 - c2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t2.handedness, target: this }));
            } else
              null !== o3 && t2.gripSpace && (r2 = e2.getPose(t2.gripSpace, n2), null !== r2 && (o3.matrix.fromArray(r2.transform.matrix), o3.matrix.decompose(o3.position, o3.rotation, o3.scale), r2.linearVelocity ? (o3.hasLinearVelocity = true, o3.linearVelocity.copy(r2.linearVelocity)) : o3.hasLinearVelocity = false, r2.angularVelocity ? (o3.hasAngularVelocity = true, o3.angularVelocity.copy(r2.angularVelocity)) : o3.hasAngularVelocity = false));
          return null !== a2 && (a2.visible = null !== i2), null !== o3 && (o3.visible = null !== r2), null !== l2 && (l2.visible = null !== s2), this;
        }
      }
      class js extends rt {
        constructor(t2, e2) {
          super();
          const n2 = this, i2 = t2.state;
          let r2 = null, s2 = 1, a2 = null, o3 = "local-floor", l2 = null, c2 = null, h2 = null, u2 = null, d2 = null, p2 = false, m2 = null, f2 = null, g2 = null, v2 = null, y2 = null, x2 = null;
          const _2 = [], b2 = /* @__PURE__ */ new Map(), M2 = new Jn();
          M2.layers.enable(1), M2.viewport = new St();
          const w2 = new Jn();
          w2.layers.enable(2), w2.viewport = new St();
          const S2 = [M2, w2], T2 = new Gs();
          T2.layers.enable(1), T2.layers.enable(2);
          let E2 = null, A2 = null;
          function L2(t3) {
            const e3 = b2.get(t3.inputSource);
            e3 && e3.dispatchEvent({ type: t3.type, data: t3.inputSource });
          }
          function R2() {
            b2.forEach(function(t3, e3) {
              t3.disconnect(e3);
            }), b2.clear(), E2 = null, A2 = null, i2.bindXRFramebuffer(null), t2.setRenderTarget(t2.getRenderTarget()), h2 && e2.deleteFramebuffer(h2), m2 && e2.deleteFramebuffer(m2), f2 && e2.deleteRenderbuffer(f2), g2 && e2.deleteRenderbuffer(g2), h2 = null, m2 = null, f2 = null, g2 = null, d2 = null, u2 = null, c2 = null, r2 = null, z2.stop(), n2.isPresenting = false, n2.dispatchEvent({ type: "sessionend" });
          }
          function C2(t3) {
            const e3 = r2.inputSources;
            for (let t4 = 0; t4 < _2.length; t4++)
              b2.set(e3[t4], _2[t4]);
            for (let e4 = 0; e4 < t3.removed.length; e4++) {
              const n3 = t3.removed[e4], i3 = b2.get(n3);
              i3 && (i3.dispatchEvent({ type: "disconnected", data: n3 }), b2.delete(n3));
            }
            for (let e4 = 0; e4 < t3.added.length; e4++) {
              const n3 = t3.added[e4], i3 = b2.get(n3);
              i3 && i3.dispatchEvent({ type: "connected", data: n3 });
            }
          }
          this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(t3) {
            let e3 = _2[t3];
            return void 0 === e3 && (e3 = new Ws(), _2[t3] = e3), e3.getTargetRaySpace();
          }, this.getControllerGrip = function(t3) {
            let e3 = _2[t3];
            return void 0 === e3 && (e3 = new Ws(), _2[t3] = e3), e3.getGripSpace();
          }, this.getHand = function(t3) {
            let e3 = _2[t3];
            return void 0 === e3 && (e3 = new Ws(), _2[t3] = e3), e3.getHandSpace();
          }, this.setFramebufferScaleFactor = function(t3) {
            s2 = t3, true === n2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function(t3) {
            o3 = t3, true === n2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function() {
            return a2;
          }, this.getBaseLayer = function() {
            return null !== u2 ? u2 : d2;
          }, this.getBinding = function() {
            return c2;
          }, this.getFrame = function() {
            return v2;
          }, this.getSession = function() {
            return r2;
          }, this.setSession = async function(t3) {
            if (r2 = t3, null !== r2) {
              r2.addEventListener("select", L2), r2.addEventListener("selectstart", L2), r2.addEventListener("selectend", L2), r2.addEventListener("squeeze", L2), r2.addEventListener("squeezestart", L2), r2.addEventListener("squeezeend", L2), r2.addEventListener("end", R2), r2.addEventListener("inputsourceschange", C2);
              const t4 = e2.getContextAttributes();
              if (true !== t4.xrCompatible && await e2.makeXRCompatible(), void 0 === r2.renderState.layers) {
                const n3 = { antialias: t4.antialias, alpha: t4.alpha, depth: t4.depth, stencil: t4.stencil, framebufferScaleFactor: s2 };
                d2 = new XRWebGLLayer(r2, e2, n3), r2.updateRenderState({ baseLayer: d2 });
              } else if (e2 instanceof WebGLRenderingContext) {
                const n3 = { antialias: true, alpha: t4.alpha, depth: t4.depth, stencil: t4.stencil, framebufferScaleFactor: s2 };
                d2 = new XRWebGLLayer(r2, e2, n3), r2.updateRenderState({ layers: [d2] });
              } else {
                p2 = t4.antialias;
                let n3 = null;
                t4.depth && (x2 = 256, t4.stencil && (x2 |= 1024), y2 = t4.stencil ? 33306 : 36096, n3 = t4.stencil ? 35056 : 33190);
                const a3 = { colorFormat: t4.alpha ? 32856 : 32849, depthFormat: n3, scaleFactor: s2 };
                c2 = new XRWebGLBinding(r2, e2), u2 = c2.createProjectionLayer(a3), h2 = e2.createFramebuffer(), r2.updateRenderState({ layers: [u2] }), p2 && (m2 = e2.createFramebuffer(), f2 = e2.createRenderbuffer(), e2.bindRenderbuffer(36161, f2), e2.renderbufferStorageMultisample(36161, 4, 32856, u2.textureWidth, u2.textureHeight), i2.bindFramebuffer(36160, m2), e2.framebufferRenderbuffer(36160, 36064, 36161, f2), e2.bindRenderbuffer(36161, null), null !== n3 && (g2 = e2.createRenderbuffer(), e2.bindRenderbuffer(36161, g2), e2.renderbufferStorageMultisample(36161, 4, n3, u2.textureWidth, u2.textureHeight), e2.framebufferRenderbuffer(36160, y2, 36161, g2), e2.bindRenderbuffer(36161, null)), i2.bindFramebuffer(36160, null));
              }
              a2 = await r2.requestReferenceSpace(o3), z2.setContext(r2), z2.start(), n2.isPresenting = true, n2.dispatchEvent({ type: "sessionstart" });
            }
          };
          const P2 = new Rt(), I2 = new Rt();
          function D2(t3, e3) {
            null === e3 ? t3.matrixWorld.copy(t3.matrix) : t3.matrixWorld.multiplyMatrices(e3.matrixWorld, t3.matrix), t3.matrixWorldInverse.copy(t3.matrixWorld).invert();
          }
          this.updateCamera = function(t3) {
            if (null === r2)
              return;
            T2.near = w2.near = M2.near = t3.near, T2.far = w2.far = M2.far = t3.far, E2 === T2.near && A2 === T2.far || (r2.updateRenderState({ depthNear: T2.near, depthFar: T2.far }), E2 = T2.near, A2 = T2.far);
            const e3 = t3.parent, n3 = T2.cameras;
            D2(T2, e3);
            for (let t4 = 0; t4 < n3.length; t4++)
              D2(n3[t4], e3);
            T2.matrixWorld.decompose(T2.position, T2.quaternion, T2.scale), t3.position.copy(T2.position), t3.quaternion.copy(T2.quaternion), t3.scale.copy(T2.scale), t3.matrix.copy(T2.matrix), t3.matrixWorld.copy(T2.matrixWorld);
            const i3 = t3.children;
            for (let t4 = 0, e4 = i3.length; t4 < e4; t4++)
              i3[t4].updateMatrixWorld(true);
            2 === n3.length ? function(t4, e4, n4) {
              P2.setFromMatrixPosition(e4.matrixWorld), I2.setFromMatrixPosition(n4.matrixWorld);
              const i4 = P2.distanceTo(I2), r3 = e4.projectionMatrix.elements, s3 = n4.projectionMatrix.elements, a3 = r3[14] / (r3[10] - 1), o4 = r3[14] / (r3[10] + 1), l3 = (r3[9] + 1) / r3[5], c3 = (r3[9] - 1) / r3[5], h3 = (r3[8] - 1) / r3[0], u3 = (s3[8] + 1) / s3[0], d3 = a3 * h3, p3 = a3 * u3, m3 = i4 / (-h3 + u3), f3 = m3 * -h3;
              e4.matrixWorld.decompose(t4.position, t4.quaternion, t4.scale), t4.translateX(f3), t4.translateZ(m3), t4.matrixWorld.compose(t4.position, t4.quaternion, t4.scale), t4.matrixWorldInverse.copy(t4.matrixWorld).invert();
              const g3 = a3 + m3, v3 = o4 + m3, y3 = d3 - f3, x3 = p3 + (i4 - f3), _3 = l3 * o4 / v3 * g3, b3 = c3 * o4 / v3 * g3;
              t4.projectionMatrix.makePerspective(y3, x3, _3, b3, g3, v3);
            }(T2, M2, w2) : T2.projectionMatrix.copy(M2.projectionMatrix);
          }, this.getCamera = function() {
            return T2;
          }, this.getFoveation = function() {
            return null !== u2 ? u2.fixedFoveation : null !== d2 ? d2.fixedFoveation : void 0;
          }, this.setFoveation = function(t3) {
            null !== u2 && (u2.fixedFoveation = t3), null !== d2 && void 0 !== d2.fixedFoveation && (d2.fixedFoveation = t3);
          };
          let N2 = null;
          const z2 = new oi();
          z2.setAnimationLoop(function(t3, n3) {
            if (l2 = n3.getViewerPose(a2), v2 = n3, null !== l2) {
              const t4 = l2.views;
              null !== d2 && i2.bindXRFramebuffer(d2.framebuffer);
              let n4 = false;
              t4.length !== T2.cameras.length && (T2.cameras.length = 0, n4 = true);
              for (let r3 = 0; r3 < t4.length; r3++) {
                const s4 = t4[r3];
                let a3 = null;
                if (null !== d2)
                  a3 = d2.getViewport(s4);
                else {
                  const t5 = c2.getViewSubImage(u2, s4);
                  i2.bindXRFramebuffer(h2), void 0 !== t5.depthStencilTexture && e2.framebufferTexture2D(36160, y2, 3553, t5.depthStencilTexture, 0), e2.framebufferTexture2D(36160, 36064, 3553, t5.colorTexture, 0), a3 = t5.viewport;
                }
                const o4 = S2[r3];
                o4.matrix.fromArray(s4.transform.matrix), o4.projectionMatrix.fromArray(s4.projectionMatrix), o4.viewport.set(a3.x, a3.y, a3.width, a3.height), 0 === r3 && T2.matrix.copy(o4.matrix), true === n4 && T2.cameras.push(o4);
              }
              p2 && (i2.bindXRFramebuffer(m2), null !== x2 && e2.clear(x2));
            }
            const s3 = r2.inputSources;
            for (let t4 = 0; t4 < _2.length; t4++) {
              const e3 = _2[t4], i3 = s3[t4];
              e3.update(i3, n3, a2);
            }
            if (N2 && N2(t3, n3), p2) {
              const t4 = u2.textureWidth, n4 = u2.textureHeight;
              i2.bindFramebuffer(36008, m2), i2.bindFramebuffer(36009, h2), e2.invalidateFramebuffer(36008, [y2]), e2.invalidateFramebuffer(36009, [y2]), e2.blitFramebuffer(0, 0, t4, n4, 0, 0, t4, n4, 16384, 9728), e2.invalidateFramebuffer(36008, [36064]), i2.bindFramebuffer(36008, null), i2.bindFramebuffer(36009, null), i2.bindFramebuffer(36160, m2);
            }
            v2 = null;
          }), this.setAnimationLoop = function(t3) {
            N2 = t3;
          }, this.dispose = function() {
          };
        }
      }
      function qs(t2) {
        function e2(e3, n3) {
          e3.opacity.value = n3.opacity, n3.color && e3.diffuse.value.copy(n3.color), n3.emissive && e3.emissive.value.copy(n3.emissive).multiplyScalar(n3.emissiveIntensity), n3.map && (e3.map.value = n3.map), n3.alphaMap && (e3.alphaMap.value = n3.alphaMap), n3.specularMap && (e3.specularMap.value = n3.specularMap), n3.alphaTest > 0 && (e3.alphaTest.value = n3.alphaTest);
          const i2 = t2.get(n3).envMap;
          if (i2) {
            e3.envMap.value = i2, e3.flipEnvMap.value = i2.isCubeTexture && false === i2.isRenderTargetTexture ? -1 : 1, e3.reflectivity.value = n3.reflectivity, e3.ior.value = n3.ior, e3.refractionRatio.value = n3.refractionRatio;
            const r3 = t2.get(i2).__maxMipLevel;
            void 0 !== r3 && (e3.maxMipLevel.value = r3);
          }
          let r2, s2;
          n3.lightMap && (e3.lightMap.value = n3.lightMap, e3.lightMapIntensity.value = n3.lightMapIntensity), n3.aoMap && (e3.aoMap.value = n3.aoMap, e3.aoMapIntensity.value = n3.aoMapIntensity), n3.map ? r2 = n3.map : n3.specularMap ? r2 = n3.specularMap : n3.displacementMap ? r2 = n3.displacementMap : n3.normalMap ? r2 = n3.normalMap : n3.bumpMap ? r2 = n3.bumpMap : n3.roughnessMap ? r2 = n3.roughnessMap : n3.metalnessMap ? r2 = n3.metalnessMap : n3.alphaMap ? r2 = n3.alphaMap : n3.emissiveMap ? r2 = n3.emissiveMap : n3.clearcoatMap ? r2 = n3.clearcoatMap : n3.clearcoatNormalMap ? r2 = n3.clearcoatNormalMap : n3.clearcoatRoughnessMap ? r2 = n3.clearcoatRoughnessMap : n3.specularIntensityMap ? r2 = n3.specularIntensityMap : n3.specularTintMap ? r2 = n3.specularTintMap : n3.transmissionMap ? r2 = n3.transmissionMap : n3.thicknessMap && (r2 = n3.thicknessMap), void 0 !== r2 && (r2.isWebGLRenderTarget && (r2 = r2.texture), true === r2.matrixAutoUpdate && r2.updateMatrix(), e3.uvTransform.value.copy(r2.matrix)), n3.aoMap ? s2 = n3.aoMap : n3.lightMap && (s2 = n3.lightMap), void 0 !== s2 && (s2.isWebGLRenderTarget && (s2 = s2.texture), true === s2.matrixAutoUpdate && s2.updateMatrix(), e3.uv2Transform.value.copy(s2.matrix));
        }
        function n2(e3, n3) {
          e3.roughness.value = n3.roughness, e3.metalness.value = n3.metalness, n3.roughnessMap && (e3.roughnessMap.value = n3.roughnessMap), n3.metalnessMap && (e3.metalnessMap.value = n3.metalnessMap), n3.emissiveMap && (e3.emissiveMap.value = n3.emissiveMap), n3.bumpMap && (e3.bumpMap.value = n3.bumpMap, e3.bumpScale.value = n3.bumpScale, 1 === n3.side && (e3.bumpScale.value *= -1)), n3.normalMap && (e3.normalMap.value = n3.normalMap, e3.normalScale.value.copy(n3.normalScale), 1 === n3.side && e3.normalScale.value.negate()), n3.displacementMap && (e3.displacementMap.value = n3.displacementMap, e3.displacementScale.value = n3.displacementScale, e3.displacementBias.value = n3.displacementBias);
          t2.get(n3).envMap && (e3.envMapIntensity.value = n3.envMapIntensity);
        }
        return { refreshFogUniforms: function(t3, e3) {
          t3.fogColor.value.copy(e3.color), e3.isFog ? (t3.fogNear.value = e3.near, t3.fogFar.value = e3.far) : e3.isFogExp2 && (t3.fogDensity.value = e3.density);
        }, refreshMaterialUniforms: function(t3, i2, r2, s2, a2) {
          i2.isMeshBasicMaterial ? e2(t3, i2) : i2.isMeshLambertMaterial ? (e2(t3, i2), function(t4, e3) {
            e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
          }(t3, i2)) : i2.isMeshToonMaterial ? (e2(t3, i2), function(t4, e3) {
            e3.gradientMap && (t4.gradientMap.value = e3.gradientMap);
            e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, 1 === e3.side && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), 1 === e3.side && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, i2)) : i2.isMeshPhongMaterial ? (e2(t3, i2), function(t4, e3) {
            t4.specular.value.copy(e3.specular), t4.shininess.value = Math.max(e3.shininess, 1e-4), e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, 1 === e3.side && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), 1 === e3.side && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, i2)) : i2.isMeshStandardMaterial ? (e2(t3, i2), i2.isMeshPhysicalMaterial ? function(t4, e3, i3) {
            n2(t4, e3), t4.ior.value = e3.ior, e3.sheenTint && t4.sheenTint.value.copy(e3.sheenTint);
            e3.clearcoat > 0 && (t4.clearcoat.value = e3.clearcoat, t4.clearcoatRoughness.value = e3.clearcoatRoughness, e3.clearcoatMap && (t4.clearcoatMap.value = e3.clearcoatMap), e3.clearcoatRoughnessMap && (t4.clearcoatRoughnessMap.value = e3.clearcoatRoughnessMap), e3.clearcoatNormalMap && (t4.clearcoatNormalScale.value.copy(e3.clearcoatNormalScale), t4.clearcoatNormalMap.value = e3.clearcoatNormalMap, 1 === e3.side && t4.clearcoatNormalScale.value.negate()));
            e3.transmission > 0 && (t4.transmission.value = e3.transmission, t4.transmissionSamplerMap.value = i3.texture, t4.transmissionSamplerSize.value.set(i3.width, i3.height), e3.transmissionMap && (t4.transmissionMap.value = e3.transmissionMap), t4.thickness.value = e3.thickness, e3.thicknessMap && (t4.thicknessMap.value = e3.thicknessMap), t4.attenuationDistance.value = e3.attenuationDistance, t4.attenuationTint.value.copy(e3.attenuationTint));
            t4.specularIntensity.value = e3.specularIntensity, t4.specularTint.value.copy(e3.specularTint), e3.specularIntensityMap && (t4.specularIntensityMap.value = e3.specularIntensityMap);
            e3.specularTintMap && (t4.specularTintMap.value = e3.specularTintMap);
          }(t3, i2, a2) : n2(t3, i2)) : i2.isMeshMatcapMaterial ? (e2(t3, i2), function(t4, e3) {
            e3.matcap && (t4.matcap.value = e3.matcap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, 1 === e3.side && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), 1 === e3.side && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, i2)) : i2.isMeshDepthMaterial ? (e2(t3, i2), function(t4, e3) {
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, i2)) : i2.isMeshDistanceMaterial ? (e2(t3, i2), function(t4, e3) {
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
            t4.referencePosition.value.copy(e3.referencePosition), t4.nearDistance.value = e3.nearDistance, t4.farDistance.value = e3.farDistance;
          }(t3, i2)) : i2.isMeshNormalMaterial ? (e2(t3, i2), function(t4, e3) {
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, 1 === e3.side && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), 1 === e3.side && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, i2)) : i2.isLineBasicMaterial ? (function(t4, e3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity;
          }(t3, i2), i2.isLineDashedMaterial && function(t4, e3) {
            t4.dashSize.value = e3.dashSize, t4.totalSize.value = e3.dashSize + e3.gapSize, t4.scale.value = e3.scale;
          }(t3, i2)) : i2.isPointsMaterial ? function(t4, e3, n3, i3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.size.value = e3.size * n3, t4.scale.value = 0.5 * i3, e3.map && (t4.map.value = e3.map);
            e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
            e3.alphaTest > 0 && (t4.alphaTest.value = e3.alphaTest);
            let r3;
            e3.map ? r3 = e3.map : e3.alphaMap && (r3 = e3.alphaMap);
            void 0 !== r3 && (true === r3.matrixAutoUpdate && r3.updateMatrix(), t4.uvTransform.value.copy(r3.matrix));
          }(t3, i2, r2, s2) : i2.isSpriteMaterial ? function(t4, e3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.rotation.value = e3.rotation, e3.map && (t4.map.value = e3.map);
            e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
            e3.alphaTest > 0 && (t4.alphaTest.value = e3.alphaTest);
            let n3;
            e3.map ? n3 = e3.map : e3.alphaMap && (n3 = e3.alphaMap);
            void 0 !== n3 && (true === n3.matrixAutoUpdate && n3.updateMatrix(), t4.uvTransform.value.copy(n3.matrix));
          }(t3, i2) : i2.isShadowMaterial ? (t3.color.value.copy(i2.color), t3.opacity.value = i2.opacity) : i2.isShaderMaterial && (i2.uniformsNeedUpdate = false);
        } };
      }
      function Xs(t2 = {}) {
        const e2 = void 0 !== t2.canvas ? t2.canvas : function() {
          const t3 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          return t3.style.display = "block", t3;
        }(), n2 = void 0 !== t2.context ? t2.context : null, i2 = void 0 !== t2.alpha && t2.alpha, r2 = void 0 === t2.depth || t2.depth, s2 = void 0 === t2.stencil || t2.stencil, a2 = void 0 !== t2.antialias && t2.antialias, o3 = void 0 === t2.premultipliedAlpha || t2.premultipliedAlpha, l2 = void 0 !== t2.preserveDrawingBuffer && t2.preserveDrawingBuffer, c2 = void 0 !== t2.powerPreference ? t2.powerPreference : "default", h2 = void 0 !== t2.failIfMajorPerformanceCaveat && t2.failIfMajorPerformanceCaveat;
        let d2 = null, m2 = null;
        const f2 = [], g2 = [];
        this.domElement = e2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = X, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
        const v2 = this;
        let _2 = false, b2 = 0, S2 = 0, T2 = null, A2 = -1, L2 = null;
        const R2 = new St(), C2 = new St();
        let P2 = null, I2 = e2.width, D2 = e2.height, N2 = 1, z2 = null, B2 = null;
        const F2 = new St(0, 0, I2, D2), O2 = new St(0, 0, I2, D2);
        let U2 = false;
        const H2 = [], G2 = new ai();
        let k2 = false, V2 = false, W2 = null;
        const j2 = new ae(), q2 = new Rt(), Y2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
        function J2() {
          return null === T2 ? N2 : 1;
        }
        let Z2, Q2, K2, $2, tt2, et2, nt2, it2, rt2, st2, at2, ot2, lt2, ct2, ht2, ut2, dt2, pt2, mt2, ft2, gt2, vt2, yt2, xt2 = n2;
        function _t2(t3, n3) {
          for (let i3 = 0; i3 < t3.length; i3++) {
            const r3 = t3[i3], s3 = e2.getContext(r3, n3);
            if (null !== s3)
              return s3;
          }
          return null;
        }
        try {
          const t3 = { alpha: i2, depth: r2, stencil: s2, antialias: a2, premultipliedAlpha: o3, preserveDrawingBuffer: l2, powerPreference: c2, failIfMajorPerformanceCaveat: h2 };
          if (e2.addEventListener("webglcontextlost", wt2, false), e2.addEventListener("webglcontextrestored", Et2, false), null === xt2) {
            const e3 = ["webgl2", "webgl", "experimental-webgl"];
            if (true === v2.isWebGL1Renderer && e3.shift(), xt2 = _t2(e3, t3), null === xt2)
              throw _t2(e3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
          }
          void 0 === xt2.getShaderPrecisionFormat && (xt2.getShaderPrecisionFormat = function() {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
        } catch (t3) {
          throw console.error("THREE.WebGLRenderer: " + t3.message), t3;
        }
        function bt2() {
          Z2 = new ji(xt2), Q2 = new gi(xt2, Z2, t2), Z2.init(Q2), vt2 = new Hs(xt2, Z2, Q2), K2 = new Os(xt2, Z2, Q2), H2[0] = 1029, $2 = new Yi(xt2), tt2 = new Ss(), et2 = new Us(xt2, Z2, K2, tt2, Q2, vt2, $2), nt2 = new yi(v2), it2 = new Wi(v2), rt2 = new li(xt2, Q2), yt2 = new mi(xt2, Z2, rt2, Q2), st2 = new qi(xt2, rt2, $2, yt2), at2 = new Ki(xt2, st2, rt2, $2), mt2 = new Qi(xt2), ut2 = new vi(tt2), ot2 = new ws(v2, nt2, it2, Z2, Q2, yt2, ut2), lt2 = new qs(tt2), ct2 = new Ls(tt2), ht2 = new Ns(Z2, Q2), pt2 = new pi(v2, nt2, K2, at2, o3), dt2 = new Fs(v2, at2, Q2), ft2 = new fi(xt2, Z2, $2, Q2), gt2 = new Xi(xt2, Z2, $2, Q2), $2.programs = ot2.programs, v2.capabilities = Q2, v2.extensions = Z2, v2.properties = tt2, v2.renderLists = ct2, v2.shadowMap = dt2, v2.state = K2, v2.info = $2;
        }
        bt2();
        const Mt2 = new js(v2, xt2);
        function wt2(t3) {
          t3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _2 = true;
        }
        function Et2() {
          console.log("THREE.WebGLRenderer: Context Restored."), _2 = false;
          const t3 = $2.autoReset, e3 = dt2.enabled, n3 = dt2.autoUpdate, i3 = dt2.needsUpdate, r3 = dt2.type;
          bt2(), $2.autoReset = t3, dt2.enabled = e3, dt2.autoUpdate = n3, dt2.needsUpdate = i3, dt2.type = r3;
        }
        function Lt2(t3) {
          const e3 = t3.target;
          e3.removeEventListener("dispose", Lt2), function(t4) {
            (function(t5) {
              const e4 = tt2.get(t5).programs;
              void 0 !== e4 && e4.forEach(function(t6) {
                ot2.releaseProgram(t6);
              });
            })(t4), tt2.remove(t4);
          }(e3);
        }
        this.xr = Mt2, this.getContext = function() {
          return xt2;
        }, this.getContextAttributes = function() {
          return xt2.getContextAttributes();
        }, this.forceContextLoss = function() {
          const t3 = Z2.get("WEBGL_lose_context");
          t3 && t3.loseContext();
        }, this.forceContextRestore = function() {
          const t3 = Z2.get("WEBGL_lose_context");
          t3 && t3.restoreContext();
        }, this.getPixelRatio = function() {
          return N2;
        }, this.setPixelRatio = function(t3) {
          void 0 !== t3 && (N2 = t3, this.setSize(I2, D2, false));
        }, this.getSize = function(t3) {
          return t3.set(I2, D2);
        }, this.setSize = function(t3, n3, i3) {
          Mt2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I2 = t3, D2 = n3, e2.width = Math.floor(t3 * N2), e2.height = Math.floor(n3 * N2), false !== i3 && (e2.style.width = t3 + "px", e2.style.height = n3 + "px"), this.setViewport(0, 0, t3, n3));
        }, this.getDrawingBufferSize = function(t3) {
          return t3.set(I2 * N2, D2 * N2).floor();
        }, this.setDrawingBufferSize = function(t3, n3, i3) {
          I2 = t3, D2 = n3, N2 = i3, e2.width = Math.floor(t3 * i3), e2.height = Math.floor(n3 * i3), this.setViewport(0, 0, t3, n3);
        }, this.getCurrentViewport = function(t3) {
          return t3.copy(R2);
        }, this.getViewport = function(t3) {
          return t3.copy(F2);
        }, this.setViewport = function(t3, e3, n3, i3) {
          t3.isVector4 ? F2.set(t3.x, t3.y, t3.z, t3.w) : F2.set(t3, e3, n3, i3), K2.viewport(R2.copy(F2).multiplyScalar(N2).floor());
        }, this.getScissor = function(t3) {
          return t3.copy(O2);
        }, this.setScissor = function(t3, e3, n3, i3) {
          t3.isVector4 ? O2.set(t3.x, t3.y, t3.z, t3.w) : O2.set(t3, e3, n3, i3), K2.scissor(C2.copy(O2).multiplyScalar(N2).floor());
        }, this.getScissorTest = function() {
          return U2;
        }, this.setScissorTest = function(t3) {
          K2.setScissorTest(U2 = t3);
        }, this.setOpaqueSort = function(t3) {
          z2 = t3;
        }, this.setTransparentSort = function(t3) {
          B2 = t3;
        }, this.getClearColor = function(t3) {
          return t3.copy(pt2.getClearColor());
        }, this.setClearColor = function() {
          pt2.setClearColor.apply(pt2, arguments);
        }, this.getClearAlpha = function() {
          return pt2.getClearAlpha();
        }, this.setClearAlpha = function() {
          pt2.setClearAlpha.apply(pt2, arguments);
        }, this.clear = function(t3, e3, n3) {
          let i3 = 0;
          (void 0 === t3 || t3) && (i3 |= 16384), (void 0 === e3 || e3) && (i3 |= 256), (void 0 === n3 || n3) && (i3 |= 1024), xt2.clear(i3);
        }, this.clearColor = function() {
          this.clear(true, false, false);
        }, this.clearDepth = function() {
          this.clear(false, true, false);
        }, this.clearStencil = function() {
          this.clear(false, false, true);
        }, this.dispose = function() {
          e2.removeEventListener("webglcontextlost", wt2, false), e2.removeEventListener("webglcontextrestored", Et2, false), ct2.dispose(), ht2.dispose(), tt2.dispose(), nt2.dispose(), it2.dispose(), at2.dispose(), yt2.dispose(), Mt2.dispose(), Mt2.removeEventListener("sessionstart", Pt2), Mt2.removeEventListener("sessionend", It2), W2 && (W2.dispose(), W2 = null), Dt2.stop();
        }, this.renderBufferImmediate = function(t3, e3) {
          yt2.initAttributes();
          const n3 = tt2.get(t3);
          t3.hasPositions && !n3.position && (n3.position = xt2.createBuffer()), t3.hasNormals && !n3.normal && (n3.normal = xt2.createBuffer()), t3.hasUvs && !n3.uv && (n3.uv = xt2.createBuffer()), t3.hasColors && !n3.color && (n3.color = xt2.createBuffer());
          const i3 = e3.getAttributes();
          t3.hasPositions && (xt2.bindBuffer(34962, n3.position), xt2.bufferData(34962, t3.positionArray, 35048), yt2.enableAttribute(i3.position.location), xt2.vertexAttribPointer(i3.position.location, 3, 5126, false, 0, 0)), t3.hasNormals && (xt2.bindBuffer(34962, n3.normal), xt2.bufferData(34962, t3.normalArray, 35048), yt2.enableAttribute(i3.normal.location), xt2.vertexAttribPointer(i3.normal.location, 3, 5126, false, 0, 0)), t3.hasUvs && (xt2.bindBuffer(34962, n3.uv), xt2.bufferData(34962, t3.uvArray, 35048), yt2.enableAttribute(i3.uv.location), xt2.vertexAttribPointer(i3.uv.location, 2, 5126, false, 0, 0)), t3.hasColors && (xt2.bindBuffer(34962, n3.color), xt2.bufferData(34962, t3.colorArray, 35048), yt2.enableAttribute(i3.color.location), xt2.vertexAttribPointer(i3.color.location, 3, 5126, false, 0, 0)), yt2.disableUnusedAttributes(), xt2.drawArrays(4, 0, t3.count), t3.count = 0;
        }, this.renderBufferDirect = function(t3, e3, n3, i3, r3, s3) {
          null === e3 && (e3 = Y2);
          const a3 = r3.isMesh && r3.matrixWorld.determinant() < 0, o4 = Ht2(t3, e3, i3, r3);
          K2.setMaterial(i3, a3);
          let l3 = n3.index;
          const c3 = n3.attributes.position;
          if (null === l3) {
            if (void 0 === c3 || 0 === c3.count)
              return;
          } else if (0 === l3.count)
            return;
          let h3, u2 = 1;
          true === i3.wireframe && (l3 = st2.getWireframeAttribute(n3), u2 = 2), void 0 === n3.morphAttributes.position && void 0 === n3.morphAttributes.normal || mt2.update(r3, n3, i3, o4), yt2.setup(r3, i3, o4, n3, l3);
          let d3 = ft2;
          null !== l3 && (h3 = rt2.get(l3), d3 = gt2, d3.setIndex(h3));
          const p2 = null !== l3 ? l3.count : c3.count, m3 = n3.drawRange.start * u2, f3 = n3.drawRange.count * u2, g3 = null !== s3 ? s3.start * u2 : 0, v3 = null !== s3 ? s3.count * u2 : 1 / 0, y2 = Math.max(m3, g3), x2 = Math.min(p2, m3 + f3, g3 + v3) - 1, _3 = Math.max(0, x2 - y2 + 1);
          if (0 !== _3) {
            if (r3.isMesh)
              true === i3.wireframe ? (K2.setLineWidth(i3.wireframeLinewidth * J2()), d3.setMode(1)) : d3.setMode(4);
            else if (r3.isLine) {
              let t4 = i3.linewidth;
              void 0 === t4 && (t4 = 1), K2.setLineWidth(t4 * J2()), r3.isLineSegments ? d3.setMode(1) : r3.isLineLoop ? d3.setMode(2) : d3.setMode(3);
            } else
              r3.isPoints ? d3.setMode(0) : r3.isSprite && d3.setMode(4);
            if (r3.isInstancedMesh)
              d3.renderInstances(y2, _3, r3.count);
            else if (n3.isInstancedBufferGeometry) {
              const t4 = Math.min(n3.instanceCount, n3._maxInstanceCount);
              d3.renderInstances(y2, _3, t4);
            } else
              d3.render(y2, _3);
          }
        }, this.compile = function(t3, e3) {
          m2 = ht2.get(t3), m2.init(), g2.push(m2), t3.traverseVisible(function(t4) {
            t4.isLight && t4.layers.test(e3.layers) && (m2.pushLight(t4), t4.castShadow && m2.pushShadow(t4));
          }), m2.setupLights(v2.physicallyCorrectLights), t3.traverse(function(e4) {
            const n3 = e4.material;
            if (n3)
              if (Array.isArray(n3))
                for (let i3 = 0; i3 < n3.length; i3++) {
                  Ot2(n3[i3], t3, e4);
                }
              else
                Ot2(n3, t3, e4);
          }), g2.pop(), m2 = null;
        };
        let Ct2 = null;
        function Pt2() {
          Dt2.stop();
        }
        function It2() {
          Dt2.start();
        }
        const Dt2 = new oi();
        function Nt2(t3, e3, n3, i3) {
          if (false === t3.visible)
            return;
          if (t3.layers.test(e3.layers)) {
            if (t3.isGroup)
              n3 = t3.renderOrder;
            else if (t3.isLOD)
              true === t3.autoUpdate && t3.update(e3);
            else if (t3.isLight)
              m2.pushLight(t3), t3.castShadow && m2.pushShadow(t3);
            else if (t3.isSprite) {
              if (!t3.frustumCulled || G2.intersectsSprite(t3)) {
                i3 && q2.setFromMatrixPosition(t3.matrixWorld).applyMatrix4(j2);
                const e4 = at2.update(t3), r4 = t3.material;
                r4.visible && d2.push(t3, e4, r4, n3, q2.z, null);
              }
            } else if (t3.isImmediateRenderObject)
              i3 && q2.setFromMatrixPosition(t3.matrixWorld).applyMatrix4(j2), d2.push(t3, null, t3.material, n3, q2.z, null);
            else if ((t3.isMesh || t3.isLine || t3.isPoints) && (t3.isSkinnedMesh && t3.skeleton.frame !== $2.render.frame && (t3.skeleton.update(), t3.skeleton.frame = $2.render.frame), !t3.frustumCulled || G2.intersectsObject(t3))) {
              i3 && q2.setFromMatrixPosition(t3.matrixWorld).applyMatrix4(j2);
              const e4 = at2.update(t3), r4 = t3.material;
              if (Array.isArray(r4)) {
                const i4 = e4.groups;
                for (let s3 = 0, a3 = i4.length; s3 < a3; s3++) {
                  const a4 = i4[s3], o4 = r4[a4.materialIndex];
                  o4 && o4.visible && d2.push(t3, e4, o4, n3, q2.z, a4);
                }
              } else
                r4.visible && d2.push(t3, e4, r4, n3, q2.z, null);
            }
          }
          const r3 = t3.children;
          for (let t4 = 0, s3 = r3.length; t4 < s3; t4++)
            Nt2(r3[t4], e3, n3, i3);
        }
        function zt2(t3, e3, n3, i3) {
          const r3 = t3.opaque, s3 = t3.transmissive, o4 = t3.transparent;
          m2.setupLightsView(n3), s3.length > 0 && function(t4, e4, n4) {
            if (null === W2) {
              const t5 = true === a2 && true === Q2.isWebGL2;
              W2 = new (t5 ? At : Tt)(1024, 1024, { generateMipmaps: true, type: null !== vt2.convert(w) ? w : x, minFilter: y, magFilter: p, wrapS: u, wrapT: u });
            }
            const i4 = v2.getRenderTarget();
            v2.setRenderTarget(W2), v2.clear();
            const r4 = v2.toneMapping;
            v2.toneMapping = 0, Bt2(t4, e4, n4), v2.toneMapping = r4, et2.updateMultisampleRenderTarget(W2), et2.updateRenderTargetMipmap(W2), v2.setRenderTarget(i4);
          }(r3, e3, n3), i3 && K2.viewport(R2.copy(i3)), r3.length > 0 && Bt2(r3, e3, n3), s3.length > 0 && Bt2(s3, e3, n3), o4.length > 0 && Bt2(o4, e3, n3);
        }
        function Bt2(t3, e3, n3) {
          const i3 = true === e3.isScene ? e3.overrideMaterial : null;
          for (let r3 = 0, s3 = t3.length; r3 < s3; r3++) {
            const s4 = t3[r3], a3 = s4.object, o4 = s4.geometry, l3 = null === i3 ? s4.material : i3, c3 = s4.group;
            a3.layers.test(n3.layers) && Ft2(a3, e3, n3, o4, l3, c3);
          }
        }
        function Ft2(t3, e3, n3, i3, r3, s3) {
          if (t3.onBeforeRender(v2, e3, n3, i3, r3, s3), t3.modelViewMatrix.multiplyMatrices(n3.matrixWorldInverse, t3.matrixWorld), t3.normalMatrix.getNormalMatrix(t3.modelViewMatrix), t3.isImmediateRenderObject) {
            const i4 = Ht2(n3, e3, r3, t3);
            K2.setMaterial(r3), yt2.reset(), function(t4, e4) {
              t4.render(function(t5) {
                v2.renderBufferImmediate(t5, e4);
              });
            }(t3, i4);
          } else
            true === r3.transparent && 2 === r3.side ? (r3.side = 1, r3.needsUpdate = true, v2.renderBufferDirect(n3, e3, i3, r3, t3, s3), r3.side = 0, r3.needsUpdate = true, v2.renderBufferDirect(n3, e3, i3, r3, t3, s3), r3.side = 2) : v2.renderBufferDirect(n3, e3, i3, r3, t3, s3);
          t3.onAfterRender(v2, e3, n3, i3, r3, s3);
        }
        function Ot2(t3, e3, n3) {
          true !== e3.isScene && (e3 = Y2);
          const i3 = tt2.get(t3), r3 = m2.state.lights, s3 = m2.state.shadowsArray, a3 = r3.state.version, o4 = ot2.getParameters(t3, r3.state, s3, e3, n3), l3 = ot2.getProgramCacheKey(o4);
          let c3 = i3.programs;
          i3.environment = t3.isMeshStandardMaterial ? e3.environment : null, i3.fog = e3.fog, i3.envMap = (t3.isMeshStandardMaterial ? it2 : nt2).get(t3.envMap || i3.environment), void 0 === c3 && (t3.addEventListener("dispose", Lt2), c3 = /* @__PURE__ */ new Map(), i3.programs = c3);
          let h3 = c3.get(l3);
          if (void 0 !== h3) {
            if (i3.currentProgram === h3 && i3.lightsStateVersion === a3)
              return Ut2(t3, o4), h3;
          } else
            o4.uniforms = ot2.getUniforms(t3), t3.onBuild(o4, v2), t3.onBeforeCompile(o4, v2), h3 = ot2.acquireProgram(o4, l3), c3.set(l3, h3), i3.uniforms = o4.uniforms;
          const u2 = i3.uniforms;
          (t3.isShaderMaterial || t3.isRawShaderMaterial) && true !== t3.clipping || (u2.clippingPlanes = ut2.uniform), Ut2(t3, o4), i3.needsLights = function(t4) {
            return t4.isMeshLambertMaterial || t4.isMeshToonMaterial || t4.isMeshPhongMaterial || t4.isMeshStandardMaterial || t4.isShadowMaterial || t4.isShaderMaterial && true === t4.lights;
          }(t3), i3.lightsStateVersion = a3, i3.needsLights && (u2.ambientLightColor.value = r3.state.ambient, u2.lightProbe.value = r3.state.probe, u2.directionalLights.value = r3.state.directional, u2.directionalLightShadows.value = r3.state.directionalShadow, u2.spotLights.value = r3.state.spot, u2.spotLightShadows.value = r3.state.spotShadow, u2.rectAreaLights.value = r3.state.rectArea, u2.ltc_1.value = r3.state.rectAreaLTC1, u2.ltc_2.value = r3.state.rectAreaLTC2, u2.pointLights.value = r3.state.point, u2.pointLightShadows.value = r3.state.pointShadow, u2.hemisphereLights.value = r3.state.hemi, u2.directionalShadowMap.value = r3.state.directionalShadowMap, u2.directionalShadowMatrix.value = r3.state.directionalShadowMatrix, u2.spotShadowMap.value = r3.state.spotShadowMap, u2.spotShadowMatrix.value = r3.state.spotShadowMatrix, u2.pointShadowMap.value = r3.state.pointShadowMap, u2.pointShadowMatrix.value = r3.state.pointShadowMatrix);
          const d3 = h3.getUniforms(), p2 = ns.seqWithValue(d3.seq, u2);
          return i3.currentProgram = h3, i3.uniformsList = p2, h3;
        }
        function Ut2(t3, e3) {
          const n3 = tt2.get(t3);
          n3.outputEncoding = e3.outputEncoding, n3.instancing = e3.instancing, n3.skinning = e3.skinning, n3.morphTargets = e3.morphTargets, n3.morphNormals = e3.morphNormals, n3.numClippingPlanes = e3.numClippingPlanes, n3.numIntersection = e3.numClipIntersection, n3.vertexAlphas = e3.vertexAlphas, n3.vertexTangents = e3.vertexTangents;
        }
        function Ht2(t3, e3, n3, i3) {
          true !== e3.isScene && (e3 = Y2), et2.resetTextureUnits();
          const r3 = e3.fog, s3 = n3.isMeshStandardMaterial ? e3.environment : null, a3 = null === T2 ? v2.outputEncoding : T2.texture.encoding, o4 = (n3.isMeshStandardMaterial ? it2 : nt2).get(n3.envMap || s3), l3 = true === n3.vertexColors && !!i3.geometry && !!i3.geometry.attributes.color && 4 === i3.geometry.attributes.color.itemSize, c3 = !!i3.geometry && !!i3.geometry.attributes.tangent, h3 = !!i3.geometry && !!i3.geometry.morphAttributes.position, u2 = !!i3.geometry && !!i3.geometry.morphAttributes.normal, d3 = tt2.get(n3), p2 = m2.state.lights;
          if (true === k2 && (true === V2 || t3 !== L2)) {
            const e4 = t3 === L2 && n3.id === A2;
            ut2.setState(n3, t3, e4);
          }
          let f3 = false;
          n3.version === d3.__version ? d3.needsLights && d3.lightsStateVersion !== p2.state.version || d3.outputEncoding !== a3 || i3.isInstancedMesh && false === d3.instancing ? f3 = true : i3.isInstancedMesh || true !== d3.instancing ? i3.isSkinnedMesh && false === d3.skinning ? f3 = true : i3.isSkinnedMesh || true !== d3.skinning ? d3.envMap !== o4 || n3.fog && d3.fog !== r3 ? f3 = true : void 0 === d3.numClippingPlanes || d3.numClippingPlanes === ut2.numPlanes && d3.numIntersection === ut2.numIntersection ? (d3.vertexAlphas !== l3 || d3.vertexTangents !== c3 || d3.morphTargets !== h3 || d3.morphNormals !== u2) && (f3 = true) : f3 = true : f3 = true : f3 = true : (f3 = true, d3.__version = n3.version);
          let g3 = d3.currentProgram;
          true === f3 && (g3 = Ot2(n3, e3, i3));
          let y2 = false, x2 = false, _3 = false;
          const b3 = g3.getUniforms(), M2 = d3.uniforms;
          if (K2.useProgram(g3.program) && (y2 = true, x2 = true, _3 = true), n3.id !== A2 && (A2 = n3.id, x2 = true), y2 || L2 !== t3) {
            if (b3.setValue(xt2, "projectionMatrix", t3.projectionMatrix), Q2.logarithmicDepthBuffer && b3.setValue(xt2, "logDepthBufFC", 2 / (Math.log(t3.far + 1) / Math.LN2)), L2 !== t3 && (L2 = t3, x2 = true, _3 = true), n3.isShaderMaterial || n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshStandardMaterial || n3.envMap) {
              const e4 = b3.map.cameraPosition;
              void 0 !== e4 && e4.setValue(xt2, q2.setFromMatrixPosition(t3.matrixWorld));
            }
            (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial) && b3.setValue(xt2, "isOrthographic", true === t3.isOrthographicCamera), (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial || n3.isShadowMaterial || i3.isSkinnedMesh) && b3.setValue(xt2, "viewMatrix", t3.matrixWorldInverse);
          }
          if (i3.isSkinnedMesh) {
            b3.setOptional(xt2, i3, "bindMatrix"), b3.setOptional(xt2, i3, "bindMatrixInverse");
            const t4 = i3.skeleton;
            t4 && (Q2.floatVertexTextures ? (null === t4.boneTexture && t4.computeBoneTexture(), b3.setValue(xt2, "boneTexture", t4.boneTexture, et2), b3.setValue(xt2, "boneTextureSize", t4.boneTextureSize)) : b3.setOptional(xt2, t4, "boneMatrices"));
          }
          var w2, S3;
          return (x2 || d3.receiveShadow !== i3.receiveShadow) && (d3.receiveShadow = i3.receiveShadow, b3.setValue(xt2, "receiveShadow", i3.receiveShadow)), x2 && (b3.setValue(xt2, "toneMappingExposure", v2.toneMappingExposure), d3.needsLights && (S3 = _3, (w2 = M2).ambientLightColor.needsUpdate = S3, w2.lightProbe.needsUpdate = S3, w2.directionalLights.needsUpdate = S3, w2.directionalLightShadows.needsUpdate = S3, w2.pointLights.needsUpdate = S3, w2.pointLightShadows.needsUpdate = S3, w2.spotLights.needsUpdate = S3, w2.spotLightShadows.needsUpdate = S3, w2.rectAreaLights.needsUpdate = S3, w2.hemisphereLights.needsUpdate = S3), r3 && n3.fog && lt2.refreshFogUniforms(M2, r3), lt2.refreshMaterialUniforms(M2, n3, N2, D2, W2), ns.upload(xt2, d3.uniformsList, M2, et2)), n3.isShaderMaterial && true === n3.uniformsNeedUpdate && (ns.upload(xt2, d3.uniformsList, M2, et2), n3.uniformsNeedUpdate = false), n3.isSpriteMaterial && b3.setValue(xt2, "center", i3.center), b3.setValue(xt2, "modelViewMatrix", i3.modelViewMatrix), b3.setValue(xt2, "normalMatrix", i3.normalMatrix), b3.setValue(xt2, "modelMatrix", i3.matrixWorld), g3;
        }
        Dt2.setAnimationLoop(function(t3) {
          Ct2 && Ct2(t3);
        }), "undefined" != typeof window && Dt2.setContext(window), this.setAnimationLoop = function(t3) {
          Ct2 = t3, Mt2.setAnimationLoop(t3), null === t3 ? Dt2.stop() : Dt2.start();
        }, Mt2.addEventListener("sessionstart", Pt2), Mt2.addEventListener("sessionend", It2), this.render = function(t3, e3) {
          if (void 0 !== e3 && true !== e3.isCamera)
            return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          if (true === _2)
            return;
          true === t3.autoUpdate && t3.updateMatrixWorld(), null === e3.parent && e3.updateMatrixWorld(), true === Mt2.enabled && true === Mt2.isPresenting && (true === Mt2.cameraAutoUpdate && Mt2.updateCamera(e3), e3 = Mt2.getCamera()), true === t3.isScene && t3.onBeforeRender(v2, t3, e3, T2), m2 = ht2.get(t3, g2.length), m2.init(), g2.push(m2), j2.multiplyMatrices(e3.projectionMatrix, e3.matrixWorldInverse), G2.setFromProjectionMatrix(j2), V2 = this.localClippingEnabled, k2 = ut2.init(this.clippingPlanes, V2, e3), d2 = ct2.get(t3, f2.length), d2.init(), f2.push(d2), Nt2(t3, e3, 0, v2.sortObjects), d2.finish(), true === v2.sortObjects && d2.sort(z2, B2), true === k2 && ut2.beginShadows();
          const n3 = m2.state.shadowsArray;
          if (dt2.render(n3, t3, e3), true === k2 && ut2.endShadows(), true === this.info.autoReset && this.info.reset(), pt2.render(d2, t3), m2.setupLights(v2.physicallyCorrectLights), e3.isArrayCamera) {
            const n4 = e3.cameras;
            for (let e4 = 0, i3 = n4.length; e4 < i3; e4++) {
              const i4 = n4[e4];
              zt2(d2, t3, i4, i4.viewport);
            }
          } else
            zt2(d2, t3, e3);
          null !== T2 && (et2.updateMultisampleRenderTarget(T2), et2.updateRenderTargetMipmap(T2)), true === t3.isScene && t3.onAfterRender(v2, t3, e3), K2.buffers.depth.setTest(true), K2.buffers.depth.setMask(true), K2.buffers.color.setMask(true), K2.setPolygonOffset(false), yt2.resetDefaultState(), A2 = -1, L2 = null, g2.pop(), m2 = g2.length > 0 ? g2[g2.length - 1] : null, f2.pop(), d2 = f2.length > 0 ? f2[f2.length - 1] : null;
        }, this.getActiveCubeFace = function() {
          return b2;
        }, this.getActiveMipmapLevel = function() {
          return S2;
        }, this.getRenderTarget = function() {
          return T2;
        }, this.setRenderTarget = function(t3, e3 = 0, n3 = 0) {
          T2 = t3, b2 = e3, S2 = n3, t3 && void 0 === tt2.get(t3).__webglFramebuffer && et2.setupRenderTarget(t3);
          let i3 = null, r3 = false, s3 = false;
          if (t3) {
            const n4 = t3.texture;
            (n4.isDataTexture3D || n4.isDataTexture2DArray) && (s3 = true);
            const a3 = tt2.get(t3).__webglFramebuffer;
            t3.isWebGLCubeRenderTarget ? (i3 = a3[e3], r3 = true) : i3 = t3.isWebGLMultisampleRenderTarget ? tt2.get(t3).__webglMultisampledFramebuffer : a3, R2.copy(t3.viewport), C2.copy(t3.scissor), P2 = t3.scissorTest;
          } else
            R2.copy(F2).multiplyScalar(N2).floor(), C2.copy(O2).multiplyScalar(N2).floor(), P2 = U2;
          if (K2.bindFramebuffer(36160, i3) && Q2.drawBuffers) {
            let e4 = false;
            if (t3)
              if (t3.isWebGLMultipleRenderTargets) {
                const n4 = t3.texture;
                if (H2.length !== n4.length || 36064 !== H2[0]) {
                  for (let t4 = 0, e5 = n4.length; t4 < e5; t4++)
                    H2[t4] = 36064 + t4;
                  H2.length = n4.length, e4 = true;
                }
              } else
                1 === H2.length && 36064 === H2[0] || (H2[0] = 36064, H2.length = 1, e4 = true);
            else
              1 === H2.length && 1029 === H2[0] || (H2[0] = 1029, H2.length = 1, e4 = true);
            e4 && (Q2.isWebGL2 ? xt2.drawBuffers(H2) : Z2.get("WEBGL_draw_buffers").drawBuffersWEBGL(H2));
          }
          if (K2.viewport(R2), K2.scissor(C2), K2.setScissorTest(P2), r3) {
            const i4 = tt2.get(t3.texture);
            xt2.framebufferTexture2D(36160, 36064, 34069 + e3, i4.__webglTexture, n3);
          } else if (s3) {
            const i4 = tt2.get(t3.texture), r4 = e3 || 0;
            xt2.framebufferTextureLayer(36160, 36064, i4.__webglTexture, n3 || 0, r4);
          }
          A2 = -1;
        }, this.readRenderTargetPixels = function(t3, e3, n3, i3, r3, s3, a3) {
          if (!t3 || !t3.isWebGLRenderTarget)
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          let o4 = tt2.get(t3).__webglFramebuffer;
          if (t3.isWebGLCubeRenderTarget && void 0 !== a3 && (o4 = o4[a3]), o4) {
            K2.bindFramebuffer(36160, o4);
            try {
              const a4 = t3.texture, o5 = a4.format, l3 = a4.type;
              if (o5 !== E && vt2.convert(o5) !== xt2.getParameter(35739))
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              const c3 = l3 === w && (Z2.has("EXT_color_buffer_half_float") || Q2.isWebGL2 && Z2.has("EXT_color_buffer_float"));
              if (!(l3 === x || vt2.convert(l3) === xt2.getParameter(35738) || l3 === M && (Q2.isWebGL2 || Z2.has("OES_texture_float") || Z2.has("WEBGL_color_buffer_float")) || c3))
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              36053 === xt2.checkFramebufferStatus(36160) ? e3 >= 0 && e3 <= t3.width - i3 && n3 >= 0 && n3 <= t3.height - r3 && xt2.readPixels(e3, n3, i3, r3, vt2.convert(o5), vt2.convert(l3), s3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            } finally {
              const t4 = null !== T2 ? tt2.get(T2).__webglFramebuffer : null;
              K2.bindFramebuffer(36160, t4);
            }
          }
        }, this.copyFramebufferToTexture = function(t3, e3, n3 = 0) {
          const i3 = Math.pow(2, -n3), r3 = Math.floor(e3.image.width * i3), s3 = Math.floor(e3.image.height * i3);
          let a3 = vt2.convert(e3.format);
          Q2.isWebGL2 && (6407 === a3 && (a3 = 32849), 6408 === a3 && (a3 = 32856)), et2.setTexture2D(e3, 0), xt2.copyTexImage2D(3553, n3, a3, t3.x, t3.y, r3, s3, 0), K2.unbindTexture();
        }, this.copyTextureToTexture = function(t3, e3, n3, i3 = 0) {
          const r3 = e3.image.width, s3 = e3.image.height, a3 = vt2.convert(n3.format), o4 = vt2.convert(n3.type);
          et2.setTexture2D(n3, 0), xt2.pixelStorei(37440, n3.flipY), xt2.pixelStorei(37441, n3.premultiplyAlpha), xt2.pixelStorei(3317, n3.unpackAlignment), e3.isDataTexture ? xt2.texSubImage2D(3553, i3, t3.x, t3.y, r3, s3, a3, o4, e3.image.data) : e3.isCompressedTexture ? xt2.compressedTexSubImage2D(3553, i3, t3.x, t3.y, e3.mipmaps[0].width, e3.mipmaps[0].height, a3, e3.mipmaps[0].data) : xt2.texSubImage2D(3553, i3, t3.x, t3.y, a3, o4, e3.image), 0 === i3 && n3.generateMipmaps && xt2.generateMipmap(3553), K2.unbindTexture();
        }, this.copyTextureToTexture3D = function(t3, e3, n3, i3, r3 = 0) {
          if (v2.isWebGL1Renderer)
            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
          const s3 = t3.max.x - t3.min.x + 1, a3 = t3.max.y - t3.min.y + 1, o4 = t3.max.z - t3.min.z + 1, l3 = vt2.convert(i3.format), c3 = vt2.convert(i3.type);
          let h3;
          if (i3.isDataTexture3D)
            et2.setTexture3D(i3, 0), h3 = 32879;
          else {
            if (!i3.isDataTexture2DArray)
              return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            et2.setTexture2DArray(i3, 0), h3 = 35866;
          }
          xt2.pixelStorei(37440, i3.flipY), xt2.pixelStorei(37441, i3.premultiplyAlpha), xt2.pixelStorei(3317, i3.unpackAlignment);
          const u2 = xt2.getParameter(3314), d3 = xt2.getParameter(32878), p2 = xt2.getParameter(3316), m3 = xt2.getParameter(3315), f3 = xt2.getParameter(32877), g3 = n3.isCompressedTexture ? n3.mipmaps[0] : n3.image;
          xt2.pixelStorei(3314, g3.width), xt2.pixelStorei(32878, g3.height), xt2.pixelStorei(3316, t3.min.x), xt2.pixelStorei(3315, t3.min.y), xt2.pixelStorei(32877, t3.min.z), n3.isDataTexture || n3.isDataTexture3D ? xt2.texSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, a3, o4, l3, c3, g3.data) : n3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), xt2.compressedTexSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, a3, o4, l3, g3.data)) : xt2.texSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, a3, o4, l3, c3, g3), xt2.pixelStorei(3314, u2), xt2.pixelStorei(32878, d3), xt2.pixelStorei(3316, p2), xt2.pixelStorei(3315, m3), xt2.pixelStorei(32877, f3), 0 === r3 && i3.generateMipmaps && xt2.generateMipmap(h3), K2.unbindTexture();
        }, this.initTexture = function(t3) {
          et2.setTexture2D(t3, 0), K2.unbindTexture();
        }, this.resetState = function() {
          b2 = 0, S2 = 0, T2 = null, K2.reset(), yt2.reset();
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
      class Ys extends Xs {
      }
      Ys.prototype.isWebGL1Renderer = true;
      class Js {
        constructor(t2, e2 = 25e-5) {
          this.name = "", this.color = new Qe(t2), this.density = e2;
        }
        clone() {
          return new Js(this.color, this.density);
        }
        toJSON() {
          return { type: "FogExp2", color: this.color.getHex(), density: this.density };
        }
      }
      Js.prototype.isFogExp2 = true;
      class Zs {
        constructor(t2, e2 = 1, n2 = 1e3) {
          this.name = "", this.color = new Qe(t2), this.near = e2, this.far = n2;
        }
        clone() {
          return new Zs(this.color, this.near, this.far);
        }
        toJSON() {
          return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
        }
      }
      Zs.prototype.isFog = true;
      class Qs extends Pe {
        constructor() {
          super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        copy(t2, e2) {
          return super.copy(t2, e2), null !== t2.background && (this.background = t2.background.clone()), null !== t2.environment && (this.environment = t2.environment.clone()), null !== t2.fog && (this.fog = t2.fog.clone()), null !== t2.overrideMaterial && (this.overrideMaterial = t2.overrideMaterial.clone()), this.autoUpdate = t2.autoUpdate, this.matrixAutoUpdate = t2.matrixAutoUpdate, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return null !== this.fog && (e2.object.fog = this.fog.toJSON()), e2;
        }
      }
      Qs.prototype.isScene = true;
      class Ks {
        constructor(t2, e2) {
          this.array = t2, this.stride = e2, this.count = void 0 !== t2 ? t2.length / e2 : 0, this.usage = et, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = ct();
        }
        onUploadCallback() {
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
        setUsage(t2) {
          return this.usage = t2, this;
        }
        copy(t2) {
          return this.array = new t2.array.constructor(t2.array), this.count = t2.count, this.stride = t2.stride, this.usage = t2.usage, this;
        }
        copyAt(t2, e2, n2) {
          t2 *= this.stride, n2 *= e2.stride;
          for (let i2 = 0, r2 = this.stride; i2 < r2; i2++)
            this.array[t2 + i2] = e2.array[n2 + i2];
          return this;
        }
        set(t2, e2 = 0) {
          return this.array.set(t2, e2), this;
        }
        clone(t2) {
          void 0 === t2.arrayBuffers && (t2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ct()), void 0 === t2.arrayBuffers[this.array.buffer._uuid] && (t2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const e2 = new this.array.constructor(t2.arrayBuffers[this.array.buffer._uuid]), n2 = new this.constructor(e2, this.stride);
          return n2.setUsage(this.usage), n2;
        }
        onUpload(t2) {
          return this.onUploadCallback = t2, this;
        }
        toJSON(t2) {
          return void 0 === t2.arrayBuffers && (t2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ct()), void 0 === t2.arrayBuffers[this.array.buffer._uuid] && (t2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
        }
      }
      Ks.prototype.isInterleavedBuffer = true;
      const $s = new Rt();
      class ta {
        constructor(t2, e2, n2, i2 = false) {
          this.name = "", this.data = t2, this.itemSize = e2, this.offset = n2, this.normalized = true === i2;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(t2) {
          this.data.needsUpdate = t2;
        }
        applyMatrix4(t2) {
          for (let e2 = 0, n2 = this.data.count; e2 < n2; e2++)
            $s.x = this.getX(e2), $s.y = this.getY(e2), $s.z = this.getZ(e2), $s.applyMatrix4(t2), this.setXYZ(e2, $s.x, $s.y, $s.z);
          return this;
        }
        applyNormalMatrix(t2) {
          for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
            $s.x = this.getX(e2), $s.y = this.getY(e2), $s.z = this.getZ(e2), $s.applyNormalMatrix(t2), this.setXYZ(e2, $s.x, $s.y, $s.z);
          return this;
        }
        transformDirection(t2) {
          for (let e2 = 0, n2 = this.count; e2 < n2; e2++)
            $s.x = this.getX(e2), $s.y = this.getY(e2), $s.z = this.getZ(e2), $s.transformDirection(t2), this.setXYZ(e2, $s.x, $s.y, $s.z);
          return this;
        }
        setX(t2, e2) {
          return this.data.array[t2 * this.data.stride + this.offset] = e2, this;
        }
        setY(t2, e2) {
          return this.data.array[t2 * this.data.stride + this.offset + 1] = e2, this;
        }
        setZ(t2, e2) {
          return this.data.array[t2 * this.data.stride + this.offset + 2] = e2, this;
        }
        setW(t2, e2) {
          return this.data.array[t2 * this.data.stride + this.offset + 3] = e2, this;
        }
        getX(t2) {
          return this.data.array[t2 * this.data.stride + this.offset];
        }
        getY(t2) {
          return this.data.array[t2 * this.data.stride + this.offset + 1];
        }
        getZ(t2) {
          return this.data.array[t2 * this.data.stride + this.offset + 2];
        }
        getW(t2) {
          return this.data.array[t2 * this.data.stride + this.offset + 3];
        }
        setXY(t2, e2, n2) {
          return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this;
        }
        setXYZ(t2, e2, n2, i2) {
          return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this.data.array[t2 + 2] = i2, this;
        }
        setXYZW(t2, e2, n2, i2, r2) {
          return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = n2, this.data.array[t2 + 2] = i2, this.data.array[t2 + 3] = r2, this;
        }
        clone(t2) {
          if (void 0 === t2) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const t3 = [];
            for (let e2 = 0; e2 < this.count; e2++) {
              const n2 = e2 * this.data.stride + this.offset;
              for (let e3 = 0; e3 < this.itemSize; e3++)
                t3.push(this.data.array[n2 + e3]);
            }
            return new en(new this.array.constructor(t3), this.itemSize, this.normalized);
          }
          return void 0 === t2.interleavedBuffers && (t2.interleavedBuffers = {}), void 0 === t2.interleavedBuffers[this.data.uuid] && (t2.interleavedBuffers[this.data.uuid] = this.data.clone(t2)), new ta(t2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(t2) {
          if (void 0 === t2) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const t3 = [];
            for (let e2 = 0; e2 < this.count; e2++) {
              const n2 = e2 * this.data.stride + this.offset;
              for (let e3 = 0; e3 < this.itemSize; e3++)
                t3.push(this.data.array[n2 + e3]);
            }
            return { itemSize: this.itemSize, type: this.array.constructor.name, array: t3, normalized: this.normalized };
          }
          return void 0 === t2.interleavedBuffers && (t2.interleavedBuffers = {}), void 0 === t2.interleavedBuffers[this.data.uuid] && (t2.interleavedBuffers[this.data.uuid] = this.data.toJSON(t2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
        }
      }
      ta.prototype.isInterleavedBufferAttribute = true;
      class ea extends We {
        constructor(t2) {
          super(), this.type = "SpriteMaterial", this.color = new Qe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.rotation = t2.rotation, this.sizeAttenuation = t2.sizeAttenuation, this;
        }
      }
      let na;
      ea.prototype.isSpriteMaterial = true;
      const ia = new Rt(), ra = new Rt(), sa = new Rt(), aa = new vt(), oa = new vt(), la = new ae(), ca = new Rt(), ha = new Rt(), ua = new Rt(), da = new vt(), pa = new vt(), ma = new vt();
      class fa extends Pe {
        constructor(t2) {
          if (super(), this.type = "Sprite", void 0 === na) {
            na = new wn();
            const t3 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e2 = new Ks(t3, 5);
            na.setIndex([0, 1, 2, 0, 2, 3]), na.setAttribute("position", new ta(e2, 3, 0, false)), na.setAttribute("uv", new ta(e2, 2, 3, false));
          }
          this.geometry = na, this.material = void 0 !== t2 ? t2 : new ea(), this.center = new vt(0.5, 0.5);
        }
        raycast(t2, e2) {
          null === t2.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ra.setFromMatrixScale(this.matrixWorld), la.copy(t2.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t2.camera.matrixWorldInverse, this.matrixWorld), sa.setFromMatrixPosition(this.modelViewMatrix), t2.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && ra.multiplyScalar(-sa.z);
          const n2 = this.material.rotation;
          let i2, r2;
          0 !== n2 && (r2 = Math.cos(n2), i2 = Math.sin(n2));
          const s2 = this.center;
          ga(ca.set(-0.5, -0.5, 0), sa, s2, ra, i2, r2), ga(ha.set(0.5, -0.5, 0), sa, s2, ra, i2, r2), ga(ua.set(0.5, 0.5, 0), sa, s2, ra, i2, r2), da.set(0, 0), pa.set(1, 0), ma.set(1, 1);
          let a2 = t2.ray.intersectTriangle(ca, ha, ua, false, ia);
          if (null === a2 && (ga(ha.set(-0.5, 0.5, 0), sa, s2, ra, i2, r2), pa.set(0, 1), a2 = t2.ray.intersectTriangle(ca, ua, ha, false, ia), null === a2))
            return;
          const o3 = t2.ray.origin.distanceTo(ia);
          o3 < t2.near || o3 > t2.far || e2.push({ distance: o3, point: ia.clone(), uv: ke.getUV(ia, ca, ha, ua, da, pa, ma, new vt()), face: null, object: this });
        }
        copy(t2) {
          return super.copy(t2), void 0 !== t2.center && this.center.copy(t2.center), this.material = t2.material, this;
        }
      }
      function ga(t2, e2, n2, i2, r2, s2) {
        aa.subVectors(t2, n2).addScalar(0.5).multiply(i2), void 0 !== r2 ? (oa.x = s2 * aa.x - r2 * aa.y, oa.y = r2 * aa.x + s2 * aa.y) : oa.copy(aa), t2.copy(e2), t2.x += oa.x, t2.y += oa.y, t2.applyMatrix4(la);
      }
      fa.prototype.isSprite = true;
      const va = new Rt(), ya = new Rt();
      class xa extends Pe {
        constructor() {
          super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
        }
        copy(t2) {
          super.copy(t2, false);
          const e2 = t2.levels;
          for (let t3 = 0, n2 = e2.length; t3 < n2; t3++) {
            const n3 = e2[t3];
            this.addLevel(n3.object.clone(), n3.distance);
          }
          return this.autoUpdate = t2.autoUpdate, this;
        }
        addLevel(t2, e2 = 0) {
          e2 = Math.abs(e2);
          const n2 = this.levels;
          let i2;
          for (i2 = 0; i2 < n2.length && !(e2 < n2[i2].distance); i2++)
            ;
          return n2.splice(i2, 0, { distance: e2, object: t2 }), this.add(t2), this;
        }
        getCurrentLevel() {
          return this._currentLevel;
        }
        getObjectForDistance(t2) {
          const e2 = this.levels;
          if (e2.length > 0) {
            let n2, i2;
            for (n2 = 1, i2 = e2.length; n2 < i2 && !(t2 < e2[n2].distance); n2++)
              ;
            return e2[n2 - 1].object;
          }
          return null;
        }
        raycast(t2, e2) {
          if (this.levels.length > 0) {
            va.setFromMatrixPosition(this.matrixWorld);
            const n2 = t2.ray.origin.distanceTo(va);
            this.getObjectForDistance(n2).raycast(t2, e2);
          }
        }
        update(t2) {
          const e2 = this.levels;
          if (e2.length > 1) {
            va.setFromMatrixPosition(t2.matrixWorld), ya.setFromMatrixPosition(this.matrixWorld);
            const n2 = va.distanceTo(ya) / t2.zoom;
            let i2, r2;
            for (e2[0].object.visible = true, i2 = 1, r2 = e2.length; i2 < r2 && n2 >= e2[i2].distance; i2++)
              e2[i2 - 1].object.visible = false, e2[i2].object.visible = true;
            for (this._currentLevel = i2 - 1; i2 < r2; i2++)
              e2[i2].object.visible = false;
          }
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          false === this.autoUpdate && (e2.object.autoUpdate = false), e2.object.levels = [];
          const n2 = this.levels;
          for (let t3 = 0, i2 = n2.length; t3 < i2; t3++) {
            const i3 = n2[t3];
            e2.object.levels.push({ object: i3.object.uuid, distance: i3.distance });
          }
          return e2;
        }
      }
      const _a = new Rt(), ba = new St(), Ma = new St(), wa = new Rt(), Sa = new ae();
      class Ta extends Gn {
        constructor(t2, e2) {
          super(t2, e2), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ae(), this.bindMatrixInverse = new ae();
        }
        copy(t2) {
          return super.copy(t2), this.bindMode = t2.bindMode, this.bindMatrix.copy(t2.bindMatrix), this.bindMatrixInverse.copy(t2.bindMatrixInverse), this.skeleton = t2.skeleton, this;
        }
        bind(t2, e2) {
          this.skeleton = t2, void 0 === e2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e2 = this.matrixWorld), this.bindMatrix.copy(e2), this.bindMatrixInverse.copy(e2).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const t2 = new St(), e2 = this.geometry.attributes.skinWeight;
          for (let n2 = 0, i2 = e2.count; n2 < i2; n2++) {
            t2.x = e2.getX(n2), t2.y = e2.getY(n2), t2.z = e2.getZ(n2), t2.w = e2.getW(n2);
            const i3 = 1 / t2.manhattanLength();
            i3 !== 1 / 0 ? t2.multiplyScalar(i3) : t2.set(1, 0, 0, 0), e2.setXYZW(n2, t2.x, t2.y, t2.z, t2.w);
          }
        }
        updateMatrixWorld(t2) {
          super.updateMatrixWorld(t2), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        boneTransform(t2, e2) {
          const n2 = this.skeleton, i2 = this.geometry;
          ba.fromBufferAttribute(i2.attributes.skinIndex, t2), Ma.fromBufferAttribute(i2.attributes.skinWeight, t2), _a.fromBufferAttribute(i2.attributes.position, t2).applyMatrix4(this.bindMatrix), e2.set(0, 0, 0);
          for (let t3 = 0; t3 < 4; t3++) {
            const i3 = Ma.getComponent(t3);
            if (0 !== i3) {
              const r2 = ba.getComponent(t3);
              Sa.multiplyMatrices(n2.bones[r2].matrixWorld, n2.boneInverses[r2]), e2.addScaledVector(wa.copy(_a).applyMatrix4(Sa), i3);
            }
          }
          return e2.applyMatrix4(this.bindMatrixInverse);
        }
      }
      Ta.prototype.isSkinnedMesh = true;
      class Ea extends Pe {
        constructor() {
          super(), this.type = "Bone";
        }
      }
      Ea.prototype.isBone = true;
      class Aa extends Mt {
        constructor(t2 = null, e2 = 1, n2 = 1, i2, r2, s2, a2, o3, l2 = 1003, c2 = 1003, h2, u2) {
          super(null, s2, a2, o3, l2, c2, i2, r2, h2, u2), this.image = { data: t2, width: e2, height: n2 }, this.magFilter = l2, this.minFilter = c2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
        }
      }
      Aa.prototype.isDataTexture = true;
      const La = new ae(), Ra = new ae();
      class Ca {
        constructor(t2 = [], e2 = []) {
          this.uuid = ct(), this.bones = t2.slice(0), this.boneInverses = e2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
        }
        init() {
          const t2 = this.bones, e2 = this.boneInverses;
          if (this.boneMatrices = new Float32Array(16 * t2.length), 0 === e2.length)
            this.calculateInverses();
          else if (t2.length !== e2.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let t3 = 0, e3 = this.bones.length; t3 < e3; t3++)
              this.boneInverses.push(new ae());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
            const e3 = new ae();
            this.bones[t2] && e3.copy(this.bones[t2].matrixWorld).invert(), this.boneInverses.push(e3);
          }
        }
        pose() {
          for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
            const e3 = this.bones[t2];
            e3 && e3.matrixWorld.copy(this.boneInverses[t2]).invert();
          }
          for (let t2 = 0, e2 = this.bones.length; t2 < e2; t2++) {
            const e3 = this.bones[t2];
            e3 && (e3.parent && e3.parent.isBone ? (e3.matrix.copy(e3.parent.matrixWorld).invert(), e3.matrix.multiply(e3.matrixWorld)) : e3.matrix.copy(e3.matrixWorld), e3.matrix.decompose(e3.position, e3.quaternion, e3.scale));
          }
        }
        update() {
          const t2 = this.bones, e2 = this.boneInverses, n2 = this.boneMatrices, i2 = this.boneTexture;
          for (let i3 = 0, r2 = t2.length; i3 < r2; i3++) {
            const r3 = t2[i3] ? t2[i3].matrixWorld : Ra;
            La.multiplyMatrices(r3, e2[i3]), La.toArray(n2, 16 * i3);
          }
          null !== i2 && (i2.needsUpdate = true);
        }
        clone() {
          return new Ca(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let t2 = Math.sqrt(4 * this.bones.length);
          t2 = mt(t2), t2 = Math.max(t2, 4);
          const e2 = new Float32Array(t2 * t2 * 4);
          e2.set(this.boneMatrices);
          const n2 = new Aa(e2, t2, t2, E, M);
          return this.boneMatrices = e2, this.boneTexture = n2, this.boneTextureSize = t2, this;
        }
        getBoneByName(t2) {
          for (let e2 = 0, n2 = this.bones.length; e2 < n2; e2++) {
            const n3 = this.bones[e2];
            if (n3.name === t2)
              return n3;
          }
        }
        dispose() {
          null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(t2, e2) {
          this.uuid = t2.uuid;
          for (let n2 = 0, i2 = t2.bones.length; n2 < i2; n2++) {
            const i3 = t2.bones[n2];
            let r2 = e2[i3];
            void 0 === r2 && (console.warn("THREE.Skeleton: No bone found with UUID:", i3), r2 = new Ea()), this.bones.push(r2), this.boneInverses.push(new ae().fromArray(t2.boneInverses[n2]));
          }
          return this.init(), this;
        }
        toJSON() {
          const t2 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
          t2.uuid = this.uuid;
          const e2 = this.bones, n2 = this.boneInverses;
          for (let i2 = 0, r2 = e2.length; i2 < r2; i2++) {
            const r3 = e2[i2];
            t2.bones.push(r3.uuid);
            const s2 = n2[i2];
            t2.boneInverses.push(s2.toArray());
          }
          return t2;
        }
      }
      class Pa extends en {
        constructor(t2, e2, n2, i2 = 1) {
          "number" == typeof n2 && (i2 = n2, n2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t2, e2, n2), this.meshPerAttribute = i2;
        }
        copy(t2) {
          return super.copy(t2), this.meshPerAttribute = t2.meshPerAttribute, this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.meshPerAttribute = this.meshPerAttribute, t2.isInstancedBufferAttribute = true, t2;
        }
      }
      Pa.prototype.isInstancedBufferAttribute = true;
      const Ia = new ae(), Da = new ae(), Na = [], za = new Gn();
      class Ba extends Gn {
        constructor(t2, e2, n2) {
          super(t2, e2), this.instanceMatrix = new Pa(new Float32Array(16 * n2), 16), this.instanceColor = null, this.count = n2, this.frustumCulled = false;
        }
        copy(t2) {
          return super.copy(t2), this.instanceMatrix.copy(t2.instanceMatrix), null !== t2.instanceColor && (this.instanceColor = t2.instanceColor.clone()), this.count = t2.count, this;
        }
        getColorAt(t2, e2) {
          e2.fromArray(this.instanceColor.array, 3 * t2);
        }
        getMatrixAt(t2, e2) {
          e2.fromArray(this.instanceMatrix.array, 16 * t2);
        }
        raycast(t2, e2) {
          const n2 = this.matrixWorld, i2 = this.count;
          if (za.geometry = this.geometry, za.material = this.material, void 0 !== za.material)
            for (let r2 = 0; r2 < i2; r2++) {
              this.getMatrixAt(r2, Ia), Da.multiplyMatrices(n2, Ia), za.matrixWorld = Da, za.raycast(t2, Na);
              for (let t3 = 0, n3 = Na.length; t3 < n3; t3++) {
                const n4 = Na[t3];
                n4.instanceId = r2, n4.object = this, e2.push(n4);
              }
              Na.length = 0;
            }
        }
        setColorAt(t2, e2) {
          null === this.instanceColor && (this.instanceColor = new Pa(new Float32Array(3 * this.instanceMatrix.count), 3)), e2.toArray(this.instanceColor.array, 3 * t2);
        }
        setMatrixAt(t2, e2) {
          e2.toArray(this.instanceMatrix.array, 16 * t2);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Ba.prototype.isInstancedMesh = true;
      class Fa extends We {
        constructor(t2) {
          super(), this.type = "LineBasicMaterial", this.color = new Qe(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.linewidth = t2.linewidth, this.linecap = t2.linecap, this.linejoin = t2.linejoin, this;
        }
      }
      Fa.prototype.isLineBasicMaterial = true;
      const Oa = new Rt(), Ua = new Rt(), Ha = new ae(), Ga = new se(), ka = new Qt();
      class Va extends Pe {
        constructor(t2 = new wn(), e2 = new Fa()) {
          super(), this.type = "Line", this.geometry = t2, this.material = e2, this.updateMorphTargets();
        }
        copy(t2) {
          return super.copy(t2), this.material = t2.material, this.geometry = t2.geometry, this;
        }
        computeLineDistances() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry)
            if (null === t2.index) {
              const e2 = t2.attributes.position, n2 = [0];
              for (let t3 = 1, i2 = e2.count; t3 < i2; t3++)
                Oa.fromBufferAttribute(e2, t3 - 1), Ua.fromBufferAttribute(e2, t3), n2[t3] = n2[t3 - 1], n2[t3] += Oa.distanceTo(Ua);
              t2.setAttribute("lineDistance", new un(n2, 1));
            } else
              console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          else
            t2.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          return this;
        }
        raycast(t2, e2) {
          const n2 = this.geometry, i2 = this.matrixWorld, r2 = t2.params.Line.threshold, s2 = n2.drawRange;
          if (null === n2.boundingSphere && n2.computeBoundingSphere(), ka.copy(n2.boundingSphere), ka.applyMatrix4(i2), ka.radius += r2, false === t2.ray.intersectsSphere(ka))
            return;
          Ha.copy(i2).invert(), Ga.copy(t2.ray).applyMatrix4(Ha);
          const a2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o3 = a2 * a2, l2 = new Rt(), c2 = new Rt(), h2 = new Rt(), u2 = new Rt(), d2 = this.isLineSegments ? 2 : 1;
          if (n2.isBufferGeometry) {
            const i3 = n2.index, r3 = n2.attributes.position;
            if (null !== i3) {
              for (let n3 = Math.max(0, s2.start), a3 = Math.min(i3.count, s2.start + s2.count) - 1; n3 < a3; n3 += d2) {
                const s3 = i3.getX(n3), a4 = i3.getX(n3 + 1);
                l2.fromBufferAttribute(r3, s3), c2.fromBufferAttribute(r3, a4);
                if (Ga.distanceSqToSegment(l2, c2, u2, h2) > o3)
                  continue;
                u2.applyMatrix4(this.matrixWorld);
                const d3 = t2.ray.origin.distanceTo(u2);
                d3 < t2.near || d3 > t2.far || e2.push({ distance: d3, point: h2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
              }
            } else {
              for (let n3 = Math.max(0, s2.start), i4 = Math.min(r3.count, s2.start + s2.count) - 1; n3 < i4; n3 += d2) {
                l2.fromBufferAttribute(r3, n3), c2.fromBufferAttribute(r3, n3 + 1);
                if (Ga.distanceSqToSegment(l2, c2, u2, h2) > o3)
                  continue;
                u2.applyMatrix4(this.matrixWorld);
                const i5 = t2.ray.origin.distanceTo(u2);
                i5 < t2.near || i5 > t2.far || e2.push({ distance: i5, point: h2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
              }
            }
          } else
            n2.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        updateMorphTargets() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry) {
            const e2 = t2.morphAttributes, n2 = Object.keys(e2);
            if (n2.length > 0) {
              const t3 = e2[n2[0]];
              if (void 0 !== t3) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
                  const n4 = t3[e3].name || String(e3);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
                }
              }
            }
          } else {
            const e2 = t2.morphTargets;
            void 0 !== e2 && e2.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
      Va.prototype.isLine = true;
      const Wa = new Rt(), ja = new Rt();
      class qa extends Va {
        constructor(t2, e2) {
          super(t2, e2), this.type = "LineSegments";
        }
        computeLineDistances() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry)
            if (null === t2.index) {
              const e2 = t2.attributes.position, n2 = [];
              for (let t3 = 0, i2 = e2.count; t3 < i2; t3 += 2)
                Wa.fromBufferAttribute(e2, t3), ja.fromBufferAttribute(e2, t3 + 1), n2[t3] = 0 === t3 ? 0 : n2[t3 - 1], n2[t3 + 1] = n2[t3] + Wa.distanceTo(ja);
              t2.setAttribute("lineDistance", new un(n2, 1));
            } else
              console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          else
            t2.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          return this;
        }
      }
      qa.prototype.isLineSegments = true;
      class Xa extends Va {
        constructor(t2, e2) {
          super(t2, e2), this.type = "LineLoop";
        }
      }
      Xa.prototype.isLineLoop = true;
      class Ya extends We {
        constructor(t2) {
          super(), this.type = "PointsMaterial", this.color = new Qe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.size = t2.size, this.sizeAttenuation = t2.sizeAttenuation, this;
        }
      }
      Ya.prototype.isPointsMaterial = true;
      const Ja = new ae(), Za = new se(), Qa = new Qt(), Ka = new Rt();
      class $a extends Pe {
        constructor(t2 = new wn(), e2 = new Ya()) {
          super(), this.type = "Points", this.geometry = t2, this.material = e2, this.updateMorphTargets();
        }
        copy(t2) {
          return super.copy(t2), this.material = t2.material, this.geometry = t2.geometry, this;
        }
        raycast(t2, e2) {
          const n2 = this.geometry, i2 = this.matrixWorld, r2 = t2.params.Points.threshold, s2 = n2.drawRange;
          if (null === n2.boundingSphere && n2.computeBoundingSphere(), Qa.copy(n2.boundingSphere), Qa.applyMatrix4(i2), Qa.radius += r2, false === t2.ray.intersectsSphere(Qa))
            return;
          Ja.copy(i2).invert(), Za.copy(t2.ray).applyMatrix4(Ja);
          const a2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o3 = a2 * a2;
          if (n2.isBufferGeometry) {
            const r3 = n2.index, a3 = n2.attributes.position;
            if (null !== r3) {
              for (let n3 = Math.max(0, s2.start), l2 = Math.min(r3.count, s2.start + s2.count); n3 < l2; n3++) {
                const s3 = r3.getX(n3);
                Ka.fromBufferAttribute(a3, s3), to(Ka, s3, o3, i2, t2, e2, this);
              }
            } else {
              for (let n3 = Math.max(0, s2.start), r4 = Math.min(a3.count, s2.start + s2.count); n3 < r4; n3++)
                Ka.fromBufferAttribute(a3, n3), to(Ka, n3, o3, i2, t2, e2, this);
            }
          } else
            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        updateMorphTargets() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry) {
            const e2 = t2.morphAttributes, n2 = Object.keys(e2);
            if (n2.length > 0) {
              const t3 = e2[n2[0]];
              if (void 0 !== t3) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let e3 = 0, n3 = t3.length; e3 < n3; e3++) {
                  const n4 = t3[e3].name || String(e3);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = e3;
                }
              }
            }
          } else {
            const e2 = t2.morphTargets;
            void 0 !== e2 && e2.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
      function to(t2, e2, n2, i2, r2, s2, a2) {
        const o3 = Za.distanceSqToPoint(t2);
        if (o3 < n2) {
          const n3 = new Rt();
          Za.closestPointToPoint(t2, n3), n3.applyMatrix4(i2);
          const l2 = r2.ray.origin.distanceTo(n3);
          if (l2 < r2.near || l2 > r2.far)
            return;
          s2.push({ distance: l2, distanceToRay: Math.sqrt(o3), point: n3, index: e2, face: null, object: a2 });
        }
      }
      $a.prototype.isPoints = true;
      class eo extends Mt {
        constructor(t2, e2, n2, i2, r2, s2, a2, o3, l2) {
          super(t2, e2, n2, i2, r2, s2, a2, o3, l2), this.format = void 0 !== a2 ? a2 : T, this.minFilter = void 0 !== s2 ? s2 : g, this.magFilter = void 0 !== r2 ? r2 : g, this.generateMipmaps = false;
          const c2 = this;
          "requestVideoFrameCallback" in t2 && t2.requestVideoFrameCallback(function e3() {
            c2.needsUpdate = true, t2.requestVideoFrameCallback(e3);
          });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const t2 = this.image;
          false === "requestVideoFrameCallback" in t2 && t2.readyState >= t2.HAVE_CURRENT_DATA && (this.needsUpdate = true);
        }
      }
      eo.prototype.isVideoTexture = true;
      class no extends Mt {
        constructor(t2, e2, n2, i2, r2, s2, a2, o3, l2, c2, h2, u2) {
          super(null, s2, a2, o3, l2, c2, i2, r2, h2, u2), this.image = { width: e2, height: n2 }, this.mipmaps = t2, this.flipY = false, this.generateMipmaps = false;
        }
      }
      no.prototype.isCompressedTexture = true;
      class io extends Mt {
        constructor(t2, e2, n2, i2, r2, s2, a2, o3, l2) {
          super(t2, e2, n2, i2, r2, s2, a2, o3, l2), this.needsUpdate = true;
        }
      }
      io.prototype.isCanvasTexture = true;
      class ro extends Mt {
        constructor(t2, e2, n2, i2, r2, s2, a2, o3, l2, c2) {
          if ((c2 = void 0 !== c2 ? c2 : A) !== A && c2 !== L)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          void 0 === n2 && c2 === A && (n2 = _), void 0 === n2 && c2 === L && (n2 = S), super(null, i2, r2, s2, a2, o3, c2, n2, l2), this.image = { width: t2, height: e2 }, this.magFilter = void 0 !== a2 ? a2 : p, this.minFilter = void 0 !== o3 ? o3 : p, this.flipY = false, this.generateMipmaps = false;
        }
      }
      ro.prototype.isDepthTexture = true;
      class so extends wn {
        constructor(t2 = 1, e2 = 8, n2 = 0, i2 = 2 * Math.PI) {
          super(), this.type = "CircleGeometry", this.parameters = { radius: t2, segments: e2, thetaStart: n2, thetaLength: i2 }, e2 = Math.max(3, e2);
          const r2 = [], s2 = [], a2 = [], o3 = [], l2 = new Rt(), c2 = new vt();
          s2.push(0, 0, 0), a2.push(0, 0, 1), o3.push(0.5, 0.5);
          for (let r3 = 0, h2 = 3; r3 <= e2; r3++, h2 += 3) {
            const u2 = n2 + r3 / e2 * i2;
            l2.x = t2 * Math.cos(u2), l2.y = t2 * Math.sin(u2), s2.push(l2.x, l2.y, l2.z), a2.push(0, 0, 1), c2.x = (s2[h2] / t2 + 1) / 2, c2.y = (s2[h2 + 1] / t2 + 1) / 2, o3.push(c2.x, c2.y);
          }
          for (let t3 = 1; t3 <= e2; t3++)
            r2.push(t3, t3 + 1, 0);
          this.setIndex(r2), this.setAttribute("position", new un(s2, 3)), this.setAttribute("normal", new un(a2, 3)), this.setAttribute("uv", new un(o3, 2));
        }
        static fromJSON(t2) {
          return new so(t2.radius, t2.segments, t2.thetaStart, t2.thetaLength);
        }
      }
      class ao extends wn {
        constructor(t2 = 1, e2 = 1, n2 = 1, i2 = 8, r2 = 1, s2 = false, a2 = 0, o3 = 2 * Math.PI) {
          super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t2, radiusBottom: e2, height: n2, radialSegments: i2, heightSegments: r2, openEnded: s2, thetaStart: a2, thetaLength: o3 };
          const l2 = this;
          i2 = Math.floor(i2), r2 = Math.floor(r2);
          const c2 = [], h2 = [], u2 = [], d2 = [];
          let p2 = 0;
          const m2 = [], f2 = n2 / 2;
          let g2 = 0;
          function v2(n3) {
            const r3 = p2, s3 = new vt(), m3 = new Rt();
            let v3 = 0;
            const y2 = true === n3 ? t2 : e2, x2 = true === n3 ? 1 : -1;
            for (let t3 = 1; t3 <= i2; t3++)
              h2.push(0, f2 * x2, 0), u2.push(0, x2, 0), d2.push(0.5, 0.5), p2++;
            const _2 = p2;
            for (let t3 = 0; t3 <= i2; t3++) {
              const e3 = t3 / i2 * o3 + a2, n4 = Math.cos(e3), r4 = Math.sin(e3);
              m3.x = y2 * r4, m3.y = f2 * x2, m3.z = y2 * n4, h2.push(m3.x, m3.y, m3.z), u2.push(0, x2, 0), s3.x = 0.5 * n4 + 0.5, s3.y = 0.5 * r4 * x2 + 0.5, d2.push(s3.x, s3.y), p2++;
            }
            for (let t3 = 0; t3 < i2; t3++) {
              const e3 = r3 + t3, i3 = _2 + t3;
              true === n3 ? c2.push(i3, i3 + 1, e3) : c2.push(i3 + 1, i3, e3), v3 += 3;
            }
            l2.addGroup(g2, v3, true === n3 ? 1 : 2), g2 += v3;
          }
          !function() {
            const s3 = new Rt(), v3 = new Rt();
            let y2 = 0;
            const x2 = (e2 - t2) / n2;
            for (let l3 = 0; l3 <= r2; l3++) {
              const c3 = [], g3 = l3 / r2, y3 = g3 * (e2 - t2) + t2;
              for (let t3 = 0; t3 <= i2; t3++) {
                const e3 = t3 / i2, r3 = e3 * o3 + a2, l4 = Math.sin(r3), m3 = Math.cos(r3);
                v3.x = y3 * l4, v3.y = -g3 * n2 + f2, v3.z = y3 * m3, h2.push(v3.x, v3.y, v3.z), s3.set(l4, x2, m3).normalize(), u2.push(s3.x, s3.y, s3.z), d2.push(e3, 1 - g3), c3.push(p2++);
              }
              m2.push(c3);
            }
            for (let t3 = 0; t3 < i2; t3++)
              for (let e3 = 0; e3 < r2; e3++) {
                const n3 = m2[e3][t3], i3 = m2[e3 + 1][t3], r3 = m2[e3 + 1][t3 + 1], s4 = m2[e3][t3 + 1];
                c2.push(n3, i3, s4), c2.push(i3, r3, s4), y2 += 6;
              }
            l2.addGroup(g2, y2, 0), g2 += y2;
          }(), false === s2 && (t2 > 0 && v2(true), e2 > 0 && v2(false)), this.setIndex(c2), this.setAttribute("position", new un(h2, 3)), this.setAttribute("normal", new un(u2, 3)), this.setAttribute("uv", new un(d2, 2));
        }
        static fromJSON(t2) {
          return new ao(t2.radiusTop, t2.radiusBottom, t2.height, t2.radialSegments, t2.heightSegments, t2.openEnded, t2.thetaStart, t2.thetaLength);
        }
      }
      class oo extends ao {
        constructor(t2 = 1, e2 = 1, n2 = 8, i2 = 1, r2 = false, s2 = 0, a2 = 2 * Math.PI) {
          super(0, t2, e2, n2, i2, r2, s2, a2), this.type = "ConeGeometry", this.parameters = { radius: t2, height: e2, radialSegments: n2, heightSegments: i2, openEnded: r2, thetaStart: s2, thetaLength: a2 };
        }
        static fromJSON(t2) {
          return new oo(t2.radius, t2.height, t2.radialSegments, t2.heightSegments, t2.openEnded, t2.thetaStart, t2.thetaLength);
        }
      }
      class lo extends wn {
        constructor(t2, e2, n2 = 1, i2 = 0) {
          super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t2, indices: e2, radius: n2, detail: i2 };
          const r2 = [], s2 = [];
          function a2(t3, e3, n3, i3) {
            const r3 = i3 + 1, s3 = [];
            for (let i4 = 0; i4 <= r3; i4++) {
              s3[i4] = [];
              const a3 = t3.clone().lerp(n3, i4 / r3), o4 = e3.clone().lerp(n3, i4 / r3), l3 = r3 - i4;
              for (let t4 = 0; t4 <= l3; t4++)
                s3[i4][t4] = 0 === t4 && i4 === r3 ? a3 : a3.clone().lerp(o4, t4 / l3);
            }
            for (let t4 = 0; t4 < r3; t4++)
              for (let e4 = 0; e4 < 2 * (r3 - t4) - 1; e4++) {
                const n4 = Math.floor(e4 / 2);
                e4 % 2 == 0 ? (o3(s3[t4][n4 + 1]), o3(s3[t4 + 1][n4]), o3(s3[t4][n4])) : (o3(s3[t4][n4 + 1]), o3(s3[t4 + 1][n4 + 1]), o3(s3[t4 + 1][n4]));
              }
          }
          function o3(t3) {
            r2.push(t3.x, t3.y, t3.z);
          }
          function l2(e3, n3) {
            const i3 = 3 * e3;
            n3.x = t2[i3 + 0], n3.y = t2[i3 + 1], n3.z = t2[i3 + 2];
          }
          function c2(t3, e3, n3, i3) {
            i3 < 0 && 1 === t3.x && (s2[e3] = t3.x - 1), 0 === n3.x && 0 === n3.z && (s2[e3] = i3 / 2 / Math.PI + 0.5);
          }
          function h2(t3) {
            return Math.atan2(t3.z, -t3.x);
          }
          !function(t3) {
            const n3 = new Rt(), i3 = new Rt(), r3 = new Rt();
            for (let s3 = 0; s3 < e2.length; s3 += 3)
              l2(e2[s3 + 0], n3), l2(e2[s3 + 1], i3), l2(e2[s3 + 2], r3), a2(n3, i3, r3, t3);
          }(i2), function(t3) {
            const e3 = new Rt();
            for (let n3 = 0; n3 < r2.length; n3 += 3)
              e3.x = r2[n3 + 0], e3.y = r2[n3 + 1], e3.z = r2[n3 + 2], e3.normalize().multiplyScalar(t3), r2[n3 + 0] = e3.x, r2[n3 + 1] = e3.y, r2[n3 + 2] = e3.z;
          }(n2), function() {
            const t3 = new Rt();
            for (let n3 = 0; n3 < r2.length; n3 += 3) {
              t3.x = r2[n3 + 0], t3.y = r2[n3 + 1], t3.z = r2[n3 + 2];
              const i3 = h2(t3) / 2 / Math.PI + 0.5, a3 = (e3 = t3, Math.atan2(-e3.y, Math.sqrt(e3.x * e3.x + e3.z * e3.z)) / Math.PI + 0.5);
              s2.push(i3, 1 - a3);
            }
            var e3;
            (function() {
              const t4 = new Rt(), e4 = new Rt(), n3 = new Rt(), i3 = new Rt(), a3 = new vt(), o4 = new vt(), l3 = new vt();
              for (let u2 = 0, d2 = 0; u2 < r2.length; u2 += 9, d2 += 6) {
                t4.set(r2[u2 + 0], r2[u2 + 1], r2[u2 + 2]), e4.set(r2[u2 + 3], r2[u2 + 4], r2[u2 + 5]), n3.set(r2[u2 + 6], r2[u2 + 7], r2[u2 + 8]), a3.set(s2[d2 + 0], s2[d2 + 1]), o4.set(s2[d2 + 2], s2[d2 + 3]), l3.set(s2[d2 + 4], s2[d2 + 5]), i3.copy(t4).add(e4).add(n3).divideScalar(3);
                const p2 = h2(i3);
                c2(a3, d2 + 0, t4, p2), c2(o4, d2 + 2, e4, p2), c2(l3, d2 + 4, n3, p2);
              }
            })(), function() {
              for (let t4 = 0; t4 < s2.length; t4 += 6) {
                const e4 = s2[t4 + 0], n3 = s2[t4 + 2], i3 = s2[t4 + 4], r3 = Math.max(e4, n3, i3), a3 = Math.min(e4, n3, i3);
                r3 > 0.9 && a3 < 0.1 && (e4 < 0.2 && (s2[t4 + 0] += 1), n3 < 0.2 && (s2[t4 + 2] += 1), i3 < 0.2 && (s2[t4 + 4] += 1));
              }
            }();
          }(), this.setAttribute("position", new un(r2, 3)), this.setAttribute("normal", new un(r2.slice(), 3)), this.setAttribute("uv", new un(s2, 2)), 0 === i2 ? this.computeVertexNormals() : this.normalizeNormals();
        }
        static fromJSON(t2) {
          return new lo(t2.vertices, t2.indices, t2.radius, t2.details);
        }
      }
      class co extends lo {
        constructor(t2 = 1, e2 = 0) {
          const n2 = (1 + Math.sqrt(5)) / 2, i2 = 1 / n2;
          super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i2, -n2, 0, -i2, n2, 0, i2, -n2, 0, i2, n2, -i2, -n2, 0, -i2, n2, 0, i2, -n2, 0, i2, n2, 0, -n2, 0, -i2, n2, 0, -i2, -n2, 0, i2, n2, 0, i2], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t2, e2), this.type = "DodecahedronGeometry", this.parameters = { radius: t2, detail: e2 };
        }
        static fromJSON(t2) {
          return new co(t2.radius, t2.detail);
        }
      }
      const ho = new Rt(), uo = new Rt(), po = new Rt(), mo = new ke();
      class fo extends wn {
        constructor(t2, e2) {
          if (super(), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e2 }, e2 = void 0 !== e2 ? e2 : 1, true === t2.isGeometry)
            return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          const n2 = Math.pow(10, 4), i2 = Math.cos(ot * e2), r2 = t2.getIndex(), s2 = t2.getAttribute("position"), a2 = r2 ? r2.count : s2.count, o3 = [0, 0, 0], l2 = ["a", "b", "c"], c2 = new Array(3), h2 = {}, u2 = [];
          for (let t3 = 0; t3 < a2; t3 += 3) {
            r2 ? (o3[0] = r2.getX(t3), o3[1] = r2.getX(t3 + 1), o3[2] = r2.getX(t3 + 2)) : (o3[0] = t3, o3[1] = t3 + 1, o3[2] = t3 + 2);
            const { a: e3, b: a3, c: d2 } = mo;
            if (e3.fromBufferAttribute(s2, o3[0]), a3.fromBufferAttribute(s2, o3[1]), d2.fromBufferAttribute(s2, o3[2]), mo.getNormal(po), c2[0] = `${Math.round(e3.x * n2)},${Math.round(e3.y * n2)},${Math.round(e3.z * n2)}`, c2[1] = `${Math.round(a3.x * n2)},${Math.round(a3.y * n2)},${Math.round(a3.z * n2)}`, c2[2] = `${Math.round(d2.x * n2)},${Math.round(d2.y * n2)},${Math.round(d2.z * n2)}`, c2[0] !== c2[1] && c2[1] !== c2[2] && c2[2] !== c2[0])
              for (let t4 = 0; t4 < 3; t4++) {
                const e4 = (t4 + 1) % 3, n3 = c2[t4], r3 = c2[e4], s3 = mo[l2[t4]], a4 = mo[l2[e4]], d3 = `${n3}_${r3}`, p2 = `${r3}_${n3}`;
                p2 in h2 && h2[p2] ? (po.dot(h2[p2].normal) <= i2 && (u2.push(s3.x, s3.y, s3.z), u2.push(a4.x, a4.y, a4.z)), h2[p2] = null) : d3 in h2 || (h2[d3] = { index0: o3[t4], index1: o3[e4], normal: po.clone() });
              }
          }
          for (const t3 in h2)
            if (h2[t3]) {
              const { index0: e3, index1: n3 } = h2[t3];
              ho.fromBufferAttribute(s2, e3), uo.fromBufferAttribute(s2, n3), u2.push(ho.x, ho.y, ho.z), u2.push(uo.x, uo.y, uo.z);
            }
          this.setAttribute("position", new un(u2, 3));
        }
      }
      class go {
        constructor() {
          this.type = "Curve", this.arcLengthDivisions = 200;
        }
        getPoint() {
          return console.warn("THREE.Curve: .getPoint() not implemented."), null;
        }
        getPointAt(t2, e2) {
          const n2 = this.getUtoTmapping(t2);
          return this.getPoint(n2, e2);
        }
        getPoints(t2 = 5) {
          const e2 = [];
          for (let n2 = 0; n2 <= t2; n2++)
            e2.push(this.getPoint(n2 / t2));
          return e2;
        }
        getSpacedPoints(t2 = 5) {
          const e2 = [];
          for (let n2 = 0; n2 <= t2; n2++)
            e2.push(this.getPointAt(n2 / t2));
          return e2;
        }
        getLength() {
          const t2 = this.getLengths();
          return t2[t2.length - 1];
        }
        getLengths(t2 = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === t2 + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
          this.needsUpdate = false;
          const e2 = [];
          let n2, i2 = this.getPoint(0), r2 = 0;
          e2.push(0);
          for (let s2 = 1; s2 <= t2; s2++)
            n2 = this.getPoint(s2 / t2), r2 += n2.distanceTo(i2), e2.push(r2), i2 = n2;
          return this.cacheArcLengths = e2, e2;
        }
        updateArcLengths() {
          this.needsUpdate = true, this.getLengths();
        }
        getUtoTmapping(t2, e2) {
          const n2 = this.getLengths();
          let i2 = 0;
          const r2 = n2.length;
          let s2;
          s2 = e2 || t2 * n2[r2 - 1];
          let a2, o3 = 0, l2 = r2 - 1;
          for (; o3 <= l2; )
            if (i2 = Math.floor(o3 + (l2 - o3) / 2), a2 = n2[i2] - s2, a2 < 0)
              o3 = i2 + 1;
            else {
              if (!(a2 > 0)) {
                l2 = i2;
                break;
              }
              l2 = i2 - 1;
            }
          if (i2 = l2, n2[i2] === s2)
            return i2 / (r2 - 1);
          const c2 = n2[i2];
          return (i2 + (s2 - c2) / (n2[i2 + 1] - c2)) / (r2 - 1);
        }
        getTangent(t2, e2) {
          const n2 = 1e-4;
          let i2 = t2 - n2, r2 = t2 + n2;
          i2 < 0 && (i2 = 0), r2 > 1 && (r2 = 1);
          const s2 = this.getPoint(i2), a2 = this.getPoint(r2), o3 = e2 || (s2.isVector2 ? new vt() : new Rt());
          return o3.copy(a2).sub(s2).normalize(), o3;
        }
        getTangentAt(t2, e2) {
          const n2 = this.getUtoTmapping(t2);
          return this.getTangent(n2, e2);
        }
        computeFrenetFrames(t2, e2) {
          const n2 = new Rt(), i2 = [], r2 = [], s2 = [], a2 = new Rt(), o3 = new ae();
          for (let e3 = 0; e3 <= t2; e3++) {
            const n3 = e3 / t2;
            i2[e3] = this.getTangentAt(n3, new Rt()), i2[e3].normalize();
          }
          r2[0] = new Rt(), s2[0] = new Rt();
          let l2 = Number.MAX_VALUE;
          const c2 = Math.abs(i2[0].x), h2 = Math.abs(i2[0].y), u2 = Math.abs(i2[0].z);
          c2 <= l2 && (l2 = c2, n2.set(1, 0, 0)), h2 <= l2 && (l2 = h2, n2.set(0, 1, 0)), u2 <= l2 && n2.set(0, 0, 1), a2.crossVectors(i2[0], n2).normalize(), r2[0].crossVectors(i2[0], a2), s2[0].crossVectors(i2[0], r2[0]);
          for (let e3 = 1; e3 <= t2; e3++) {
            if (r2[e3] = r2[e3 - 1].clone(), s2[e3] = s2[e3 - 1].clone(), a2.crossVectors(i2[e3 - 1], i2[e3]), a2.length() > Number.EPSILON) {
              a2.normalize();
              const t3 = Math.acos(ht(i2[e3 - 1].dot(i2[e3]), -1, 1));
              r2[e3].applyMatrix4(o3.makeRotationAxis(a2, t3));
            }
            s2[e3].crossVectors(i2[e3], r2[e3]);
          }
          if (true === e2) {
            let e3 = Math.acos(ht(r2[0].dot(r2[t2]), -1, 1));
            e3 /= t2, i2[0].dot(a2.crossVectors(r2[0], r2[t2])) > 0 && (e3 = -e3);
            for (let n3 = 1; n3 <= t2; n3++)
              r2[n3].applyMatrix4(o3.makeRotationAxis(i2[n3], e3 * n3)), s2[n3].crossVectors(i2[n3], r2[n3]);
          }
          return { tangents: i2, normals: r2, binormals: s2 };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.arcLengthDivisions = t2.arcLengthDivisions, this;
        }
        toJSON() {
          const t2 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
          return t2.arcLengthDivisions = this.arcLengthDivisions, t2.type = this.type, t2;
        }
        fromJSON(t2) {
          return this.arcLengthDivisions = t2.arcLengthDivisions, this;
        }
      }
      class vo extends go {
        constructor(t2 = 0, e2 = 0, n2 = 1, i2 = 1, r2 = 0, s2 = 2 * Math.PI, a2 = false, o3 = 0) {
          super(), this.type = "EllipseCurve", this.aX = t2, this.aY = e2, this.xRadius = n2, this.yRadius = i2, this.aStartAngle = r2, this.aEndAngle = s2, this.aClockwise = a2, this.aRotation = o3;
        }
        getPoint(t2, e2) {
          const n2 = e2 || new vt(), i2 = 2 * Math.PI;
          let r2 = this.aEndAngle - this.aStartAngle;
          const s2 = Math.abs(r2) < Number.EPSILON;
          for (; r2 < 0; )
            r2 += i2;
          for (; r2 > i2; )
            r2 -= i2;
          r2 < Number.EPSILON && (r2 = s2 ? 0 : i2), true !== this.aClockwise || s2 || (r2 === i2 ? r2 = -i2 : r2 -= i2);
          const a2 = this.aStartAngle + t2 * r2;
          let o3 = this.aX + this.xRadius * Math.cos(a2), l2 = this.aY + this.yRadius * Math.sin(a2);
          if (0 !== this.aRotation) {
            const t3 = Math.cos(this.aRotation), e3 = Math.sin(this.aRotation), n3 = o3 - this.aX, i3 = l2 - this.aY;
            o3 = n3 * t3 - i3 * e3 + this.aX, l2 = n3 * e3 + i3 * t3 + this.aY;
          }
          return n2.set(o3, l2);
        }
        copy(t2) {
          return super.copy(t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.aX = this.aX, t2.aY = this.aY, t2.xRadius = this.xRadius, t2.yRadius = this.yRadius, t2.aStartAngle = this.aStartAngle, t2.aEndAngle = this.aEndAngle, t2.aClockwise = this.aClockwise, t2.aRotation = this.aRotation, t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
        }
      }
      vo.prototype.isEllipseCurve = true;
      class yo extends vo {
        constructor(t2, e2, n2, i2, r2, s2) {
          super(t2, e2, n2, n2, i2, r2, s2), this.type = "ArcCurve";
        }
      }
      function xo() {
        let t2 = 0, e2 = 0, n2 = 0, i2 = 0;
        function r2(r3, s2, a2, o3) {
          t2 = r3, e2 = a2, n2 = -3 * r3 + 3 * s2 - 2 * a2 - o3, i2 = 2 * r3 - 2 * s2 + a2 + o3;
        }
        return { initCatmullRom: function(t3, e3, n3, i3, s2) {
          r2(e3, n3, s2 * (n3 - t3), s2 * (i3 - e3));
        }, initNonuniformCatmullRom: function(t3, e3, n3, i3, s2, a2, o3) {
          let l2 = (e3 - t3) / s2 - (n3 - t3) / (s2 + a2) + (n3 - e3) / a2, c2 = (n3 - e3) / a2 - (i3 - e3) / (a2 + o3) + (i3 - n3) / o3;
          l2 *= a2, c2 *= a2, r2(e3, n3, l2, c2);
        }, calc: function(r3) {
          const s2 = r3 * r3;
          return t2 + e2 * r3 + n2 * s2 + i2 * (s2 * r3);
        } };
      }
      yo.prototype.isArcCurve = true;
      const _o = new Rt(), bo = new xo(), Mo = new xo(), wo = new xo();
      class So extends go {
        constructor(t2 = [], e2 = false, n2 = "centripetal", i2 = 0.5) {
          super(), this.type = "CatmullRomCurve3", this.points = t2, this.closed = e2, this.curveType = n2, this.tension = i2;
        }
        getPoint(t2, e2 = new Rt()) {
          const n2 = e2, i2 = this.points, r2 = i2.length, s2 = (r2 - (this.closed ? 0 : 1)) * t2;
          let a2, o3, l2 = Math.floor(s2), c2 = s2 - l2;
          this.closed ? l2 += l2 > 0 ? 0 : (Math.floor(Math.abs(l2) / r2) + 1) * r2 : 0 === c2 && l2 === r2 - 1 && (l2 = r2 - 2, c2 = 1), this.closed || l2 > 0 ? a2 = i2[(l2 - 1) % r2] : (_o.subVectors(i2[0], i2[1]).add(i2[0]), a2 = _o);
          const h2 = i2[l2 % r2], u2 = i2[(l2 + 1) % r2];
          if (this.closed || l2 + 2 < r2 ? o3 = i2[(l2 + 2) % r2] : (_o.subVectors(i2[r2 - 1], i2[r2 - 2]).add(i2[r2 - 1]), o3 = _o), "centripetal" === this.curveType || "chordal" === this.curveType) {
            const t3 = "chordal" === this.curveType ? 0.5 : 0.25;
            let e3 = Math.pow(a2.distanceToSquared(h2), t3), n3 = Math.pow(h2.distanceToSquared(u2), t3), i3 = Math.pow(u2.distanceToSquared(o3), t3);
            n3 < 1e-4 && (n3 = 1), e3 < 1e-4 && (e3 = n3), i3 < 1e-4 && (i3 = n3), bo.initNonuniformCatmullRom(a2.x, h2.x, u2.x, o3.x, e3, n3, i3), Mo.initNonuniformCatmullRom(a2.y, h2.y, u2.y, o3.y, e3, n3, i3), wo.initNonuniformCatmullRom(a2.z, h2.z, u2.z, o3.z, e3, n3, i3);
          } else
            "catmullrom" === this.curveType && (bo.initCatmullRom(a2.x, h2.x, u2.x, o3.x, this.tension), Mo.initCatmullRom(a2.y, h2.y, u2.y, o3.y, this.tension), wo.initCatmullRom(a2.z, h2.z, u2.z, o3.z, this.tension));
          return n2.set(bo.calc(c2), Mo.calc(c2), wo.calc(c2)), n2;
        }
        copy(t2) {
          super.copy(t2), this.points = [];
          for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
            const n3 = t2.points[e2];
            this.points.push(n3.clone());
          }
          return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
        }
        toJSON() {
          const t2 = super.toJSON();
          t2.points = [];
          for (let e2 = 0, n2 = this.points.length; e2 < n2; e2++) {
            const n3 = this.points[e2];
            t2.points.push(n3.toArray());
          }
          return t2.closed = this.closed, t2.curveType = this.curveType, t2.tension = this.tension, t2;
        }
        fromJSON(t2) {
          super.fromJSON(t2), this.points = [];
          for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
            const n3 = t2.points[e2];
            this.points.push(new Rt().fromArray(n3));
          }
          return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
        }
      }
      function To(t2, e2, n2, i2, r2) {
        const s2 = 0.5 * (i2 - e2), a2 = 0.5 * (r2 - n2), o3 = t2 * t2;
        return (2 * n2 - 2 * i2 + s2 + a2) * (t2 * o3) + (-3 * n2 + 3 * i2 - 2 * s2 - a2) * o3 + s2 * t2 + n2;
      }
      function Eo(t2, e2, n2, i2) {
        return function(t3, e3) {
          const n3 = 1 - t3;
          return n3 * n3 * e3;
        }(t2, e2) + function(t3, e3) {
          return 2 * (1 - t3) * t3 * e3;
        }(t2, n2) + function(t3, e3) {
          return t3 * t3 * e3;
        }(t2, i2);
      }
      function Ao(t2, e2, n2, i2, r2) {
        return function(t3, e3) {
          const n3 = 1 - t3;
          return n3 * n3 * n3 * e3;
        }(t2, e2) + function(t3, e3) {
          const n3 = 1 - t3;
          return 3 * n3 * n3 * t3 * e3;
        }(t2, n2) + function(t3, e3) {
          return 3 * (1 - t3) * t3 * t3 * e3;
        }(t2, i2) + function(t3, e3) {
          return t3 * t3 * t3 * e3;
        }(t2, r2);
      }
      So.prototype.isCatmullRomCurve3 = true;
      class Lo extends go {
        constructor(t2 = new vt(), e2 = new vt(), n2 = new vt(), i2 = new vt()) {
          super(), this.type = "CubicBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = n2, this.v3 = i2;
        }
        getPoint(t2, e2 = new vt()) {
          const n2 = e2, i2 = this.v0, r2 = this.v1, s2 = this.v2, a2 = this.v3;
          return n2.set(Ao(t2, i2.x, r2.x, s2.x, a2.x), Ao(t2, i2.y, r2.y, s2.y, a2.y)), n2;
        }
        copy(t2) {
          return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
        }
      }
      Lo.prototype.isCubicBezierCurve = true;
      class Ro extends go {
        constructor(t2 = new Rt(), e2 = new Rt(), n2 = new Rt(), i2 = new Rt()) {
          super(), this.type = "CubicBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = n2, this.v3 = i2;
        }
        getPoint(t2, e2 = new Rt()) {
          const n2 = e2, i2 = this.v0, r2 = this.v1, s2 = this.v2, a2 = this.v3;
          return n2.set(Ao(t2, i2.x, r2.x, s2.x, a2.x), Ao(t2, i2.y, r2.y, s2.y, a2.y), Ao(t2, i2.z, r2.z, s2.z, a2.z)), n2;
        }
        copy(t2) {
          return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
        }
      }
      Ro.prototype.isCubicBezierCurve3 = true;
      class Co extends go {
        constructor(t2 = new vt(), e2 = new vt()) {
          super(), this.type = "LineCurve", this.v1 = t2, this.v2 = e2;
        }
        getPoint(t2, e2 = new vt()) {
          const n2 = e2;
          return 1 === t2 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(t2).add(this.v1)), n2;
        }
        getPointAt(t2, e2) {
          return this.getPoint(t2, e2);
        }
        getTangent(t2, e2) {
          const n2 = e2 || new vt();
          return n2.copy(this.v2).sub(this.v1).normalize(), n2;
        }
        copy(t2) {
          return super.copy(t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
        }
      }
      Co.prototype.isLineCurve = true;
      class Po extends go {
        constructor(t2 = new Rt(), e2 = new Rt()) {
          super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t2, this.v2 = e2;
        }
        getPoint(t2, e2 = new Rt()) {
          const n2 = e2;
          return 1 === t2 ? n2.copy(this.v2) : (n2.copy(this.v2).sub(this.v1), n2.multiplyScalar(t2).add(this.v1)), n2;
        }
        getPointAt(t2, e2) {
          return this.getPoint(t2, e2);
        }
        copy(t2) {
          return super.copy(t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
        }
      }
      class Io extends go {
        constructor(t2 = new vt(), e2 = new vt(), n2 = new vt()) {
          super(), this.type = "QuadraticBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = n2;
        }
        getPoint(t2, e2 = new vt()) {
          const n2 = e2, i2 = this.v0, r2 = this.v1, s2 = this.v2;
          return n2.set(Eo(t2, i2.x, r2.x, s2.x), Eo(t2, i2.y, r2.y, s2.y)), n2;
        }
        copy(t2) {
          return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
        }
      }
      Io.prototype.isQuadraticBezierCurve = true;
      class Do extends go {
        constructor(t2 = new Rt(), e2 = new Rt(), n2 = new Rt()) {
          super(), this.type = "QuadraticBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = n2;
        }
        getPoint(t2, e2 = new Rt()) {
          const n2 = e2, i2 = this.v0, r2 = this.v1, s2 = this.v2;
          return n2.set(Eo(t2, i2.x, r2.x, s2.x), Eo(t2, i2.y, r2.y, s2.y), Eo(t2, i2.z, r2.z, s2.z)), n2;
        }
        copy(t2) {
          return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
        }
      }
      Do.prototype.isQuadraticBezierCurve3 = true;
      class No extends go {
        constructor(t2 = []) {
          super(), this.type = "SplineCurve", this.points = t2;
        }
        getPoint(t2, e2 = new vt()) {
          const n2 = e2, i2 = this.points, r2 = (i2.length - 1) * t2, s2 = Math.floor(r2), a2 = r2 - s2, o3 = i2[0 === s2 ? s2 : s2 - 1], l2 = i2[s2], c2 = i2[s2 > i2.length - 2 ? i2.length - 1 : s2 + 1], h2 = i2[s2 > i2.length - 3 ? i2.length - 1 : s2 + 2];
          return n2.set(To(a2, o3.x, l2.x, c2.x, h2.x), To(a2, o3.y, l2.y, c2.y, h2.y)), n2;
        }
        copy(t2) {
          super.copy(t2), this.points = [];
          for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
            const n3 = t2.points[e2];
            this.points.push(n3.clone());
          }
          return this;
        }
        toJSON() {
          const t2 = super.toJSON();
          t2.points = [];
          for (let e2 = 0, n2 = this.points.length; e2 < n2; e2++) {
            const n3 = this.points[e2];
            t2.points.push(n3.toArray());
          }
          return t2;
        }
        fromJSON(t2) {
          super.fromJSON(t2), this.points = [];
          for (let e2 = 0, n2 = t2.points.length; e2 < n2; e2++) {
            const n3 = t2.points[e2];
            this.points.push(new vt().fromArray(n3));
          }
          return this;
        }
      }
      No.prototype.isSplineCurve = true;
      var zo = Object.freeze({ __proto__: null, ArcCurve: yo, CatmullRomCurve3: So, CubicBezierCurve: Lo, CubicBezierCurve3: Ro, EllipseCurve: vo, LineCurve: Co, LineCurve3: Po, QuadraticBezierCurve: Io, QuadraticBezierCurve3: Do, SplineCurve: No });
      const Bo = function(t2, e2, n2 = 2) {
        const i2 = e2 && e2.length, r2 = i2 ? e2[0] * n2 : t2.length;
        let s2 = Fo(t2, 0, r2, n2, true);
        const a2 = [];
        if (!s2 || s2.next === s2.prev)
          return a2;
        let o3, l2, c2, h2, u2, d2, p2;
        if (i2 && (s2 = function(t3, e3, n3, i3) {
          const r3 = [];
          let s3, a3, o4, l3, c3;
          for (s3 = 0, a3 = e3.length; s3 < a3; s3++)
            o4 = e3[s3] * i3, l3 = s3 < a3 - 1 ? e3[s3 + 1] * i3 : t3.length, c3 = Fo(t3, o4, l3, i3, false), c3 === c3.next && (c3.steiner = true), r3.push(Yo(c3));
          for (r3.sort(Wo), s3 = 0; s3 < r3.length; s3++)
            jo(r3[s3], n3), n3 = Oo(n3, n3.next);
          return n3;
        }(t2, e2, s2, n2)), t2.length > 80 * n2) {
          o3 = c2 = t2[0], l2 = h2 = t2[1];
          for (let e3 = n2; e3 < r2; e3 += n2)
            u2 = t2[e3], d2 = t2[e3 + 1], u2 < o3 && (o3 = u2), d2 < l2 && (l2 = d2), u2 > c2 && (c2 = u2), d2 > h2 && (h2 = d2);
          p2 = Math.max(c2 - o3, h2 - l2), p2 = 0 !== p2 ? 1 / p2 : 0;
        }
        return Uo(s2, a2, n2, o3, l2, p2), a2;
      };
      function Fo(t2, e2, n2, i2, r2) {
        let s2, a2;
        if (r2 === function(t3, e3, n3, i3) {
          let r3 = 0;
          for (let s3 = e3, a3 = n3 - i3; s3 < n3; s3 += i3)
            r3 += (t3[a3] - t3[s3]) * (t3[s3 + 1] + t3[a3 + 1]), a3 = s3;
          return r3;
        }(t2, e2, n2, i2) > 0)
          for (s2 = e2; s2 < n2; s2 += i2)
            a2 = rl(s2, t2[s2], t2[s2 + 1], a2);
        else
          for (s2 = n2 - i2; s2 >= e2; s2 -= i2)
            a2 = rl(s2, t2[s2], t2[s2 + 1], a2);
        return a2 && Ko(a2, a2.next) && (sl(a2), a2 = a2.next), a2;
      }
      function Oo(t2, e2) {
        if (!t2)
          return t2;
        e2 || (e2 = t2);
        let n2, i2 = t2;
        do {
          if (n2 = false, i2.steiner || !Ko(i2, i2.next) && 0 !== Qo(i2.prev, i2, i2.next))
            i2 = i2.next;
          else {
            if (sl(i2), i2 = e2 = i2.prev, i2 === i2.next)
              break;
            n2 = true;
          }
        } while (n2 || i2 !== e2);
        return e2;
      }
      function Uo(t2, e2, n2, i2, r2, s2, a2) {
        if (!t2)
          return;
        !a2 && s2 && function(t3, e3, n3, i3) {
          let r3 = t3;
          do {
            null === r3.z && (r3.z = Xo(r3.x, r3.y, e3, n3, i3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
          } while (r3 !== t3);
          r3.prevZ.nextZ = null, r3.prevZ = null, function(t4) {
            let e4, n4, i4, r4, s3, a3, o4, l3, c3 = 1;
            do {
              for (n4 = t4, t4 = null, s3 = null, a3 = 0; n4; ) {
                for (a3++, i4 = n4, o4 = 0, e4 = 0; e4 < c3 && (o4++, i4 = i4.nextZ, i4); e4++)
                  ;
                for (l3 = c3; o4 > 0 || l3 > 0 && i4; )
                  0 !== o4 && (0 === l3 || !i4 || n4.z <= i4.z) ? (r4 = n4, n4 = n4.nextZ, o4--) : (r4 = i4, i4 = i4.nextZ, l3--), s3 ? s3.nextZ = r4 : t4 = r4, r4.prevZ = s3, s3 = r4;
                n4 = i4;
              }
              s3.nextZ = null, c3 *= 2;
            } while (a3 > 1);
          }(r3);
        }(t2, i2, r2, s2);
        let o3, l2, c2 = t2;
        for (; t2.prev !== t2.next; )
          if (o3 = t2.prev, l2 = t2.next, s2 ? Go(t2, i2, r2, s2) : Ho(t2))
            e2.push(o3.i / n2), e2.push(t2.i / n2), e2.push(l2.i / n2), sl(t2), t2 = l2.next, c2 = l2.next;
          else if ((t2 = l2) === c2) {
            a2 ? 1 === a2 ? Uo(t2 = ko(Oo(t2), e2, n2), e2, n2, i2, r2, s2, 2) : 2 === a2 && Vo(t2, e2, n2, i2, r2, s2) : Uo(Oo(t2), e2, n2, i2, r2, s2, 1);
            break;
          }
      }
      function Ho(t2) {
        const e2 = t2.prev, n2 = t2, i2 = t2.next;
        if (Qo(e2, n2, i2) >= 0)
          return false;
        let r2 = t2.next.next;
        for (; r2 !== t2.prev; ) {
          if (Jo(e2.x, e2.y, n2.x, n2.y, i2.x, i2.y, r2.x, r2.y) && Qo(r2.prev, r2, r2.next) >= 0)
            return false;
          r2 = r2.next;
        }
        return true;
      }
      function Go(t2, e2, n2, i2) {
        const r2 = t2.prev, s2 = t2, a2 = t2.next;
        if (Qo(r2, s2, a2) >= 0)
          return false;
        const o3 = r2.x < s2.x ? r2.x < a2.x ? r2.x : a2.x : s2.x < a2.x ? s2.x : a2.x, l2 = r2.y < s2.y ? r2.y < a2.y ? r2.y : a2.y : s2.y < a2.y ? s2.y : a2.y, c2 = r2.x > s2.x ? r2.x > a2.x ? r2.x : a2.x : s2.x > a2.x ? s2.x : a2.x, h2 = r2.y > s2.y ? r2.y > a2.y ? r2.y : a2.y : s2.y > a2.y ? s2.y : a2.y, u2 = Xo(o3, l2, e2, n2, i2), d2 = Xo(c2, h2, e2, n2, i2);
        let p2 = t2.prevZ, m2 = t2.nextZ;
        for (; p2 && p2.z >= u2 && m2 && m2.z <= d2; ) {
          if (p2 !== t2.prev && p2 !== t2.next && Jo(r2.x, r2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && Qo(p2.prev, p2, p2.next) >= 0)
            return false;
          if (p2 = p2.prevZ, m2 !== t2.prev && m2 !== t2.next && Jo(r2.x, r2.y, s2.x, s2.y, a2.x, a2.y, m2.x, m2.y) && Qo(m2.prev, m2, m2.next) >= 0)
            return false;
          m2 = m2.nextZ;
        }
        for (; p2 && p2.z >= u2; ) {
          if (p2 !== t2.prev && p2 !== t2.next && Jo(r2.x, r2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && Qo(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.prevZ;
        }
        for (; m2 && m2.z <= d2; ) {
          if (m2 !== t2.prev && m2 !== t2.next && Jo(r2.x, r2.y, s2.x, s2.y, a2.x, a2.y, m2.x, m2.y) && Qo(m2.prev, m2, m2.next) >= 0)
            return false;
          m2 = m2.nextZ;
        }
        return true;
      }
      function ko(t2, e2, n2) {
        let i2 = t2;
        do {
          const r2 = i2.prev, s2 = i2.next.next;
          !Ko(r2, s2) && $o(r2, i2, i2.next, s2) && nl(r2, s2) && nl(s2, r2) && (e2.push(r2.i / n2), e2.push(i2.i / n2), e2.push(s2.i / n2), sl(i2), sl(i2.next), i2 = t2 = s2), i2 = i2.next;
        } while (i2 !== t2);
        return Oo(i2);
      }
      function Vo(t2, e2, n2, i2, r2, s2) {
        let a2 = t2;
        do {
          let t3 = a2.next.next;
          for (; t3 !== a2.prev; ) {
            if (a2.i !== t3.i && Zo(a2, t3)) {
              let o3 = il(a2, t3);
              return a2 = Oo(a2, a2.next), o3 = Oo(o3, o3.next), Uo(a2, e2, n2, i2, r2, s2), void Uo(o3, e2, n2, i2, r2, s2);
            }
            t3 = t3.next;
          }
          a2 = a2.next;
        } while (a2 !== t2);
      }
      function Wo(t2, e2) {
        return t2.x - e2.x;
      }
      function jo(t2, e2) {
        if (e2 = function(t3, e3) {
          let n2 = e3;
          const i2 = t3.x, r2 = t3.y;
          let s2, a2 = -1 / 0;
          do {
            if (r2 <= n2.y && r2 >= n2.next.y && n2.next.y !== n2.y) {
              const t4 = n2.x + (r2 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
              if (t4 <= i2 && t4 > a2) {
                if (a2 = t4, t4 === i2) {
                  if (r2 === n2.y)
                    return n2;
                  if (r2 === n2.next.y)
                    return n2.next;
                }
                s2 = n2.x < n2.next.x ? n2 : n2.next;
              }
            }
            n2 = n2.next;
          } while (n2 !== e3);
          if (!s2)
            return null;
          if (i2 === a2)
            return s2;
          const o3 = s2, l2 = s2.x, c2 = s2.y;
          let h2, u2 = 1 / 0;
          n2 = s2;
          do {
            i2 >= n2.x && n2.x >= l2 && i2 !== n2.x && Jo(r2 < c2 ? i2 : a2, r2, l2, c2, r2 < c2 ? a2 : i2, r2, n2.x, n2.y) && (h2 = Math.abs(r2 - n2.y) / (i2 - n2.x), nl(n2, t3) && (h2 < u2 || h2 === u2 && (n2.x > s2.x || n2.x === s2.x && qo(s2, n2))) && (s2 = n2, u2 = h2)), n2 = n2.next;
          } while (n2 !== o3);
          return s2;
        }(t2, e2)) {
          const n2 = il(e2, t2);
          Oo(e2, e2.next), Oo(n2, n2.next);
        }
      }
      function qo(t2, e2) {
        return Qo(t2.prev, t2, e2.prev) < 0 && Qo(e2.next, t2, t2.next) < 0;
      }
      function Xo(t2, e2, n2, i2, r2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - n2) * r2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - i2) * r2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function Yo(t2) {
        let e2 = t2, n2 = t2;
        do {
          (e2.x < n2.x || e2.x === n2.x && e2.y < n2.y) && (n2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return n2;
      }
      function Jo(t2, e2, n2, i2, r2, s2, a2, o3) {
        return (r2 - a2) * (e2 - o3) - (t2 - a2) * (s2 - o3) >= 0 && (t2 - a2) * (i2 - o3) - (n2 - a2) * (e2 - o3) >= 0 && (n2 - a2) * (s2 - o3) - (r2 - a2) * (i2 - o3) >= 0;
      }
      function Zo(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          let n2 = t3;
          do {
            if (n2.i !== t3.i && n2.next.i !== t3.i && n2.i !== e3.i && n2.next.i !== e3.i && $o(n2, n2.next, t3, e3))
              return true;
            n2 = n2.next;
          } while (n2 !== t3);
          return false;
        }(t2, e2) && (nl(t2, e2) && nl(e2, t2) && function(t3, e3) {
          let n2 = t3, i2 = false;
          const r2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            n2.y > s2 != n2.next.y > s2 && n2.next.y !== n2.y && r2 < (n2.next.x - n2.x) * (s2 - n2.y) / (n2.next.y - n2.y) + n2.x && (i2 = !i2), n2 = n2.next;
          } while (n2 !== t3);
          return i2;
        }(t2, e2) && (Qo(t2.prev, t2, e2.prev) || Qo(t2, e2.prev, e2)) || Ko(t2, e2) && Qo(t2.prev, t2, t2.next) > 0 && Qo(e2.prev, e2, e2.next) > 0);
      }
      function Qo(t2, e2, n2) {
        return (e2.y - t2.y) * (n2.x - e2.x) - (e2.x - t2.x) * (n2.y - e2.y);
      }
      function Ko(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function $o(t2, e2, n2, i2) {
        const r2 = el(Qo(t2, e2, n2)), s2 = el(Qo(t2, e2, i2)), a2 = el(Qo(n2, i2, t2)), o3 = el(Qo(n2, i2, e2));
        return r2 !== s2 && a2 !== o3 || (!(0 !== r2 || !tl(t2, n2, e2)) || (!(0 !== s2 || !tl(t2, i2, e2)) || (!(0 !== a2 || !tl(n2, t2, i2)) || !(0 !== o3 || !tl(n2, e2, i2)))));
      }
      function tl(t2, e2, n2) {
        return e2.x <= Math.max(t2.x, n2.x) && e2.x >= Math.min(t2.x, n2.x) && e2.y <= Math.max(t2.y, n2.y) && e2.y >= Math.min(t2.y, n2.y);
      }
      function el(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function nl(t2, e2) {
        return Qo(t2.prev, t2, t2.next) < 0 ? Qo(t2, e2, t2.next) >= 0 && Qo(t2, t2.prev, e2) >= 0 : Qo(t2, e2, t2.prev) < 0 || Qo(t2, t2.next, e2) < 0;
      }
      function il(t2, e2) {
        const n2 = new al(t2.i, t2.x, t2.y), i2 = new al(e2.i, e2.x, e2.y), r2 = t2.next, s2 = e2.prev;
        return t2.next = e2, e2.prev = t2, n2.next = r2, r2.prev = n2, i2.next = n2, n2.prev = i2, s2.next = i2, i2.prev = s2, i2;
      }
      function rl(t2, e2, n2, i2) {
        const r2 = new al(t2, e2, n2);
        return i2 ? (r2.next = i2.next, r2.prev = i2, i2.next.prev = r2, i2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
      }
      function sl(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function al(t2, e2, n2) {
        this.i = t2, this.x = e2, this.y = n2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      class ol {
        static area(t2) {
          const e2 = t2.length;
          let n2 = 0;
          for (let i2 = e2 - 1, r2 = 0; r2 < e2; i2 = r2++)
            n2 += t2[i2].x * t2[r2].y - t2[r2].x * t2[i2].y;
          return 0.5 * n2;
        }
        static isClockWise(t2) {
          return ol.area(t2) < 0;
        }
        static triangulateShape(t2, e2) {
          const n2 = [], i2 = [], r2 = [];
          ll(t2), cl(n2, t2);
          let s2 = t2.length;
          e2.forEach(ll);
          for (let t3 = 0; t3 < e2.length; t3++)
            i2.push(s2), s2 += e2[t3].length, cl(n2, e2[t3]);
          const a2 = Bo(n2, i2);
          for (let t3 = 0; t3 < a2.length; t3 += 3)
            r2.push(a2.slice(t3, t3 + 3));
          return r2;
        }
      }
      function ll(t2) {
        const e2 = t2.length;
        e2 > 2 && t2[e2 - 1].equals(t2[0]) && t2.pop();
      }
      function cl(t2, e2) {
        for (let n2 = 0; n2 < e2.length; n2++)
          t2.push(e2[n2].x), t2.push(e2[n2].y);
      }
      class hl extends wn {
        constructor(t2, e2) {
          super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t2, options: e2 }, t2 = Array.isArray(t2) ? t2 : [t2];
          const n2 = this, i2 = [], r2 = [];
          for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
            s2(t2[e3]);
          }
          function s2(t3) {
            const s3 = [], a2 = void 0 !== e2.curveSegments ? e2.curveSegments : 12, o3 = void 0 !== e2.steps ? e2.steps : 1;
            let l2 = void 0 !== e2.depth ? e2.depth : 100, c2 = void 0 === e2.bevelEnabled || e2.bevelEnabled, h2 = void 0 !== e2.bevelThickness ? e2.bevelThickness : 6, u2 = void 0 !== e2.bevelSize ? e2.bevelSize : h2 - 2, d2 = void 0 !== e2.bevelOffset ? e2.bevelOffset : 0, p2 = void 0 !== e2.bevelSegments ? e2.bevelSegments : 3;
            const m2 = e2.extrudePath, f2 = void 0 !== e2.UVGenerator ? e2.UVGenerator : ul;
            void 0 !== e2.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l2 = e2.amount);
            let g2, v2, y2, x2, _2, b2 = false;
            m2 && (g2 = m2.getSpacedPoints(o3), b2 = true, c2 = false, v2 = m2.computeFrenetFrames(o3, false), y2 = new Rt(), x2 = new Rt(), _2 = new Rt()), c2 || (p2 = 0, h2 = 0, u2 = 0, d2 = 0);
            const M2 = t3.extractPoints(a2);
            let w2 = M2.shape;
            const S2 = M2.holes;
            if (!ol.isClockWise(w2)) {
              w2 = w2.reverse();
              for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
                const e4 = S2[t4];
                ol.isClockWise(e4) && (S2[t4] = e4.reverse());
              }
            }
            const T2 = ol.triangulateShape(w2, S2), E2 = w2;
            for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
              const e4 = S2[t4];
              w2 = w2.concat(e4);
            }
            function A2(t4, e3, n3) {
              return e3 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e3.clone().multiplyScalar(n3).add(t4);
            }
            const L2 = w2.length, R2 = T2.length;
            function C2(t4, e3, n3) {
              let i3, r3, s4;
              const a3 = t4.x - e3.x, o4 = t4.y - e3.y, l3 = n3.x - t4.x, c3 = n3.y - t4.y, h3 = a3 * a3 + o4 * o4, u3 = a3 * c3 - o4 * l3;
              if (Math.abs(u3) > Number.EPSILON) {
                const u4 = Math.sqrt(h3), d3 = Math.sqrt(l3 * l3 + c3 * c3), p3 = e3.x - o4 / u4, m3 = e3.y + a3 / u4, f3 = ((n3.x - c3 / d3 - p3) * c3 - (n3.y + l3 / d3 - m3) * l3) / (a3 * c3 - o4 * l3);
                i3 = p3 + a3 * f3 - t4.x, r3 = m3 + o4 * f3 - t4.y;
                const g3 = i3 * i3 + r3 * r3;
                if (g3 <= 2)
                  return new vt(i3, r3);
                s4 = Math.sqrt(g3 / 2);
              } else {
                let t5 = false;
                a3 > Number.EPSILON ? l3 > Number.EPSILON && (t5 = true) : a3 < -Number.EPSILON ? l3 < -Number.EPSILON && (t5 = true) : Math.sign(o4) === Math.sign(c3) && (t5 = true), t5 ? (i3 = -o4, r3 = a3, s4 = Math.sqrt(h3)) : (i3 = a3, r3 = o4, s4 = Math.sqrt(h3 / 2));
              }
              return new vt(i3 / s4, r3 / s4);
            }
            const P2 = [];
            for (let t4 = 0, e3 = E2.length, n3 = e3 - 1, i3 = t4 + 1; t4 < e3; t4++, n3++, i3++)
              n3 === e3 && (n3 = 0), i3 === e3 && (i3 = 0), P2[t4] = C2(E2[t4], E2[n3], E2[i3]);
            const I2 = [];
            let D2, N2 = P2.concat();
            for (let t4 = 0, e3 = S2.length; t4 < e3; t4++) {
              const e4 = S2[t4];
              D2 = [];
              for (let t5 = 0, n3 = e4.length, i3 = n3 - 1, r3 = t5 + 1; t5 < n3; t5++, i3++, r3++)
                i3 === n3 && (i3 = 0), r3 === n3 && (r3 = 0), D2[t5] = C2(e4[t5], e4[i3], e4[r3]);
              I2.push(D2), N2 = N2.concat(D2);
            }
            for (let t4 = 0; t4 < p2; t4++) {
              const e3 = t4 / p2, n3 = h2 * Math.cos(e3 * Math.PI / 2), i3 = u2 * Math.sin(e3 * Math.PI / 2) + d2;
              for (let t5 = 0, e4 = E2.length; t5 < e4; t5++) {
                const e5 = A2(E2[t5], P2[t5], i3);
                F2(e5.x, e5.y, -n3);
              }
              for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
                const e5 = S2[t5];
                D2 = I2[t5];
                for (let t6 = 0, r3 = e5.length; t6 < r3; t6++) {
                  const r4 = A2(e5[t6], D2[t6], i3);
                  F2(r4.x, r4.y, -n3);
                }
              }
            }
            const z2 = u2 + d2;
            for (let t4 = 0; t4 < L2; t4++) {
              const e3 = c2 ? A2(w2[t4], N2[t4], z2) : w2[t4];
              b2 ? (x2.copy(v2.normals[0]).multiplyScalar(e3.x), y2.copy(v2.binormals[0]).multiplyScalar(e3.y), _2.copy(g2[0]).add(x2).add(y2), F2(_2.x, _2.y, _2.z)) : F2(e3.x, e3.y, 0);
            }
            for (let t4 = 1; t4 <= o3; t4++)
              for (let e3 = 0; e3 < L2; e3++) {
                const n3 = c2 ? A2(w2[e3], N2[e3], z2) : w2[e3];
                b2 ? (x2.copy(v2.normals[t4]).multiplyScalar(n3.x), y2.copy(v2.binormals[t4]).multiplyScalar(n3.y), _2.copy(g2[t4]).add(x2).add(y2), F2(_2.x, _2.y, _2.z)) : F2(n3.x, n3.y, l2 / o3 * t4);
              }
            for (let t4 = p2 - 1; t4 >= 0; t4--) {
              const e3 = t4 / p2, n3 = h2 * Math.cos(e3 * Math.PI / 2), i3 = u2 * Math.sin(e3 * Math.PI / 2) + d2;
              for (let t5 = 0, e4 = E2.length; t5 < e4; t5++) {
                const e5 = A2(E2[t5], P2[t5], i3);
                F2(e5.x, e5.y, l2 + n3);
              }
              for (let t5 = 0, e4 = S2.length; t5 < e4; t5++) {
                const e5 = S2[t5];
                D2 = I2[t5];
                for (let t6 = 0, r3 = e5.length; t6 < r3; t6++) {
                  const r4 = A2(e5[t6], D2[t6], i3);
                  b2 ? F2(r4.x, r4.y + g2[o3 - 1].y, g2[o3 - 1].x + n3) : F2(r4.x, r4.y, l2 + n3);
                }
              }
            }
            function B2(t4, e3) {
              let n3 = t4.length;
              for (; --n3 >= 0; ) {
                const i3 = n3;
                let r3 = n3 - 1;
                r3 < 0 && (r3 = t4.length - 1);
                for (let t5 = 0, n4 = o3 + 2 * p2; t5 < n4; t5++) {
                  const n5 = L2 * t5, s4 = L2 * (t5 + 1);
                  U2(e3 + i3 + n5, e3 + r3 + n5, e3 + r3 + s4, e3 + i3 + s4);
                }
              }
            }
            function F2(t4, e3, n3) {
              s3.push(t4), s3.push(e3), s3.push(n3);
            }
            function O2(t4, e3, r3) {
              H2(t4), H2(e3), H2(r3);
              const s4 = i2.length / 3, a3 = f2.generateTopUV(n2, i2, s4 - 3, s4 - 2, s4 - 1);
              G2(a3[0]), G2(a3[1]), G2(a3[2]);
            }
            function U2(t4, e3, r3, s4) {
              H2(t4), H2(e3), H2(s4), H2(e3), H2(r3), H2(s4);
              const a3 = i2.length / 3, o4 = f2.generateSideWallUV(n2, i2, a3 - 6, a3 - 3, a3 - 2, a3 - 1);
              G2(o4[0]), G2(o4[1]), G2(o4[3]), G2(o4[1]), G2(o4[2]), G2(o4[3]);
            }
            function H2(t4) {
              i2.push(s3[3 * t4 + 0]), i2.push(s3[3 * t4 + 1]), i2.push(s3[3 * t4 + 2]);
            }
            function G2(t4) {
              r2.push(t4.x), r2.push(t4.y);
            }
            !function() {
              const t4 = i2.length / 3;
              if (c2) {
                let t5 = 0, e3 = L2 * t5;
                for (let t6 = 0; t6 < R2; t6++) {
                  const n3 = T2[t6];
                  O2(n3[2] + e3, n3[1] + e3, n3[0] + e3);
                }
                t5 = o3 + 2 * p2, e3 = L2 * t5;
                for (let t6 = 0; t6 < R2; t6++) {
                  const n3 = T2[t6];
                  O2(n3[0] + e3, n3[1] + e3, n3[2] + e3);
                }
              } else {
                for (let t5 = 0; t5 < R2; t5++) {
                  const e3 = T2[t5];
                  O2(e3[2], e3[1], e3[0]);
                }
                for (let t5 = 0; t5 < R2; t5++) {
                  const e3 = T2[t5];
                  O2(e3[0] + L2 * o3, e3[1] + L2 * o3, e3[2] + L2 * o3);
                }
              }
              n2.addGroup(t4, i2.length / 3 - t4, 0);
            }(), function() {
              const t4 = i2.length / 3;
              let e3 = 0;
              B2(E2, e3), e3 += E2.length;
              for (let t5 = 0, n3 = S2.length; t5 < n3; t5++) {
                const n4 = S2[t5];
                B2(n4, e3), e3 += n4.length;
              }
              n2.addGroup(t4, i2.length / 3 - t4, 1);
            }();
          }
          this.setAttribute("position", new un(i2, 3)), this.setAttribute("uv", new un(r2, 2)), this.computeVertexNormals();
        }
        toJSON() {
          const t2 = super.toJSON();
          return function(t3, e2, n2) {
            if (n2.shapes = [], Array.isArray(t3))
              for (let e3 = 0, i2 = t3.length; e3 < i2; e3++) {
                const i3 = t3[e3];
                n2.shapes.push(i3.uuid);
              }
            else
              n2.shapes.push(t3.uuid);
            void 0 !== e2.extrudePath && (n2.options.extrudePath = e2.extrudePath.toJSON());
            return n2;
          }(this.parameters.shapes, this.parameters.options, t2);
        }
        static fromJSON(t2, e2) {
          const n2 = [];
          for (let i3 = 0, r2 = t2.shapes.length; i3 < r2; i3++) {
            const r3 = e2[t2.shapes[i3]];
            n2.push(r3);
          }
          const i2 = t2.options.extrudePath;
          return void 0 !== i2 && (t2.options.extrudePath = new zo[i2.type]().fromJSON(i2)), new hl(n2, t2.options);
        }
      }
      const ul = { generateTopUV: function(t2, e2, n2, i2, r2) {
        const s2 = e2[3 * n2], a2 = e2[3 * n2 + 1], o3 = e2[3 * i2], l2 = e2[3 * i2 + 1], c2 = e2[3 * r2], h2 = e2[3 * r2 + 1];
        return [new vt(s2, a2), new vt(o3, l2), new vt(c2, h2)];
      }, generateSideWallUV: function(t2, e2, n2, i2, r2, s2) {
        const a2 = e2[3 * n2], o3 = e2[3 * n2 + 1], l2 = e2[3 * n2 + 2], c2 = e2[3 * i2], h2 = e2[3 * i2 + 1], u2 = e2[3 * i2 + 2], d2 = e2[3 * r2], p2 = e2[3 * r2 + 1], m2 = e2[3 * r2 + 2], f2 = e2[3 * s2], g2 = e2[3 * s2 + 1], v2 = e2[3 * s2 + 2];
        return Math.abs(o3 - h2) < Math.abs(a2 - c2) ? [new vt(a2, 1 - l2), new vt(c2, 1 - u2), new vt(d2, 1 - m2), new vt(f2, 1 - v2)] : [new vt(o3, 1 - l2), new vt(h2, 1 - u2), new vt(p2, 1 - m2), new vt(g2, 1 - v2)];
      } };
      class dl extends lo {
        constructor(t2 = 1, e2 = 0) {
          const n2 = (1 + Math.sqrt(5)) / 2;
          super([-1, n2, 0, 1, n2, 0, -1, -n2, 0, 1, -n2, 0, 0, -1, n2, 0, 1, n2, 0, -1, -n2, 0, 1, -n2, n2, 0, -1, n2, 0, 1, -n2, 0, -1, -n2, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t2, e2), this.type = "IcosahedronGeometry", this.parameters = { radius: t2, detail: e2 };
        }
        static fromJSON(t2) {
          return new dl(t2.radius, t2.detail);
        }
      }
      class pl extends wn {
        constructor(t2, e2 = 12, n2 = 0, i2 = 2 * Math.PI) {
          super(), this.type = "LatheGeometry", this.parameters = { points: t2, segments: e2, phiStart: n2, phiLength: i2 }, e2 = Math.floor(e2), i2 = ht(i2, 0, 2 * Math.PI);
          const r2 = [], s2 = [], a2 = [], o3 = 1 / e2, l2 = new Rt(), c2 = new vt();
          for (let r3 = 0; r3 <= e2; r3++) {
            const h2 = n2 + r3 * o3 * i2, u2 = Math.sin(h2), d2 = Math.cos(h2);
            for (let n3 = 0; n3 <= t2.length - 1; n3++)
              l2.x = t2[n3].x * u2, l2.y = t2[n3].y, l2.z = t2[n3].x * d2, s2.push(l2.x, l2.y, l2.z), c2.x = r3 / e2, c2.y = n3 / (t2.length - 1), a2.push(c2.x, c2.y);
          }
          for (let n3 = 0; n3 < e2; n3++)
            for (let e3 = 0; e3 < t2.length - 1; e3++) {
              const i3 = e3 + n3 * t2.length, s3 = i3, a3 = i3 + t2.length, o4 = i3 + t2.length + 1, l3 = i3 + 1;
              r2.push(s3, a3, l3), r2.push(a3, o4, l3);
            }
          if (this.setIndex(r2), this.setAttribute("position", new un(s2, 3)), this.setAttribute("uv", new un(a2, 2)), this.computeVertexNormals(), i2 === 2 * Math.PI) {
            const n3 = this.attributes.normal.array, i3 = new Rt(), r3 = new Rt(), s3 = new Rt(), a3 = e2 * t2.length * 3;
            for (let e3 = 0, o4 = 0; e3 < t2.length; e3++, o4 += 3)
              i3.x = n3[o4 + 0], i3.y = n3[o4 + 1], i3.z = n3[o4 + 2], r3.x = n3[a3 + o4 + 0], r3.y = n3[a3 + o4 + 1], r3.z = n3[a3 + o4 + 2], s3.addVectors(i3, r3).normalize(), n3[o4 + 0] = n3[a3 + o4 + 0] = s3.x, n3[o4 + 1] = n3[a3 + o4 + 1] = s3.y, n3[o4 + 2] = n3[a3 + o4 + 2] = s3.z;
          }
        }
        static fromJSON(t2) {
          return new pl(t2.points, t2.segments, t2.phiStart, t2.phiLength);
        }
      }
      class ml extends lo {
        constructor(t2 = 1, e2 = 0) {
          super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t2, e2), this.type = "OctahedronGeometry", this.parameters = { radius: t2, detail: e2 };
        }
        static fromJSON(t2) {
          return new ml(t2.radius, t2.detail);
        }
      }
      class fl extends wn {
        constructor(t2, e2, n2) {
          super(), this.type = "ParametricGeometry", this.parameters = { func: t2, slices: e2, stacks: n2 };
          const i2 = [], r2 = [], s2 = [], a2 = [], o3 = 1e-5, l2 = new Rt(), c2 = new Rt(), h2 = new Rt(), u2 = new Rt(), d2 = new Rt();
          t2.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
          const p2 = e2 + 1;
          for (let i3 = 0; i3 <= n2; i3++) {
            const p3 = i3 / n2;
            for (let n3 = 0; n3 <= e2; n3++) {
              const i4 = n3 / e2;
              t2(i4, p3, c2), r2.push(c2.x, c2.y, c2.z), i4 - o3 >= 0 ? (t2(i4 - o3, p3, h2), u2.subVectors(c2, h2)) : (t2(i4 + o3, p3, h2), u2.subVectors(h2, c2)), p3 - o3 >= 0 ? (t2(i4, p3 - o3, h2), d2.subVectors(c2, h2)) : (t2(i4, p3 + o3, h2), d2.subVectors(h2, c2)), l2.crossVectors(u2, d2).normalize(), s2.push(l2.x, l2.y, l2.z), a2.push(i4, p3);
            }
          }
          for (let t3 = 0; t3 < n2; t3++)
            for (let n3 = 0; n3 < e2; n3++) {
              const e3 = t3 * p2 + n3, r3 = t3 * p2 + n3 + 1, s3 = (t3 + 1) * p2 + n3 + 1, a3 = (t3 + 1) * p2 + n3;
              i2.push(e3, r3, a3), i2.push(r3, s3, a3);
            }
          this.setIndex(i2), this.setAttribute("position", new un(r2, 3)), this.setAttribute("normal", new un(s2, 3)), this.setAttribute("uv", new un(a2, 2));
        }
      }
      class gl extends wn {
        constructor(t2 = 0.5, e2 = 1, n2 = 8, i2 = 1, r2 = 0, s2 = 2 * Math.PI) {
          super(), this.type = "RingGeometry", this.parameters = { innerRadius: t2, outerRadius: e2, thetaSegments: n2, phiSegments: i2, thetaStart: r2, thetaLength: s2 }, n2 = Math.max(3, n2);
          const a2 = [], o3 = [], l2 = [], c2 = [];
          let h2 = t2;
          const u2 = (e2 - t2) / (i2 = Math.max(1, i2)), d2 = new Rt(), p2 = new vt();
          for (let t3 = 0; t3 <= i2; t3++) {
            for (let t4 = 0; t4 <= n2; t4++) {
              const i3 = r2 + t4 / n2 * s2;
              d2.x = h2 * Math.cos(i3), d2.y = h2 * Math.sin(i3), o3.push(d2.x, d2.y, d2.z), l2.push(0, 0, 1), p2.x = (d2.x / e2 + 1) / 2, p2.y = (d2.y / e2 + 1) / 2, c2.push(p2.x, p2.y);
            }
            h2 += u2;
          }
          for (let t3 = 0; t3 < i2; t3++) {
            const e3 = t3 * (n2 + 1);
            for (let t4 = 0; t4 < n2; t4++) {
              const i3 = t4 + e3, r3 = i3, s3 = i3 + n2 + 1, o4 = i3 + n2 + 2, l3 = i3 + 1;
              a2.push(r3, s3, l3), a2.push(s3, o4, l3);
            }
          }
          this.setIndex(a2), this.setAttribute("position", new un(o3, 3)), this.setAttribute("normal", new un(l2, 3)), this.setAttribute("uv", new un(c2, 2));
        }
        static fromJSON(t2) {
          return new gl(t2.innerRadius, t2.outerRadius, t2.thetaSegments, t2.phiSegments, t2.thetaStart, t2.thetaLength);
        }
      }
      class vl extends wn {
        constructor(t2, e2 = 12) {
          super(), this.type = "ShapeGeometry", this.parameters = { shapes: t2, curveSegments: e2 };
          const n2 = [], i2 = [], r2 = [], s2 = [];
          let a2 = 0, o3 = 0;
          if (false === Array.isArray(t2))
            l2(t2);
          else
            for (let e3 = 0; e3 < t2.length; e3++)
              l2(t2[e3]), this.addGroup(a2, o3, e3), a2 += o3, o3 = 0;
          function l2(t3) {
            const a3 = i2.length / 3, l3 = t3.extractPoints(e2);
            let c2 = l3.shape;
            const h2 = l3.holes;
            false === ol.isClockWise(c2) && (c2 = c2.reverse());
            for (let t4 = 0, e3 = h2.length; t4 < e3; t4++) {
              const e4 = h2[t4];
              true === ol.isClockWise(e4) && (h2[t4] = e4.reverse());
            }
            const u2 = ol.triangulateShape(c2, h2);
            for (let t4 = 0, e3 = h2.length; t4 < e3; t4++) {
              const e4 = h2[t4];
              c2 = c2.concat(e4);
            }
            for (let t4 = 0, e3 = c2.length; t4 < e3; t4++) {
              const e4 = c2[t4];
              i2.push(e4.x, e4.y, 0), r2.push(0, 0, 1), s2.push(e4.x, e4.y);
            }
            for (let t4 = 0, e3 = u2.length; t4 < e3; t4++) {
              const e4 = u2[t4], i3 = e4[0] + a3, r3 = e4[1] + a3, s3 = e4[2] + a3;
              n2.push(i3, r3, s3), o3 += 3;
            }
          }
          this.setIndex(n2), this.setAttribute("position", new un(i2, 3)), this.setAttribute("normal", new un(r2, 3)), this.setAttribute("uv", new un(s2, 2));
        }
        toJSON() {
          const t2 = super.toJSON();
          return function(t3, e2) {
            if (e2.shapes = [], Array.isArray(t3))
              for (let n2 = 0, i2 = t3.length; n2 < i2; n2++) {
                const i3 = t3[n2];
                e2.shapes.push(i3.uuid);
              }
            else
              e2.shapes.push(t3.uuid);
            return e2;
          }(this.parameters.shapes, t2);
        }
        static fromJSON(t2, e2) {
          const n2 = [];
          for (let i2 = 0, r2 = t2.shapes.length; i2 < r2; i2++) {
            const r3 = e2[t2.shapes[i2]];
            n2.push(r3);
          }
          return new vl(n2, t2.curveSegments);
        }
      }
      class yl extends wn {
        constructor(t2 = 1, e2 = 32, n2 = 16, i2 = 0, r2 = 2 * Math.PI, s2 = 0, a2 = Math.PI) {
          super(), this.type = "SphereGeometry", this.parameters = { radius: t2, widthSegments: e2, heightSegments: n2, phiStart: i2, phiLength: r2, thetaStart: s2, thetaLength: a2 }, e2 = Math.max(3, Math.floor(e2)), n2 = Math.max(2, Math.floor(n2));
          const o3 = Math.min(s2 + a2, Math.PI);
          let l2 = 0;
          const c2 = [], h2 = new Rt(), u2 = new Rt(), d2 = [], p2 = [], m2 = [], f2 = [];
          for (let d3 = 0; d3 <= n2; d3++) {
            const g2 = [], v2 = d3 / n2;
            let y2 = 0;
            0 == d3 && 0 == s2 ? y2 = 0.5 / e2 : d3 == n2 && o3 == Math.PI && (y2 = -0.5 / e2);
            for (let n3 = 0; n3 <= e2; n3++) {
              const o4 = n3 / e2;
              h2.x = -t2 * Math.cos(i2 + o4 * r2) * Math.sin(s2 + v2 * a2), h2.y = t2 * Math.cos(s2 + v2 * a2), h2.z = t2 * Math.sin(i2 + o4 * r2) * Math.sin(s2 + v2 * a2), p2.push(h2.x, h2.y, h2.z), u2.copy(h2).normalize(), m2.push(u2.x, u2.y, u2.z), f2.push(o4 + y2, 1 - v2), g2.push(l2++);
            }
            c2.push(g2);
          }
          for (let t3 = 0; t3 < n2; t3++)
            for (let i3 = 0; i3 < e2; i3++) {
              const e3 = c2[t3][i3 + 1], r3 = c2[t3][i3], a3 = c2[t3 + 1][i3], l3 = c2[t3 + 1][i3 + 1];
              (0 !== t3 || s2 > 0) && d2.push(e3, r3, l3), (t3 !== n2 - 1 || o3 < Math.PI) && d2.push(r3, a3, l3);
            }
          this.setIndex(d2), this.setAttribute("position", new un(p2, 3)), this.setAttribute("normal", new un(m2, 3)), this.setAttribute("uv", new un(f2, 2));
        }
        static fromJSON(t2) {
          return new yl(t2.radius, t2.widthSegments, t2.heightSegments, t2.phiStart, t2.phiLength, t2.thetaStart, t2.thetaLength);
        }
      }
      class xl extends lo {
        constructor(t2 = 1, e2 = 0) {
          super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t2, e2), this.type = "TetrahedronGeometry", this.parameters = { radius: t2, detail: e2 };
        }
        static fromJSON(t2) {
          return new xl(t2.radius, t2.detail);
        }
      }
      class _l extends hl {
        constructor(t2, e2 = {}) {
          const n2 = e2.font;
          if (!n2 || !n2.isFont)
            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new wn();
          const i2 = n2.generateShapes(t2, e2.size);
          e2.depth = void 0 !== e2.height ? e2.height : 50, void 0 === e2.bevelThickness && (e2.bevelThickness = 10), void 0 === e2.bevelSize && (e2.bevelSize = 8), void 0 === e2.bevelEnabled && (e2.bevelEnabled = false), super(i2, e2), this.type = "TextGeometry";
        }
      }
      class bl extends wn {
        constructor(t2 = 1, e2 = 0.4, n2 = 8, i2 = 6, r2 = 2 * Math.PI) {
          super(), this.type = "TorusGeometry", this.parameters = { radius: t2, tube: e2, radialSegments: n2, tubularSegments: i2, arc: r2 }, n2 = Math.floor(n2), i2 = Math.floor(i2);
          const s2 = [], a2 = [], o3 = [], l2 = [], c2 = new Rt(), h2 = new Rt(), u2 = new Rt();
          for (let s3 = 0; s3 <= n2; s3++)
            for (let d2 = 0; d2 <= i2; d2++) {
              const p2 = d2 / i2 * r2, m2 = s3 / n2 * Math.PI * 2;
              h2.x = (t2 + e2 * Math.cos(m2)) * Math.cos(p2), h2.y = (t2 + e2 * Math.cos(m2)) * Math.sin(p2), h2.z = e2 * Math.sin(m2), a2.push(h2.x, h2.y, h2.z), c2.x = t2 * Math.cos(p2), c2.y = t2 * Math.sin(p2), u2.subVectors(h2, c2).normalize(), o3.push(u2.x, u2.y, u2.z), l2.push(d2 / i2), l2.push(s3 / n2);
            }
          for (let t3 = 1; t3 <= n2; t3++)
            for (let e3 = 1; e3 <= i2; e3++) {
              const n3 = (i2 + 1) * t3 + e3 - 1, r3 = (i2 + 1) * (t3 - 1) + e3 - 1, a3 = (i2 + 1) * (t3 - 1) + e3, o4 = (i2 + 1) * t3 + e3;
              s2.push(n3, r3, o4), s2.push(r3, a3, o4);
            }
          this.setIndex(s2), this.setAttribute("position", new un(a2, 3)), this.setAttribute("normal", new un(o3, 3)), this.setAttribute("uv", new un(l2, 2));
        }
        static fromJSON(t2) {
          return new bl(t2.radius, t2.tube, t2.radialSegments, t2.tubularSegments, t2.arc);
        }
      }
      class Ml extends wn {
        constructor(t2 = 1, e2 = 0.4, n2 = 64, i2 = 8, r2 = 2, s2 = 3) {
          super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t2, tube: e2, tubularSegments: n2, radialSegments: i2, p: r2, q: s2 }, n2 = Math.floor(n2), i2 = Math.floor(i2);
          const a2 = [], o3 = [], l2 = [], c2 = [], h2 = new Rt(), u2 = new Rt(), d2 = new Rt(), p2 = new Rt(), m2 = new Rt(), f2 = new Rt(), g2 = new Rt();
          for (let a3 = 0; a3 <= n2; ++a3) {
            const y2 = a3 / n2 * r2 * Math.PI * 2;
            v2(y2, r2, s2, t2, d2), v2(y2 + 0.01, r2, s2, t2, p2), f2.subVectors(p2, d2), g2.addVectors(p2, d2), m2.crossVectors(f2, g2), g2.crossVectors(m2, f2), m2.normalize(), g2.normalize();
            for (let t3 = 0; t3 <= i2; ++t3) {
              const r3 = t3 / i2 * Math.PI * 2, s3 = -e2 * Math.cos(r3), p3 = e2 * Math.sin(r3);
              h2.x = d2.x + (s3 * g2.x + p3 * m2.x), h2.y = d2.y + (s3 * g2.y + p3 * m2.y), h2.z = d2.z + (s3 * g2.z + p3 * m2.z), o3.push(h2.x, h2.y, h2.z), u2.subVectors(h2, d2).normalize(), l2.push(u2.x, u2.y, u2.z), c2.push(a3 / n2), c2.push(t3 / i2);
            }
          }
          for (let t3 = 1; t3 <= n2; t3++)
            for (let e3 = 1; e3 <= i2; e3++) {
              const n3 = (i2 + 1) * (t3 - 1) + (e3 - 1), r3 = (i2 + 1) * t3 + (e3 - 1), s3 = (i2 + 1) * t3 + e3, o4 = (i2 + 1) * (t3 - 1) + e3;
              a2.push(n3, r3, o4), a2.push(r3, s3, o4);
            }
          function v2(t3, e3, n3, i3, r3) {
            const s3 = Math.cos(t3), a3 = Math.sin(t3), o4 = n3 / e3 * t3, l3 = Math.cos(o4);
            r3.x = i3 * (2 + l3) * 0.5 * s3, r3.y = i3 * (2 + l3) * a3 * 0.5, r3.z = i3 * Math.sin(o4) * 0.5;
          }
          this.setIndex(a2), this.setAttribute("position", new un(o3, 3)), this.setAttribute("normal", new un(l2, 3)), this.setAttribute("uv", new un(c2, 2));
        }
        static fromJSON(t2) {
          return new Ml(t2.radius, t2.tube, t2.tubularSegments, t2.radialSegments, t2.p, t2.q);
        }
      }
      class wl extends wn {
        constructor(t2, e2 = 64, n2 = 1, i2 = 8, r2 = false) {
          super(), this.type = "TubeGeometry", this.parameters = { path: t2, tubularSegments: e2, radius: n2, radialSegments: i2, closed: r2 };
          const s2 = t2.computeFrenetFrames(e2, r2);
          this.tangents = s2.tangents, this.normals = s2.normals, this.binormals = s2.binormals;
          const a2 = new Rt(), o3 = new Rt(), l2 = new vt();
          let c2 = new Rt();
          const h2 = [], u2 = [], d2 = [], p2 = [];
          function m2(r3) {
            c2 = t2.getPointAt(r3 / e2, c2);
            const l3 = s2.normals[r3], d3 = s2.binormals[r3];
            for (let t3 = 0; t3 <= i2; t3++) {
              const e3 = t3 / i2 * Math.PI * 2, r4 = Math.sin(e3), s3 = -Math.cos(e3);
              o3.x = s3 * l3.x + r4 * d3.x, o3.y = s3 * l3.y + r4 * d3.y, o3.z = s3 * l3.z + r4 * d3.z, o3.normalize(), u2.push(o3.x, o3.y, o3.z), a2.x = c2.x + n2 * o3.x, a2.y = c2.y + n2 * o3.y, a2.z = c2.z + n2 * o3.z, h2.push(a2.x, a2.y, a2.z);
            }
          }
          !function() {
            for (let t3 = 0; t3 < e2; t3++)
              m2(t3);
            m2(false === r2 ? e2 : 0), function() {
              for (let t3 = 0; t3 <= e2; t3++)
                for (let n3 = 0; n3 <= i2; n3++)
                  l2.x = t3 / e2, l2.y = n3 / i2, d2.push(l2.x, l2.y);
            }(), function() {
              for (let t3 = 1; t3 <= e2; t3++)
                for (let e3 = 1; e3 <= i2; e3++) {
                  const n3 = (i2 + 1) * (t3 - 1) + (e3 - 1), r3 = (i2 + 1) * t3 + (e3 - 1), s3 = (i2 + 1) * t3 + e3, a3 = (i2 + 1) * (t3 - 1) + e3;
                  p2.push(n3, r3, a3), p2.push(r3, s3, a3);
                }
            }();
          }(), this.setIndex(p2), this.setAttribute("position", new un(h2, 3)), this.setAttribute("normal", new un(u2, 3)), this.setAttribute("uv", new un(d2, 2));
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.path = this.parameters.path.toJSON(), t2;
        }
        static fromJSON(t2) {
          return new wl(new zo[t2.path.type]().fromJSON(t2.path), t2.tubularSegments, t2.radius, t2.radialSegments, t2.closed);
        }
      }
      class Sl extends wn {
        constructor(t2) {
          if (super(), this.type = "WireframeGeometry", true === t2.isGeometry)
            return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          const e2 = [], n2 = /* @__PURE__ */ new Set(), i2 = new Rt(), r2 = new Rt();
          if (null !== t2.index) {
            const s2 = t2.attributes.position, a2 = t2.index;
            let o3 = t2.groups;
            0 === o3.length && (o3 = [{ start: 0, count: a2.count, materialIndex: 0 }]);
            for (let t3 = 0, l2 = o3.length; t3 < l2; ++t3) {
              const l3 = o3[t3], c2 = l3.start;
              for (let t4 = c2, o4 = c2 + l3.count; t4 < o4; t4 += 3)
                for (let o5 = 0; o5 < 3; o5++) {
                  const l4 = a2.getX(t4 + o5), c3 = a2.getX(t4 + (o5 + 1) % 3);
                  i2.fromBufferAttribute(s2, l4), r2.fromBufferAttribute(s2, c3), true === Tl(i2, r2, n2) && (e2.push(i2.x, i2.y, i2.z), e2.push(r2.x, r2.y, r2.z));
                }
            }
          } else {
            const s2 = t2.attributes.position;
            for (let t3 = 0, a2 = s2.count / 3; t3 < a2; t3++)
              for (let a3 = 0; a3 < 3; a3++) {
                const o3 = 3 * t3 + a3, l2 = 3 * t3 + (a3 + 1) % 3;
                i2.fromBufferAttribute(s2, o3), r2.fromBufferAttribute(s2, l2), true === Tl(i2, r2, n2) && (e2.push(i2.x, i2.y, i2.z), e2.push(r2.x, r2.y, r2.z));
              }
          }
          this.setAttribute("position", new un(e2, 3));
        }
      }
      function Tl(t2, e2, n2) {
        const i2 = `${t2.x},${t2.y},${t2.z}-${e2.x},${e2.y},${e2.z}`, r2 = `${e2.x},${e2.y},${e2.z}-${t2.x},${t2.y},${t2.z}`;
        return true !== n2.has(i2) && true !== n2.has(r2) && (n2.add(i2, r2), true);
      }
      var El = Object.freeze({ __proto__: null, BoxGeometry: Vn, BoxBufferGeometry: Vn, CircleGeometry: so, CircleBufferGeometry: so, ConeGeometry: oo, ConeBufferGeometry: oo, CylinderGeometry: ao, CylinderBufferGeometry: ao, DodecahedronGeometry: co, DodecahedronBufferGeometry: co, EdgesGeometry: fo, ExtrudeGeometry: hl, ExtrudeBufferGeometry: hl, IcosahedronGeometry: dl, IcosahedronBufferGeometry: dl, LatheGeometry: pl, LatheBufferGeometry: pl, OctahedronGeometry: ml, OctahedronBufferGeometry: ml, ParametricGeometry: fl, ParametricBufferGeometry: fl, PlaneGeometry: ci, PlaneBufferGeometry: ci, PolyhedronGeometry: lo, PolyhedronBufferGeometry: lo, RingGeometry: gl, RingBufferGeometry: gl, ShapeGeometry: vl, ShapeBufferGeometry: vl, SphereGeometry: yl, SphereBufferGeometry: yl, TetrahedronGeometry: xl, TetrahedronBufferGeometry: xl, TextGeometry: _l, TextBufferGeometry: _l, TorusGeometry: bl, TorusBufferGeometry: bl, TorusKnotGeometry: Ml, TorusKnotBufferGeometry: Ml, TubeGeometry: wl, TubeBufferGeometry: wl, WireframeGeometry: Sl });
      class Al extends We {
        constructor(t2) {
          super(), this.type = "ShadowMaterial", this.color = new Qe(0), this.transparent = true, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this;
        }
      }
      Al.prototype.isShadowMaterial = true;
      class Ll extends We {
        constructor(t2) {
          super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Qe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.defines = { STANDARD: "" }, this.color.copy(t2.color), this.roughness = t2.roughness, this.metalness = t2.metalness, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.roughnessMap = t2.roughnessMap, this.metalnessMap = t2.metalnessMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.envMapIntensity = t2.envMapIntensity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.flatShading = t2.flatShading, this;
        }
      }
      Ll.prototype.isMeshStandardMaterial = true;
      class Rl extends Ll {
        constructor(t2) {
          super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new vt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
            return ht(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
          }, set: function(t3) {
            this.ior = (1 + 0.4 * t3) / (1 - 0.4 * t3);
          } }), this.sheenTint = new Qe(0), this.transmission = 0, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new Qe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new Qe(1, 1, 1), this.specularTintMap = null, this._clearcoat = 0, this._transmission = 0, this.setValues(t2);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(t2) {
          this._clearcoat > 0 != t2 > 0 && this.version++, this._clearcoat = t2;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(t2) {
          this._transmission > 0 != t2 > 0 && this.version++, this._transmission = t2;
        }
        copy(t2) {
          return super.copy(t2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t2.clearcoat, this.clearcoatMap = t2.clearcoatMap, this.clearcoatRoughness = t2.clearcoatRoughness, this.clearcoatRoughnessMap = t2.clearcoatRoughnessMap, this.clearcoatNormalMap = t2.clearcoatNormalMap, this.clearcoatNormalScale.copy(t2.clearcoatNormalScale), this.ior = t2.ior, this.sheenTint.copy(t2.sheenTint), this.transmission = t2.transmission, this.transmissionMap = t2.transmissionMap, this.thickness = t2.thickness, this.thicknessMap = t2.thicknessMap, this.attenuationDistance = t2.attenuationDistance, this.attenuationTint.copy(t2.attenuationTint), this.specularIntensity = t2.specularIntensity, this.specularIntensityMap = t2.specularIntensityMap, this.specularTint.copy(t2.specularTint), this.specularTintMap = t2.specularTintMap, this;
        }
      }
      Rl.prototype.isMeshPhysicalMaterial = true;
      class Cl extends We {
        constructor(t2) {
          super(), this.type = "MeshPhongMaterial", this.color = new Qe(16777215), this.specular = new Qe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.specular.copy(t2.specular), this.shininess = t2.shininess, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.flatShading = t2.flatShading, this;
        }
      }
      Cl.prototype.isMeshPhongMaterial = true;
      class Pl extends We {
        constructor(t2) {
          super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Qe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.gradientMap = t2.gradientMap, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this;
        }
      }
      Pl.prototype.isMeshToonMaterial = true;
      class Il extends We {
        constructor(t2) {
          super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.flatShading = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.flatShading = t2.flatShading, this;
        }
      }
      Il.prototype.isMeshNormalMaterial = true;
      class Dl extends We {
        constructor(t2) {
          super(), this.type = "MeshLambertMaterial", this.color = new Qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this;
        }
      }
      Dl.prototype.isMeshLambertMaterial = true;
      class Nl extends We {
        constructor(t2) {
          super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Qe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.defines = { MATCAP: "" }, this.color.copy(t2.color), this.matcap = t2.matcap, this.map = t2.map, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.flatShading = t2.flatShading, this;
        }
      }
      Nl.prototype.isMeshMatcapMaterial = true;
      class zl extends Fa {
        constructor(t2) {
          super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.scale = t2.scale, this.dashSize = t2.dashSize, this.gapSize = t2.gapSize, this;
        }
      }
      zl.prototype.isLineDashedMaterial = true;
      var Bl = Object.freeze({ __proto__: null, ShadowMaterial: Al, SpriteMaterial: ea, RawShaderMaterial: _i, ShaderMaterial: Xn, PointsMaterial: Ya, MeshPhysicalMaterial: Rl, MeshStandardMaterial: Ll, MeshPhongMaterial: Cl, MeshToonMaterial: Pl, MeshNormalMaterial: Il, MeshLambertMaterial: Dl, MeshDepthMaterial: zs, MeshDistanceMaterial: Bs, MeshBasicMaterial: Ke, MeshMatcapMaterial: Nl, LineDashedMaterial: zl, LineBasicMaterial: Fa, Material: We });
      const Fl = { arraySlice: function(t2, e2, n2) {
        return Fl.isTypedArray(t2) ? new t2.constructor(t2.subarray(e2, void 0 !== n2 ? n2 : t2.length)) : t2.slice(e2, n2);
      }, convertArray: function(t2, e2, n2) {
        return !t2 || !n2 && t2.constructor === e2 ? t2 : "number" == typeof e2.BYTES_PER_ELEMENT ? new e2(t2) : Array.prototype.slice.call(t2);
      }, isTypedArray: function(t2) {
        return ArrayBuffer.isView(t2) && !(t2 instanceof DataView);
      }, getKeyframeOrder: function(t2) {
        const e2 = t2.length, n2 = new Array(e2);
        for (let t3 = 0; t3 !== e2; ++t3)
          n2[t3] = t3;
        return n2.sort(function(e3, n3) {
          return t2[e3] - t2[n3];
        }), n2;
      }, sortedArray: function(t2, e2, n2) {
        const i2 = t2.length, r2 = new t2.constructor(i2);
        for (let s2 = 0, a2 = 0; a2 !== i2; ++s2) {
          const i3 = n2[s2] * e2;
          for (let n3 = 0; n3 !== e2; ++n3)
            r2[a2++] = t2[i3 + n3];
        }
        return r2;
      }, flattenJSON: function(t2, e2, n2, i2) {
        let r2 = 1, s2 = t2[0];
        for (; void 0 !== s2 && void 0 === s2[i2]; )
          s2 = t2[r2++];
        if (void 0 === s2)
          return;
        let a2 = s2[i2];
        if (void 0 !== a2)
          if (Array.isArray(a2))
            do {
              a2 = s2[i2], void 0 !== a2 && (e2.push(s2.time), n2.push.apply(n2, a2)), s2 = t2[r2++];
            } while (void 0 !== s2);
          else if (void 0 !== a2.toArray)
            do {
              a2 = s2[i2], void 0 !== a2 && (e2.push(s2.time), a2.toArray(n2, n2.length)), s2 = t2[r2++];
            } while (void 0 !== s2);
          else
            do {
              a2 = s2[i2], void 0 !== a2 && (e2.push(s2.time), n2.push(a2)), s2 = t2[r2++];
            } while (void 0 !== s2);
      }, subclip: function(t2, e2, n2, i2, r2 = 30) {
        const s2 = t2.clone();
        s2.name = e2;
        const a2 = [];
        for (let t3 = 0; t3 < s2.tracks.length; ++t3) {
          const e3 = s2.tracks[t3], o4 = e3.getValueSize(), l2 = [], c2 = [];
          for (let t4 = 0; t4 < e3.times.length; ++t4) {
            const s3 = e3.times[t4] * r2;
            if (!(s3 < n2 || s3 >= i2)) {
              l2.push(e3.times[t4]);
              for (let n3 = 0; n3 < o4; ++n3)
                c2.push(e3.values[t4 * o4 + n3]);
            }
          }
          0 !== l2.length && (e3.times = Fl.convertArray(l2, e3.times.constructor), e3.values = Fl.convertArray(c2, e3.values.constructor), a2.push(e3));
        }
        s2.tracks = a2;
        let o3 = 1 / 0;
        for (let t3 = 0; t3 < s2.tracks.length; ++t3)
          o3 > s2.tracks[t3].times[0] && (o3 = s2.tracks[t3].times[0]);
        for (let t3 = 0; t3 < s2.tracks.length; ++t3)
          s2.tracks[t3].shift(-1 * o3);
        return s2.resetDuration(), s2;
      }, makeClipAdditive: function(t2, e2 = 0, n2 = t2, i2 = 30) {
        i2 <= 0 && (i2 = 30);
        const r2 = n2.tracks.length, s2 = e2 / i2;
        for (let e3 = 0; e3 < r2; ++e3) {
          const i3 = n2.tracks[e3], r3 = i3.ValueTypeName;
          if ("bool" === r3 || "string" === r3)
            continue;
          const a2 = t2.tracks.find(function(t3) {
            return t3.name === i3.name && t3.ValueTypeName === r3;
          });
          if (void 0 === a2)
            continue;
          let o3 = 0;
          const l2 = i3.getValueSize();
          i3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o3 = l2 / 3);
          let c2 = 0;
          const h2 = a2.getValueSize();
          a2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c2 = h2 / 3);
          const u2 = i3.times.length - 1;
          let d2;
          if (s2 <= i3.times[0]) {
            const t3 = o3, e4 = l2 - o3;
            d2 = Fl.arraySlice(i3.values, t3, e4);
          } else if (s2 >= i3.times[u2]) {
            const t3 = u2 * l2 + o3, e4 = t3 + l2 - o3;
            d2 = Fl.arraySlice(i3.values, t3, e4);
          } else {
            const t3 = i3.createInterpolant(), e4 = o3, n3 = l2 - o3;
            t3.evaluate(s2), d2 = Fl.arraySlice(t3.resultBuffer, e4, n3);
          }
          if ("quaternion" === r3) {
            new Lt().fromArray(d2).normalize().conjugate().toArray(d2);
          }
          const p2 = a2.times.length;
          for (let t3 = 0; t3 < p2; ++t3) {
            const e4 = t3 * h2 + c2;
            if ("quaternion" === r3)
              Lt.multiplyQuaternionsFlat(a2.values, e4, d2, 0, a2.values, e4);
            else {
              const t4 = h2 - 2 * c2;
              for (let n3 = 0; n3 < t4; ++n3)
                a2.values[e4 + n3] -= d2[n3];
            }
          }
        }
        return t2.blendMode = q, t2;
      } };
      class Ol {
        constructor(t2, e2, n2, i2) {
          this.parameterPositions = t2, this._cachedIndex = 0, this.resultBuffer = void 0 !== i2 ? i2 : new e2.constructor(n2), this.sampleValues = e2, this.valueSize = n2, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(t2) {
          const e2 = this.parameterPositions;
          let n2 = this._cachedIndex, i2 = e2[n2], r2 = e2[n2 - 1];
          t: {
            e: {
              let s2;
              n: {
                i:
                  if (!(t2 < i2)) {
                    for (let s3 = n2 + 2; ; ) {
                      if (void 0 === i2) {
                        if (t2 < r2)
                          break i;
                        return n2 = e2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, t2, r2);
                      }
                      if (n2 === s3)
                        break;
                      if (r2 = i2, i2 = e2[++n2], t2 < i2)
                        break e;
                    }
                    s2 = e2.length;
                    break n;
                  }
                if (t2 >= r2)
                  break t;
                {
                  const a2 = e2[1];
                  t2 < a2 && (n2 = 2, r2 = a2);
                  for (let s3 = n2 - 2; ; ) {
                    if (void 0 === r2)
                      return this._cachedIndex = 0, this.beforeStart_(0, t2, i2);
                    if (n2 === s3)
                      break;
                    if (i2 = r2, r2 = e2[--n2 - 1], t2 >= r2)
                      break e;
                  }
                  s2 = n2, n2 = 0;
                }
              }
              for (; n2 < s2; ) {
                const i3 = n2 + s2 >>> 1;
                t2 < e2[i3] ? s2 = i3 : n2 = i3 + 1;
              }
              if (i2 = e2[n2], r2 = e2[n2 - 1], void 0 === r2)
                return this._cachedIndex = 0, this.beforeStart_(0, t2, i2);
              if (void 0 === i2)
                return n2 = e2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, r2, t2);
            }
            this._cachedIndex = n2, this.intervalChanged_(n2, r2, i2);
          }
          return this.interpolate_(n2, r2, t2, i2);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t2) {
          const e2 = this.resultBuffer, n2 = this.sampleValues, i2 = this.valueSize, r2 = t2 * i2;
          for (let t3 = 0; t3 !== i2; ++t3)
            e2[t3] = n2[r2 + t3];
          return e2;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      }
      Ol.prototype.beforeStart_ = Ol.prototype.copySampleValue_, Ol.prototype.afterEnd_ = Ol.prototype.copySampleValue_;
      class Ul extends Ol {
        constructor(t2, e2, n2, i2) {
          super(t2, e2, n2, i2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: k, endingEnd: k };
        }
        intervalChanged_(t2, e2, n2) {
          const i2 = this.parameterPositions;
          let r2 = t2 - 2, s2 = t2 + 1, a2 = i2[r2], o3 = i2[s2];
          if (void 0 === a2)
            switch (this.getSettings_().endingStart) {
              case V:
                r2 = t2, a2 = 2 * e2 - n2;
                break;
              case W:
                r2 = i2.length - 2, a2 = e2 + i2[r2] - i2[r2 + 1];
                break;
              default:
                r2 = t2, a2 = n2;
            }
          if (void 0 === o3)
            switch (this.getSettings_().endingEnd) {
              case V:
                s2 = t2, o3 = 2 * n2 - e2;
                break;
              case W:
                s2 = 1, o3 = n2 + i2[1] - i2[0];
                break;
              default:
                s2 = t2 - 1, o3 = e2;
            }
          const l2 = 0.5 * (n2 - e2), c2 = this.valueSize;
          this._weightPrev = l2 / (e2 - a2), this._weightNext = l2 / (o3 - n2), this._offsetPrev = r2 * c2, this._offsetNext = s2 * c2;
        }
        interpolate_(t2, e2, n2, i2) {
          const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o3 = t2 * a2, l2 = o3 - a2, c2 = this._offsetPrev, h2 = this._offsetNext, u2 = this._weightPrev, d2 = this._weightNext, p2 = (n2 - e2) / (i2 - e2), m2 = p2 * p2, f2 = m2 * p2, g2 = -u2 * f2 + 2 * u2 * m2 - u2 * p2, v2 = (1 + u2) * f2 + (-1.5 - 2 * u2) * m2 + (-0.5 + u2) * p2 + 1, y2 = (-1 - d2) * f2 + (1.5 + d2) * m2 + 0.5 * p2, x2 = d2 * f2 - d2 * m2;
          for (let t3 = 0; t3 !== a2; ++t3)
            r2[t3] = g2 * s2[c2 + t3] + v2 * s2[l2 + t3] + y2 * s2[o3 + t3] + x2 * s2[h2 + t3];
          return r2;
        }
      }
      class Hl extends Ol {
        constructor(t2, e2, n2, i2) {
          super(t2, e2, n2, i2);
        }
        interpolate_(t2, e2, n2, i2) {
          const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o3 = t2 * a2, l2 = o3 - a2, c2 = (n2 - e2) / (i2 - e2), h2 = 1 - c2;
          for (let t3 = 0; t3 !== a2; ++t3)
            r2[t3] = s2[l2 + t3] * h2 + s2[o3 + t3] * c2;
          return r2;
        }
      }
      class Gl extends Ol {
        constructor(t2, e2, n2, i2) {
          super(t2, e2, n2, i2);
        }
        interpolate_(t2) {
          return this.copySampleValue_(t2 - 1);
        }
      }
      class kl {
        constructor(t2, e2, n2, i2) {
          if (void 0 === t2)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === e2 || 0 === e2.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t2);
          this.name = t2, this.times = Fl.convertArray(e2, this.TimeBufferType), this.values = Fl.convertArray(n2, this.ValueBufferType), this.setInterpolation(i2 || this.DefaultInterpolation);
        }
        static toJSON(t2) {
          const e2 = t2.constructor;
          let n2;
          if (e2.toJSON !== this.toJSON)
            n2 = e2.toJSON(t2);
          else {
            n2 = { name: t2.name, times: Fl.convertArray(t2.times, Array), values: Fl.convertArray(t2.values, Array) };
            const e3 = t2.getInterpolation();
            e3 !== t2.DefaultInterpolation && (n2.interpolation = e3);
          }
          return n2.type = t2.ValueTypeName, n2;
        }
        InterpolantFactoryMethodDiscrete(t2) {
          return new Gl(this.times, this.values, this.getValueSize(), t2);
        }
        InterpolantFactoryMethodLinear(t2) {
          return new Hl(this.times, this.values, this.getValueSize(), t2);
        }
        InterpolantFactoryMethodSmooth(t2) {
          return new Ul(this.times, this.values, this.getValueSize(), t2);
        }
        setInterpolation(t2) {
          let e2;
          switch (t2) {
            case U:
              e2 = this.InterpolantFactoryMethodDiscrete;
              break;
            case H:
              e2 = this.InterpolantFactoryMethodLinear;
              break;
            case G:
              e2 = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e2) {
            const e3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
              if (t2 === this.DefaultInterpolation)
                throw new Error(e3);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", e3), this;
          }
          return this.createInterpolant = e2, this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return U;
            case this.InterpolantFactoryMethodLinear:
              return H;
            case this.InterpolantFactoryMethodSmooth:
              return G;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(t2) {
          if (0 !== t2) {
            const e2 = this.times;
            for (let n2 = 0, i2 = e2.length; n2 !== i2; ++n2)
              e2[n2] += t2;
          }
          return this;
        }
        scale(t2) {
          if (1 !== t2) {
            const e2 = this.times;
            for (let n2 = 0, i2 = e2.length; n2 !== i2; ++n2)
              e2[n2] *= t2;
          }
          return this;
        }
        trim(t2, e2) {
          const n2 = this.times, i2 = n2.length;
          let r2 = 0, s2 = i2 - 1;
          for (; r2 !== i2 && n2[r2] < t2; )
            ++r2;
          for (; -1 !== s2 && n2[s2] > e2; )
            --s2;
          if (++s2, 0 !== r2 || s2 !== i2) {
            r2 >= s2 && (s2 = Math.max(s2, 1), r2 = s2 - 1);
            const t3 = this.getValueSize();
            this.times = Fl.arraySlice(n2, r2, s2), this.values = Fl.arraySlice(this.values, r2 * t3, s2 * t3);
          }
          return this;
        }
        validate() {
          let t2 = true;
          const e2 = this.getValueSize();
          e2 - Math.floor(e2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t2 = false);
          const n2 = this.times, i2 = this.values, r2 = n2.length;
          0 === r2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t2 = false);
          let s2 = null;
          for (let e3 = 0; e3 !== r2; e3++) {
            const i3 = n2[e3];
            if ("number" == typeof i3 && isNaN(i3)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e3, i3), t2 = false;
              break;
            }
            if (null !== s2 && s2 > i3) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, e3, i3, s2), t2 = false;
              break;
            }
            s2 = i3;
          }
          if (void 0 !== i2 && Fl.isTypedArray(i2))
            for (let e3 = 0, n3 = i2.length; e3 !== n3; ++e3) {
              const n4 = i2[e3];
              if (isNaN(n4)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e3, n4), t2 = false;
                break;
              }
            }
          return t2;
        }
        optimize() {
          const t2 = Fl.arraySlice(this.times), e2 = Fl.arraySlice(this.values), n2 = this.getValueSize(), i2 = this.getInterpolation() === G, r2 = t2.length - 1;
          let s2 = 1;
          for (let a2 = 1; a2 < r2; ++a2) {
            let r3 = false;
            const o3 = t2[a2];
            if (o3 !== t2[a2 + 1] && (1 !== a2 || o3 !== t2[0]))
              if (i2)
                r3 = true;
              else {
                const t3 = a2 * n2, i3 = t3 - n2, s3 = t3 + n2;
                for (let a3 = 0; a3 !== n2; ++a3) {
                  const n3 = e2[t3 + a3];
                  if (n3 !== e2[i3 + a3] || n3 !== e2[s3 + a3]) {
                    r3 = true;
                    break;
                  }
                }
              }
            if (r3) {
              if (a2 !== s2) {
                t2[s2] = t2[a2];
                const i3 = a2 * n2, r4 = s2 * n2;
                for (let t3 = 0; t3 !== n2; ++t3)
                  e2[r4 + t3] = e2[i3 + t3];
              }
              ++s2;
            }
          }
          if (r2 > 0) {
            t2[s2] = t2[r2];
            for (let t3 = r2 * n2, i3 = s2 * n2, a2 = 0; a2 !== n2; ++a2)
              e2[i3 + a2] = e2[t3 + a2];
            ++s2;
          }
          return s2 !== t2.length ? (this.times = Fl.arraySlice(t2, 0, s2), this.values = Fl.arraySlice(e2, 0, s2 * n2)) : (this.times = t2, this.values = e2), this;
        }
        clone() {
          const t2 = Fl.arraySlice(this.times, 0), e2 = Fl.arraySlice(this.values, 0), n2 = new (0, this.constructor)(this.name, t2, e2);
          return n2.createInterpolant = this.createInterpolant, n2;
        }
      }
      kl.prototype.TimeBufferType = Float32Array, kl.prototype.ValueBufferType = Float32Array, kl.prototype.DefaultInterpolation = H;
      class Vl extends kl {
      }
      Vl.prototype.ValueTypeName = "bool", Vl.prototype.ValueBufferType = Array, Vl.prototype.DefaultInterpolation = U, Vl.prototype.InterpolantFactoryMethodLinear = void 0, Vl.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Wl extends kl {
      }
      Wl.prototype.ValueTypeName = "color";
      class jl extends kl {
      }
      jl.prototype.ValueTypeName = "number";
      class ql extends Ol {
        constructor(t2, e2, n2, i2) {
          super(t2, e2, n2, i2);
        }
        interpolate_(t2, e2, n2, i2) {
          const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o3 = (n2 - e2) / (i2 - e2);
          let l2 = t2 * a2;
          for (let t3 = l2 + a2; l2 !== t3; l2 += 4)
            Lt.slerpFlat(r2, 0, s2, l2 - a2, s2, l2, o3);
          return r2;
        }
      }
      class Xl extends kl {
        InterpolantFactoryMethodLinear(t2) {
          return new ql(this.times, this.values, this.getValueSize(), t2);
        }
      }
      Xl.prototype.ValueTypeName = "quaternion", Xl.prototype.DefaultInterpolation = H, Xl.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Yl extends kl {
      }
      Yl.prototype.ValueTypeName = "string", Yl.prototype.ValueBufferType = Array, Yl.prototype.DefaultInterpolation = U, Yl.prototype.InterpolantFactoryMethodLinear = void 0, Yl.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Jl extends kl {
      }
      Jl.prototype.ValueTypeName = "vector";
      class Zl {
        constructor(t2, e2 = -1, n2, i2 = 2500) {
          this.name = t2, this.tracks = n2, this.duration = e2, this.blendMode = i2, this.uuid = ct(), this.duration < 0 && this.resetDuration();
        }
        static parse(t2) {
          const e2 = [], n2 = t2.tracks, i2 = 1 / (t2.fps || 1);
          for (let t3 = 0, r3 = n2.length; t3 !== r3; ++t3)
            e2.push(Ql(n2[t3]).scale(i2));
          const r2 = new this(t2.name, t2.duration, e2, t2.blendMode);
          return r2.uuid = t2.uuid, r2;
        }
        static toJSON(t2) {
          const e2 = [], n2 = t2.tracks, i2 = { name: t2.name, duration: t2.duration, tracks: e2, uuid: t2.uuid, blendMode: t2.blendMode };
          for (let t3 = 0, i3 = n2.length; t3 !== i3; ++t3)
            e2.push(kl.toJSON(n2[t3]));
          return i2;
        }
        static CreateFromMorphTargetSequence(t2, e2, n2, i2) {
          const r2 = e2.length, s2 = [];
          for (let t3 = 0; t3 < r2; t3++) {
            let a2 = [], o3 = [];
            a2.push((t3 + r2 - 1) % r2, t3, (t3 + 1) % r2), o3.push(0, 1, 0);
            const l2 = Fl.getKeyframeOrder(a2);
            a2 = Fl.sortedArray(a2, 1, l2), o3 = Fl.sortedArray(o3, 1, l2), i2 || 0 !== a2[0] || (a2.push(r2), o3.push(o3[0])), s2.push(new jl(".morphTargetInfluences[" + e2[t3].name + "]", a2, o3).scale(1 / n2));
          }
          return new this(t2, -1, s2);
        }
        static findByName(t2, e2) {
          let n2 = t2;
          if (!Array.isArray(t2)) {
            const e3 = t2;
            n2 = e3.geometry && e3.geometry.animations || e3.animations;
          }
          for (let t3 = 0; t3 < n2.length; t3++)
            if (n2[t3].name === e2)
              return n2[t3];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(t2, e2, n2) {
          const i2 = {}, r2 = /^([\w-]*?)([\d]+)$/;
          for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) {
            const n4 = t2[e3], s3 = n4.name.match(r2);
            if (s3 && s3.length > 1) {
              const t3 = s3[1];
              let e4 = i2[t3];
              e4 || (i2[t3] = e4 = []), e4.push(n4);
            }
          }
          const s2 = [];
          for (const t3 in i2)
            s2.push(this.CreateFromMorphTargetSequence(t3, i2[t3], e2, n2));
          return s2;
        }
        static parseAnimation(t2, e2) {
          if (!t2)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          const n2 = function(t3, e3, n3, i3, r3) {
            if (0 !== n3.length) {
              const s3 = [], a3 = [];
              Fl.flattenJSON(n3, s3, a3, i3), 0 !== s3.length && r3.push(new t3(e3, s3, a3));
            }
          }, i2 = [], r2 = t2.name || "default", s2 = t2.fps || 30, a2 = t2.blendMode;
          let o3 = t2.length || -1;
          const l2 = t2.hierarchy || [];
          for (let t3 = 0; t3 < l2.length; t3++) {
            const r3 = l2[t3].keys;
            if (r3 && 0 !== r3.length)
              if (r3[0].morphTargets) {
                const t4 = {};
                let e3;
                for (e3 = 0; e3 < r3.length; e3++)
                  if (r3[e3].morphTargets)
                    for (let n3 = 0; n3 < r3[e3].morphTargets.length; n3++)
                      t4[r3[e3].morphTargets[n3]] = -1;
                for (const n3 in t4) {
                  const t5 = [], s3 = [];
                  for (let i3 = 0; i3 !== r3[e3].morphTargets.length; ++i3) {
                    const i4 = r3[e3];
                    t5.push(i4.time), s3.push(i4.morphTarget === n3 ? 1 : 0);
                  }
                  i2.push(new jl(".morphTargetInfluence[" + n3 + "]", t5, s3));
                }
                o3 = t4.length * (s2 || 1);
              } else {
                const s3 = ".bones[" + e2[t3].name + "]";
                n2(Jl, s3 + ".position", r3, "pos", i2), n2(Xl, s3 + ".quaternion", r3, "rot", i2), n2(Jl, s3 + ".scale", r3, "scl", i2);
              }
          }
          if (0 === i2.length)
            return null;
          return new this(r2, o3, i2, a2);
        }
        resetDuration() {
          let t2 = 0;
          for (let e2 = 0, n2 = this.tracks.length; e2 !== n2; ++e2) {
            const n3 = this.tracks[e2];
            t2 = Math.max(t2, n3.times[n3.times.length - 1]);
          }
          return this.duration = t2, this;
        }
        trim() {
          for (let t2 = 0; t2 < this.tracks.length; t2++)
            this.tracks[t2].trim(0, this.duration);
          return this;
        }
        validate() {
          let t2 = true;
          for (let e2 = 0; e2 < this.tracks.length; e2++)
            t2 = t2 && this.tracks[e2].validate();
          return t2;
        }
        optimize() {
          for (let t2 = 0; t2 < this.tracks.length; t2++)
            this.tracks[t2].optimize();
          return this;
        }
        clone() {
          const t2 = [];
          for (let e2 = 0; e2 < this.tracks.length; e2++)
            t2.push(this.tracks[e2].clone());
          return new this.constructor(this.name, this.duration, t2, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Ql(t2) {
        if (void 0 === t2.type)
          throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e2 = function(t3) {
          switch (t3.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return jl;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Jl;
            case "color":
              return Wl;
            case "quaternion":
              return Xl;
            case "bool":
            case "boolean":
              return Vl;
            case "string":
              return Yl;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t3);
        }(t2.type);
        if (void 0 === t2.times) {
          const e3 = [], n2 = [];
          Fl.flattenJSON(t2.keys, e3, n2, "value"), t2.times = e3, t2.values = n2;
        }
        return void 0 !== e2.parse ? e2.parse(t2) : new e2(t2.name, t2.times, t2.values, t2.interpolation);
      }
      const Kl = { enabled: false, files: {}, add: function(t2, e2) {
        false !== this.enabled && (this.files[t2] = e2);
      }, get: function(t2) {
        if (false !== this.enabled)
          return this.files[t2];
      }, remove: function(t2) {
        delete this.files[t2];
      }, clear: function() {
        this.files = {};
      } };
      class $l {
        constructor(t2, e2, n2) {
          const i2 = this;
          let r2, s2 = false, a2 = 0, o3 = 0;
          const l2 = [];
          this.onStart = void 0, this.onLoad = t2, this.onProgress = e2, this.onError = n2, this.itemStart = function(t3) {
            o3++, false === s2 && void 0 !== i2.onStart && i2.onStart(t3, a2, o3), s2 = true;
          }, this.itemEnd = function(t3) {
            a2++, void 0 !== i2.onProgress && i2.onProgress(t3, a2, o3), a2 === o3 && (s2 = false, void 0 !== i2.onLoad && i2.onLoad());
          }, this.itemError = function(t3) {
            void 0 !== i2.onError && i2.onError(t3);
          }, this.resolveURL = function(t3) {
            return r2 ? r2(t3) : t3;
          }, this.setURLModifier = function(t3) {
            return r2 = t3, this;
          }, this.addHandler = function(t3, e3) {
            return l2.push(t3, e3), this;
          }, this.removeHandler = function(t3) {
            const e3 = l2.indexOf(t3);
            return -1 !== e3 && l2.splice(e3, 2), this;
          }, this.getHandler = function(t3) {
            for (let e3 = 0, n3 = l2.length; e3 < n3; e3 += 2) {
              const n4 = l2[e3], i3 = l2[e3 + 1];
              if (n4.global && (n4.lastIndex = 0), n4.test(t3))
                return i3;
            }
            return null;
          };
        }
      }
      const tc = new $l();
      class ec {
        constructor(t2) {
          this.manager = void 0 !== t2 ? t2 : tc, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {
        }
        loadAsync(t2, e2) {
          const n2 = this;
          return new Promise(function(i2, r2) {
            n2.load(t2, i2, e2, r2);
          });
        }
        parse() {
        }
        setCrossOrigin(t2) {
          return this.crossOrigin = t2, this;
        }
        setWithCredentials(t2) {
          return this.withCredentials = t2, this;
        }
        setPath(t2) {
          return this.path = t2, this;
        }
        setResourcePath(t2) {
          return this.resourcePath = t2, this;
        }
        setRequestHeader(t2) {
          return this.requestHeader = t2, this;
        }
      }
      const nc = {};
      class ic extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          void 0 === t2 && (t2 = ""), void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
          const r2 = this, s2 = Kl.get(t2);
          if (void 0 !== s2)
            return r2.manager.itemStart(t2), setTimeout(function() {
              e2 && e2(s2), r2.manager.itemEnd(t2);
            }, 0), s2;
          if (void 0 !== nc[t2])
            return void nc[t2].push({ onLoad: e2, onProgress: n2, onError: i2 });
          const a2 = t2.match(/^data:(.*?)(;base64)?,(.*)$/);
          let o3;
          if (a2) {
            const n3 = a2[1], s3 = !!a2[2];
            let o4 = a2[3];
            o4 = decodeURIComponent(o4), s3 && (o4 = atob(o4));
            try {
              let i3;
              const s4 = (this.responseType || "").toLowerCase();
              switch (s4) {
                case "arraybuffer":
                case "blob":
                  const t3 = new Uint8Array(o4.length);
                  for (let e4 = 0; e4 < o4.length; e4++)
                    t3[e4] = o4.charCodeAt(e4);
                  i3 = "blob" === s4 ? new Blob([t3.buffer], { type: n3 }) : t3.buffer;
                  break;
                case "document":
                  const e3 = new DOMParser();
                  i3 = e3.parseFromString(o4, n3);
                  break;
                case "json":
                  i3 = JSON.parse(o4);
                  break;
                default:
                  i3 = o4;
              }
              setTimeout(function() {
                e2 && e2(i3), r2.manager.itemEnd(t2);
              }, 0);
            } catch (e3) {
              setTimeout(function() {
                i2 && i2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
              }, 0);
            }
          } else {
            nc[t2] = [], nc[t2].push({ onLoad: e2, onProgress: n2, onError: i2 }), o3 = new XMLHttpRequest(), o3.open("GET", t2, true), o3.addEventListener("load", function(e3) {
              const n3 = this.response, i3 = nc[t2];
              if (delete nc[t2], 200 === this.status || 0 === this.status) {
                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Kl.add(t2, n3);
                for (let t3 = 0, e4 = i3.length; t3 < e4; t3++) {
                  const e5 = i3[t3];
                  e5.onLoad && e5.onLoad(n3);
                }
                r2.manager.itemEnd(t2);
              } else {
                for (let t3 = 0, n4 = i3.length; t3 < n4; t3++) {
                  const n5 = i3[t3];
                  n5.onError && n5.onError(e3);
                }
                r2.manager.itemError(t2), r2.manager.itemEnd(t2);
              }
            }, false), o3.addEventListener("progress", function(e3) {
              const n3 = nc[t2];
              for (let t3 = 0, i3 = n3.length; t3 < i3; t3++) {
                const i4 = n3[t3];
                i4.onProgress && i4.onProgress(e3);
              }
            }, false), o3.addEventListener("error", function(e3) {
              const n3 = nc[t2];
              delete nc[t2];
              for (let t3 = 0, i3 = n3.length; t3 < i3; t3++) {
                const i4 = n3[t3];
                i4.onError && i4.onError(e3);
              }
              r2.manager.itemError(t2), r2.manager.itemEnd(t2);
            }, false), o3.addEventListener("abort", function(e3) {
              const n3 = nc[t2];
              delete nc[t2];
              for (let t3 = 0, i3 = n3.length; t3 < i3; t3++) {
                const i4 = n3[t3];
                i4.onError && i4.onError(e3);
              }
              r2.manager.itemError(t2), r2.manager.itemEnd(t2);
            }, false), void 0 !== this.responseType && (o3.responseType = this.responseType), void 0 !== this.withCredentials && (o3.withCredentials = this.withCredentials), o3.overrideMimeType && o3.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
            for (const t3 in this.requestHeader)
              o3.setRequestHeader(t3, this.requestHeader[t3]);
            o3.send(null);
          }
          return r2.manager.itemStart(t2), o3;
        }
        setResponseType(t2) {
          return this.responseType = t2, this;
        }
        setMimeType(t2) {
          return this.mimeType = t2, this;
        }
      }
      class rc extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
          const r2 = this, s2 = Kl.get(t2);
          if (void 0 !== s2)
            return r2.manager.itemStart(t2), setTimeout(function() {
              e2 && e2(s2), r2.manager.itemEnd(t2);
            }, 0), s2;
          const a2 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
          function o3() {
            a2.removeEventListener("load", o3, false), a2.removeEventListener("error", l2, false), Kl.add(t2, this), e2 && e2(this), r2.manager.itemEnd(t2);
          }
          function l2(e3) {
            a2.removeEventListener("load", o3, false), a2.removeEventListener("error", l2, false), i2 && i2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
          }
          return a2.addEventListener("load", o3, false), a2.addEventListener("error", l2, false), "data:" !== t2.substr(0, 5) && void 0 !== this.crossOrigin && (a2.crossOrigin = this.crossOrigin), r2.manager.itemStart(t2), a2.src = t2, a2;
        }
      }
      class sc extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = new Kn(), s2 = new rc(this.manager);
          s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path);
          let a2 = 0;
          function o3(n3) {
            s2.load(t2[n3], function(t3) {
              r2.images[n3] = t3, a2++, 6 === a2 && (r2.needsUpdate = true, e2 && e2(r2));
            }, void 0, i2);
          }
          for (let e3 = 0; e3 < t2.length; ++e3)
            o3(e3);
          return r2;
        }
      }
      class ac extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = this, s2 = new Aa(), a2 = new ic(this.manager);
          return a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setPath(this.path), a2.setWithCredentials(r2.withCredentials), a2.load(t2, function(t3) {
            const n3 = r2.parse(t3);
            n3 && (void 0 !== n3.image ? s2.image = n3.image : void 0 !== n3.data && (s2.image.width = n3.width, s2.image.height = n3.height, s2.image.data = n3.data), s2.wrapS = void 0 !== n3.wrapS ? n3.wrapS : u, s2.wrapT = void 0 !== n3.wrapT ? n3.wrapT : u, s2.magFilter = void 0 !== n3.magFilter ? n3.magFilter : g, s2.minFilter = void 0 !== n3.minFilter ? n3.minFilter : g, s2.anisotropy = void 0 !== n3.anisotropy ? n3.anisotropy : 1, void 0 !== n3.encoding && (s2.encoding = n3.encoding), void 0 !== n3.flipY && (s2.flipY = n3.flipY), void 0 !== n3.format && (s2.format = n3.format), void 0 !== n3.type && (s2.type = n3.type), void 0 !== n3.mipmaps && (s2.mipmaps = n3.mipmaps, s2.minFilter = y), 1 === n3.mipmapCount && (s2.minFilter = g), void 0 !== n3.generateMipmaps && (s2.generateMipmaps = n3.generateMipmaps), s2.needsUpdate = true, e2 && e2(s2, n3));
          }, n2, i2), s2;
        }
      }
      class oc extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = new Mt(), s2 = new rc(this.manager);
          return s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path), s2.load(t2, function(n3) {
            r2.image = n3;
            const i3 = t2.search(/\.jpe?g($|\?)/i) > 0 || 0 === t2.search(/^data\:image\/jpeg/);
            r2.format = i3 ? T : E, r2.needsUpdate = true, void 0 !== e2 && e2(r2);
          }, n2, i2), r2;
        }
      }
      class lc extends go {
        constructor() {
          super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
        }
        add(t2) {
          this.curves.push(t2);
        }
        closePath() {
          const t2 = this.curves[0].getPoint(0), e2 = this.curves[this.curves.length - 1].getPoint(1);
          t2.equals(e2) || this.curves.push(new Co(e2, t2));
        }
        getPoint(t2) {
          const e2 = t2 * this.getLength(), n2 = this.getCurveLengths();
          let i2 = 0;
          for (; i2 < n2.length; ) {
            if (n2[i2] >= e2) {
              const t3 = n2[i2] - e2, r2 = this.curves[i2], s2 = r2.getLength(), a2 = 0 === s2 ? 0 : 1 - t3 / s2;
              return r2.getPointAt(a2);
            }
            i2++;
          }
          return null;
        }
        getLength() {
          const t2 = this.getCurveLengths();
          return t2[t2.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
          const t2 = [];
          let e2 = 0;
          for (let n2 = 0, i2 = this.curves.length; n2 < i2; n2++)
            e2 += this.curves[n2].getLength(), t2.push(e2);
          return this.cacheLengths = t2, t2;
        }
        getSpacedPoints(t2 = 40) {
          const e2 = [];
          for (let n2 = 0; n2 <= t2; n2++)
            e2.push(this.getPoint(n2 / t2));
          return this.autoClose && e2.push(e2[0]), e2;
        }
        getPoints(t2 = 12) {
          const e2 = [];
          let n2;
          for (let i2 = 0, r2 = this.curves; i2 < r2.length; i2++) {
            const s2 = r2[i2], a2 = s2 && s2.isEllipseCurve ? 2 * t2 : s2 && (s2.isLineCurve || s2.isLineCurve3) ? 1 : s2 && s2.isSplineCurve ? t2 * s2.points.length : t2, o3 = s2.getPoints(a2);
            for (let t3 = 0; t3 < o3.length; t3++) {
              const i3 = o3[t3];
              n2 && n2.equals(i3) || (e2.push(i3), n2 = i3);
            }
          }
          return this.autoClose && e2.length > 1 && !e2[e2.length - 1].equals(e2[0]) && e2.push(e2[0]), e2;
        }
        copy(t2) {
          super.copy(t2), this.curves = [];
          for (let e2 = 0, n2 = t2.curves.length; e2 < n2; e2++) {
            const n3 = t2.curves[e2];
            this.curves.push(n3.clone());
          }
          return this.autoClose = t2.autoClose, this;
        }
        toJSON() {
          const t2 = super.toJSON();
          t2.autoClose = this.autoClose, t2.curves = [];
          for (let e2 = 0, n2 = this.curves.length; e2 < n2; e2++) {
            const n3 = this.curves[e2];
            t2.curves.push(n3.toJSON());
          }
          return t2;
        }
        fromJSON(t2) {
          super.fromJSON(t2), this.autoClose = t2.autoClose, this.curves = [];
          for (let e2 = 0, n2 = t2.curves.length; e2 < n2; e2++) {
            const n3 = t2.curves[e2];
            this.curves.push(new zo[n3.type]().fromJSON(n3));
          }
          return this;
        }
      }
      class cc extends lc {
        constructor(t2) {
          super(), this.type = "Path", this.currentPoint = new vt(), t2 && this.setFromPoints(t2);
        }
        setFromPoints(t2) {
          this.moveTo(t2[0].x, t2[0].y);
          for (let e2 = 1, n2 = t2.length; e2 < n2; e2++)
            this.lineTo(t2[e2].x, t2[e2].y);
          return this;
        }
        moveTo(t2, e2) {
          return this.currentPoint.set(t2, e2), this;
        }
        lineTo(t2, e2) {
          const n2 = new Co(this.currentPoint.clone(), new vt(t2, e2));
          return this.curves.push(n2), this.currentPoint.set(t2, e2), this;
        }
        quadraticCurveTo(t2, e2, n2, i2) {
          const r2 = new Io(this.currentPoint.clone(), new vt(t2, e2), new vt(n2, i2));
          return this.curves.push(r2), this.currentPoint.set(n2, i2), this;
        }
        bezierCurveTo(t2, e2, n2, i2, r2, s2) {
          const a2 = new Lo(this.currentPoint.clone(), new vt(t2, e2), new vt(n2, i2), new vt(r2, s2));
          return this.curves.push(a2), this.currentPoint.set(r2, s2), this;
        }
        splineThru(t2) {
          const e2 = [this.currentPoint.clone()].concat(t2), n2 = new No(e2);
          return this.curves.push(n2), this.currentPoint.copy(t2[t2.length - 1]), this;
        }
        arc(t2, e2, n2, i2, r2, s2) {
          const a2 = this.currentPoint.x, o3 = this.currentPoint.y;
          return this.absarc(t2 + a2, e2 + o3, n2, i2, r2, s2), this;
        }
        absarc(t2, e2, n2, i2, r2, s2) {
          return this.absellipse(t2, e2, n2, n2, i2, r2, s2), this;
        }
        ellipse(t2, e2, n2, i2, r2, s2, a2, o3) {
          const l2 = this.currentPoint.x, c2 = this.currentPoint.y;
          return this.absellipse(t2 + l2, e2 + c2, n2, i2, r2, s2, a2, o3), this;
        }
        absellipse(t2, e2, n2, i2, r2, s2, a2, o3) {
          const l2 = new vo(t2, e2, n2, i2, r2, s2, a2, o3);
          if (this.curves.length > 0) {
            const t3 = l2.getPoint(0);
            t3.equals(this.currentPoint) || this.lineTo(t3.x, t3.y);
          }
          this.curves.push(l2);
          const c2 = l2.getPoint(1);
          return this.currentPoint.copy(c2), this;
        }
        copy(t2) {
          return super.copy(t2), this.currentPoint.copy(t2.currentPoint), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.currentPoint = this.currentPoint.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.currentPoint.fromArray(t2.currentPoint), this;
        }
      }
      class hc extends cc {
        constructor(t2) {
          super(t2), this.uuid = ct(), this.type = "Shape", this.holes = [];
        }
        getPointsHoles(t2) {
          const e2 = [];
          for (let n2 = 0, i2 = this.holes.length; n2 < i2; n2++)
            e2[n2] = this.holes[n2].getPoints(t2);
          return e2;
        }
        extractPoints(t2) {
          return { shape: this.getPoints(t2), holes: this.getPointsHoles(t2) };
        }
        copy(t2) {
          super.copy(t2), this.holes = [];
          for (let e2 = 0, n2 = t2.holes.length; e2 < n2; e2++) {
            const n3 = t2.holes[e2];
            this.holes.push(n3.clone());
          }
          return this;
        }
        toJSON() {
          const t2 = super.toJSON();
          t2.uuid = this.uuid, t2.holes = [];
          for (let e2 = 0, n2 = this.holes.length; e2 < n2; e2++) {
            const n3 = this.holes[e2];
            t2.holes.push(n3.toJSON());
          }
          return t2;
        }
        fromJSON(t2) {
          super.fromJSON(t2), this.uuid = t2.uuid, this.holes = [];
          for (let e2 = 0, n2 = t2.holes.length; e2 < n2; e2++) {
            const n3 = t2.holes[e2];
            this.holes.push(new cc().fromJSON(n3));
          }
          return this;
        }
      }
      class uc extends Pe {
        constructor(t2, e2 = 1) {
          super(), this.type = "Light", this.color = new Qe(t2), this.intensity = e2;
        }
        dispose() {
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.intensity = t2.intensity, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.color = this.color.getHex(), e2.object.intensity = this.intensity, void 0 !== this.groundColor && (e2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e2.object.distance = this.distance), void 0 !== this.angle && (e2.object.angle = this.angle), void 0 !== this.decay && (e2.object.decay = this.decay), void 0 !== this.penumbra && (e2.object.penumbra = this.penumbra), void 0 !== this.shadow && (e2.object.shadow = this.shadow.toJSON()), e2;
        }
      }
      uc.prototype.isLight = true;
      class dc extends uc {
        constructor(t2, e2, n2) {
          super(t2, n2), this.type = "HemisphereLight", this.position.copy(Pe.DefaultUp), this.updateMatrix(), this.groundColor = new Qe(e2);
        }
        copy(t2) {
          return uc.prototype.copy.call(this, t2), this.groundColor.copy(t2.groundColor), this;
        }
      }
      dc.prototype.isHemisphereLight = true;
      const pc = new ae(), mc = new Rt(), fc = new Rt();
      class gc {
        constructor(t2) {
          this.camera = t2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new vt(512, 512), this.map = null, this.mapPass = null, this.matrix = new ae(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new ai(), this._frameExtents = new vt(1, 1), this._viewportCount = 1, this._viewports = [new St(0, 0, 1, 1)];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t2) {
          const e2 = this.camera, n2 = this.matrix;
          mc.setFromMatrixPosition(t2.matrixWorld), e2.position.copy(mc), fc.setFromMatrixPosition(t2.target.matrixWorld), e2.lookAt(fc), e2.updateMatrixWorld(), pc.multiplyMatrices(e2.projectionMatrix, e2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(pc), n2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n2.multiply(e2.projectionMatrix), n2.multiply(e2.matrixWorldInverse);
        }
        getViewport(t2) {
          return this._viewports[t2];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(t2) {
          return this.camera = t2.camera.clone(), this.bias = t2.bias, this.radius = t2.radius, this.mapSize.copy(t2.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t2 = {};
          return 0 !== this.bias && (t2.bias = this.bias), 0 !== this.normalBias && (t2.normalBias = this.normalBias), 1 !== this.radius && (t2.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t2.mapSize = this.mapSize.toArray()), t2.camera = this.camera.toJSON(false).object, delete t2.camera.matrix, t2;
        }
      }
      class vc extends gc {
        constructor() {
          super(new Jn(50, 1, 0.5, 500)), this.focus = 1;
        }
        updateMatrices(t2) {
          const e2 = this.camera, n2 = 2 * lt * t2.angle * this.focus, i2 = this.mapSize.width / this.mapSize.height, r2 = t2.distance || e2.far;
          n2 === e2.fov && i2 === e2.aspect && r2 === e2.far || (e2.fov = n2, e2.aspect = i2, e2.far = r2, e2.updateProjectionMatrix()), super.updateMatrices(t2);
        }
        copy(t2) {
          return super.copy(t2), this.focus = t2.focus, this;
        }
      }
      vc.prototype.isSpotLightShadow = true;
      class yc extends uc {
        constructor(t2, e2, n2 = 0, i2 = Math.PI / 3, r2 = 0, s2 = 1) {
          super(t2, e2), this.type = "SpotLight", this.position.copy(Pe.DefaultUp), this.updateMatrix(), this.target = new Pe(), this.distance = n2, this.angle = i2, this.penumbra = r2, this.decay = s2, this.shadow = new vc();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(t2) {
          this.intensity = t2 / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t2) {
          return super.copy(t2), this.distance = t2.distance, this.angle = t2.angle, this.penumbra = t2.penumbra, this.decay = t2.decay, this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
        }
      }
      yc.prototype.isSpotLight = true;
      const xc = new ae(), _c = new Rt(), bc = new Rt();
      class Mc extends gc {
        constructor() {
          super(new Jn(90, 1, 0.5, 500)), this._frameExtents = new vt(4, 2), this._viewportCount = 6, this._viewports = [new St(2, 1, 1, 1), new St(0, 1, 1, 1), new St(3, 1, 1, 1), new St(1, 1, 1, 1), new St(3, 0, 1, 1), new St(1, 0, 1, 1)], this._cubeDirections = [new Rt(1, 0, 0), new Rt(-1, 0, 0), new Rt(0, 0, 1), new Rt(0, 0, -1), new Rt(0, 1, 0), new Rt(0, -1, 0)], this._cubeUps = [new Rt(0, 1, 0), new Rt(0, 1, 0), new Rt(0, 1, 0), new Rt(0, 1, 0), new Rt(0, 0, 1), new Rt(0, 0, -1)];
        }
        updateMatrices(t2, e2 = 0) {
          const n2 = this.camera, i2 = this.matrix, r2 = t2.distance || n2.far;
          r2 !== n2.far && (n2.far = r2, n2.updateProjectionMatrix()), _c.setFromMatrixPosition(t2.matrixWorld), n2.position.copy(_c), bc.copy(n2.position), bc.add(this._cubeDirections[e2]), n2.up.copy(this._cubeUps[e2]), n2.lookAt(bc), n2.updateMatrixWorld(), i2.makeTranslation(-_c.x, -_c.y, -_c.z), xc.multiplyMatrices(n2.projectionMatrix, n2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(xc);
        }
      }
      Mc.prototype.isPointLightShadow = true;
      class wc extends uc {
        constructor(t2, e2, n2 = 0, i2 = 1) {
          super(t2, e2), this.type = "PointLight", this.distance = n2, this.decay = i2, this.shadow = new Mc();
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(t2) {
          this.intensity = t2 / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t2) {
          return super.copy(t2), this.distance = t2.distance, this.decay = t2.decay, this.shadow = t2.shadow.clone(), this;
        }
      }
      wc.prototype.isPointLight = true;
      class Sc extends gc {
        constructor() {
          super(new xi(-5, 5, 5, -5, 0.5, 500));
        }
      }
      Sc.prototype.isDirectionalLightShadow = true;
      class Tc extends uc {
        constructor(t2, e2) {
          super(t2, e2), this.type = "DirectionalLight", this.position.copy(Pe.DefaultUp), this.updateMatrix(), this.target = new Pe(), this.shadow = new Sc();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t2) {
          return super.copy(t2), this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
        }
      }
      Tc.prototype.isDirectionalLight = true;
      class Ec extends uc {
        constructor(t2, e2) {
          super(t2, e2), this.type = "AmbientLight";
        }
      }
      Ec.prototype.isAmbientLight = true;
      class Ac extends uc {
        constructor(t2, e2, n2 = 10, i2 = 10) {
          super(t2, e2), this.type = "RectAreaLight", this.width = n2, this.height = i2;
        }
        get power() {
          return this.intensity * this.width * this.height * Math.PI;
        }
        set power(t2) {
          this.intensity = t2 / (this.width * this.height * Math.PI);
        }
        copy(t2) {
          return super.copy(t2), this.width = t2.width, this.height = t2.height, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.width = this.width, e2.object.height = this.height, e2;
        }
      }
      Ac.prototype.isRectAreaLight = true;
      class Lc {
        constructor() {
          this.coefficients = [];
          for (let t2 = 0; t2 < 9; t2++)
            this.coefficients.push(new Rt());
        }
        set(t2) {
          for (let e2 = 0; e2 < 9; e2++)
            this.coefficients[e2].copy(t2[e2]);
          return this;
        }
        zero() {
          for (let t2 = 0; t2 < 9; t2++)
            this.coefficients[t2].set(0, 0, 0);
          return this;
        }
        getAt(t2, e2) {
          const n2 = t2.x, i2 = t2.y, r2 = t2.z, s2 = this.coefficients;
          return e2.copy(s2[0]).multiplyScalar(0.282095), e2.addScaledVector(s2[1], 0.488603 * i2), e2.addScaledVector(s2[2], 0.488603 * r2), e2.addScaledVector(s2[3], 0.488603 * n2), e2.addScaledVector(s2[4], n2 * i2 * 1.092548), e2.addScaledVector(s2[5], i2 * r2 * 1.092548), e2.addScaledVector(s2[6], 0.315392 * (3 * r2 * r2 - 1)), e2.addScaledVector(s2[7], n2 * r2 * 1.092548), e2.addScaledVector(s2[8], 0.546274 * (n2 * n2 - i2 * i2)), e2;
        }
        getIrradianceAt(t2, e2) {
          const n2 = t2.x, i2 = t2.y, r2 = t2.z, s2 = this.coefficients;
          return e2.copy(s2[0]).multiplyScalar(0.886227), e2.addScaledVector(s2[1], 1.023328 * i2), e2.addScaledVector(s2[2], 1.023328 * r2), e2.addScaledVector(s2[3], 1.023328 * n2), e2.addScaledVector(s2[4], 0.858086 * n2 * i2), e2.addScaledVector(s2[5], 0.858086 * i2 * r2), e2.addScaledVector(s2[6], 0.743125 * r2 * r2 - 0.247708), e2.addScaledVector(s2[7], 0.858086 * n2 * r2), e2.addScaledVector(s2[8], 0.429043 * (n2 * n2 - i2 * i2)), e2;
        }
        add(t2) {
          for (let e2 = 0; e2 < 9; e2++)
            this.coefficients[e2].add(t2.coefficients[e2]);
          return this;
        }
        addScaledSH(t2, e2) {
          for (let n2 = 0; n2 < 9; n2++)
            this.coefficients[n2].addScaledVector(t2.coefficients[n2], e2);
          return this;
        }
        scale(t2) {
          for (let e2 = 0; e2 < 9; e2++)
            this.coefficients[e2].multiplyScalar(t2);
          return this;
        }
        lerp(t2, e2) {
          for (let n2 = 0; n2 < 9; n2++)
            this.coefficients[n2].lerp(t2.coefficients[n2], e2);
          return this;
        }
        equals(t2) {
          for (let e2 = 0; e2 < 9; e2++)
            if (!this.coefficients[e2].equals(t2.coefficients[e2]))
              return false;
          return true;
        }
        copy(t2) {
          return this.set(t2.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(t2, e2 = 0) {
          const n2 = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++)
            n2[i2].fromArray(t2, e2 + 3 * i2);
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const n2 = this.coefficients;
          for (let i2 = 0; i2 < 9; i2++)
            n2[i2].toArray(t2, e2 + 3 * i2);
          return t2;
        }
        static getBasisAt(t2, e2) {
          const n2 = t2.x, i2 = t2.y, r2 = t2.z;
          e2[0] = 0.282095, e2[1] = 0.488603 * i2, e2[2] = 0.488603 * r2, e2[3] = 0.488603 * n2, e2[4] = 1.092548 * n2 * i2, e2[5] = 1.092548 * i2 * r2, e2[6] = 0.315392 * (3 * r2 * r2 - 1), e2[7] = 1.092548 * n2 * r2, e2[8] = 0.546274 * (n2 * n2 - i2 * i2);
        }
      }
      Lc.prototype.isSphericalHarmonics3 = true;
      class Rc extends uc {
        constructor(t2 = new Lc(), e2 = 1) {
          super(void 0, e2), this.sh = t2;
        }
        copy(t2) {
          return super.copy(t2), this.sh.copy(t2.sh), this;
        }
        fromJSON(t2) {
          return this.intensity = t2.intensity, this.sh.fromArray(t2.sh), this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.sh = this.sh.toArray(), e2;
        }
      }
      Rc.prototype.isLightProbe = true;
      class Cc extends ec {
        constructor(t2) {
          super(t2), this.textures = {};
        }
        load(t2, e2, n2, i2) {
          const r2 = this, s2 = new ic(r2.manager);
          s2.setPath(r2.path), s2.setRequestHeader(r2.requestHeader), s2.setWithCredentials(r2.withCredentials), s2.load(t2, function(n3) {
            try {
              e2(r2.parse(JSON.parse(n3)));
            } catch (e3) {
              i2 ? i2(e3) : console.error(e3), r2.manager.itemError(t2);
            }
          }, n2, i2);
        }
        parse(t2) {
          const e2 = this.textures;
          function n2(t3) {
            return void 0 === e2[t3] && console.warn("THREE.MaterialLoader: Undefined texture", t3), e2[t3];
          }
          const i2 = new Bl[t2.type]();
          if (void 0 !== t2.uuid && (i2.uuid = t2.uuid), void 0 !== t2.name && (i2.name = t2.name), void 0 !== t2.color && void 0 !== i2.color && i2.color.setHex(t2.color), void 0 !== t2.roughness && (i2.roughness = t2.roughness), void 0 !== t2.metalness && (i2.metalness = t2.metalness), void 0 !== t2.sheenTint && (i2.sheenTint = new Qe().setHex(t2.sheenTint)), void 0 !== t2.emissive && void 0 !== i2.emissive && i2.emissive.setHex(t2.emissive), void 0 !== t2.specular && void 0 !== i2.specular && i2.specular.setHex(t2.specular), void 0 !== t2.specularIntensity && (i2.specularIntensity = t2.specularIntensity), void 0 !== t2.specularTint && void 0 !== i2.specularTint && i2.specularTint.setHex(t2.specularTint), void 0 !== t2.shininess && (i2.shininess = t2.shininess), void 0 !== t2.clearcoat && (i2.clearcoat = t2.clearcoat), void 0 !== t2.clearcoatRoughness && (i2.clearcoatRoughness = t2.clearcoatRoughness), void 0 !== t2.transmission && (i2.transmission = t2.transmission), void 0 !== t2.thickness && (i2.thickness = t2.thickness), void 0 !== t2.attenuationDistance && (i2.attenuationDistance = t2.attenuationDistance), void 0 !== t2.attenuationTint && void 0 !== i2.attenuationTint && i2.attenuationTint.setHex(t2.attenuationTint), void 0 !== t2.fog && (i2.fog = t2.fog), void 0 !== t2.flatShading && (i2.flatShading = t2.flatShading), void 0 !== t2.blending && (i2.blending = t2.blending), void 0 !== t2.combine && (i2.combine = t2.combine), void 0 !== t2.side && (i2.side = t2.side), void 0 !== t2.shadowSide && (i2.shadowSide = t2.shadowSide), void 0 !== t2.opacity && (i2.opacity = t2.opacity), void 0 !== t2.format && (i2.format = t2.format), void 0 !== t2.transparent && (i2.transparent = t2.transparent), void 0 !== t2.alphaTest && (i2.alphaTest = t2.alphaTest), void 0 !== t2.depthTest && (i2.depthTest = t2.depthTest), void 0 !== t2.depthWrite && (i2.depthWrite = t2.depthWrite), void 0 !== t2.colorWrite && (i2.colorWrite = t2.colorWrite), void 0 !== t2.stencilWrite && (i2.stencilWrite = t2.stencilWrite), void 0 !== t2.stencilWriteMask && (i2.stencilWriteMask = t2.stencilWriteMask), void 0 !== t2.stencilFunc && (i2.stencilFunc = t2.stencilFunc), void 0 !== t2.stencilRef && (i2.stencilRef = t2.stencilRef), void 0 !== t2.stencilFuncMask && (i2.stencilFuncMask = t2.stencilFuncMask), void 0 !== t2.stencilFail && (i2.stencilFail = t2.stencilFail), void 0 !== t2.stencilZFail && (i2.stencilZFail = t2.stencilZFail), void 0 !== t2.stencilZPass && (i2.stencilZPass = t2.stencilZPass), void 0 !== t2.wireframe && (i2.wireframe = t2.wireframe), void 0 !== t2.wireframeLinewidth && (i2.wireframeLinewidth = t2.wireframeLinewidth), void 0 !== t2.wireframeLinecap && (i2.wireframeLinecap = t2.wireframeLinecap), void 0 !== t2.wireframeLinejoin && (i2.wireframeLinejoin = t2.wireframeLinejoin), void 0 !== t2.rotation && (i2.rotation = t2.rotation), 1 !== t2.linewidth && (i2.linewidth = t2.linewidth), void 0 !== t2.dashSize && (i2.dashSize = t2.dashSize), void 0 !== t2.gapSize && (i2.gapSize = t2.gapSize), void 0 !== t2.scale && (i2.scale = t2.scale), void 0 !== t2.polygonOffset && (i2.polygonOffset = t2.polygonOffset), void 0 !== t2.polygonOffsetFactor && (i2.polygonOffsetFactor = t2.polygonOffsetFactor), void 0 !== t2.polygonOffsetUnits && (i2.polygonOffsetUnits = t2.polygonOffsetUnits), void 0 !== t2.dithering && (i2.dithering = t2.dithering), void 0 !== t2.alphaToCoverage && (i2.alphaToCoverage = t2.alphaToCoverage), void 0 !== t2.premultipliedAlpha && (i2.premultipliedAlpha = t2.premultipliedAlpha), void 0 !== t2.visible && (i2.visible = t2.visible), void 0 !== t2.toneMapped && (i2.toneMapped = t2.toneMapped), void 0 !== t2.userData && (i2.userData = t2.userData), void 0 !== t2.vertexColors && ("number" == typeof t2.vertexColors ? i2.vertexColors = t2.vertexColors > 0 : i2.vertexColors = t2.vertexColors), void 0 !== t2.uniforms)
            for (const e3 in t2.uniforms) {
              const r2 = t2.uniforms[e3];
              switch (i2.uniforms[e3] = {}, r2.type) {
                case "t":
                  i2.uniforms[e3].value = n2(r2.value);
                  break;
                case "c":
                  i2.uniforms[e3].value = new Qe().setHex(r2.value);
                  break;
                case "v2":
                  i2.uniforms[e3].value = new vt().fromArray(r2.value);
                  break;
                case "v3":
                  i2.uniforms[e3].value = new Rt().fromArray(r2.value);
                  break;
                case "v4":
                  i2.uniforms[e3].value = new St().fromArray(r2.value);
                  break;
                case "m3":
                  i2.uniforms[e3].value = new yt().fromArray(r2.value);
                  break;
                case "m4":
                  i2.uniforms[e3].value = new ae().fromArray(r2.value);
                  break;
                default:
                  i2.uniforms[e3].value = r2.value;
              }
            }
          if (void 0 !== t2.defines && (i2.defines = t2.defines), void 0 !== t2.vertexShader && (i2.vertexShader = t2.vertexShader), void 0 !== t2.fragmentShader && (i2.fragmentShader = t2.fragmentShader), void 0 !== t2.extensions)
            for (const e3 in t2.extensions)
              i2.extensions[e3] = t2.extensions[e3];
          if (void 0 !== t2.shading && (i2.flatShading = 1 === t2.shading), void 0 !== t2.size && (i2.size = t2.size), void 0 !== t2.sizeAttenuation && (i2.sizeAttenuation = t2.sizeAttenuation), void 0 !== t2.map && (i2.map = n2(t2.map)), void 0 !== t2.matcap && (i2.matcap = n2(t2.matcap)), void 0 !== t2.alphaMap && (i2.alphaMap = n2(t2.alphaMap)), void 0 !== t2.bumpMap && (i2.bumpMap = n2(t2.bumpMap)), void 0 !== t2.bumpScale && (i2.bumpScale = t2.bumpScale), void 0 !== t2.normalMap && (i2.normalMap = n2(t2.normalMap)), void 0 !== t2.normalMapType && (i2.normalMapType = t2.normalMapType), void 0 !== t2.normalScale) {
            let e3 = t2.normalScale;
            false === Array.isArray(e3) && (e3 = [e3, e3]), i2.normalScale = new vt().fromArray(e3);
          }
          return void 0 !== t2.displacementMap && (i2.displacementMap = n2(t2.displacementMap)), void 0 !== t2.displacementScale && (i2.displacementScale = t2.displacementScale), void 0 !== t2.displacementBias && (i2.displacementBias = t2.displacementBias), void 0 !== t2.roughnessMap && (i2.roughnessMap = n2(t2.roughnessMap)), void 0 !== t2.metalnessMap && (i2.metalnessMap = n2(t2.metalnessMap)), void 0 !== t2.emissiveMap && (i2.emissiveMap = n2(t2.emissiveMap)), void 0 !== t2.emissiveIntensity && (i2.emissiveIntensity = t2.emissiveIntensity), void 0 !== t2.specularMap && (i2.specularMap = n2(t2.specularMap)), void 0 !== t2.specularIntensityMap && (i2.specularIntensityMap = n2(t2.specularIntensityMap)), void 0 !== t2.specularTintMap && (i2.specularTintMap = n2(t2.specularTintMap)), void 0 !== t2.envMap && (i2.envMap = n2(t2.envMap)), void 0 !== t2.envMapIntensity && (i2.envMapIntensity = t2.envMapIntensity), void 0 !== t2.reflectivity && (i2.reflectivity = t2.reflectivity), void 0 !== t2.refractionRatio && (i2.refractionRatio = t2.refractionRatio), void 0 !== t2.lightMap && (i2.lightMap = n2(t2.lightMap)), void 0 !== t2.lightMapIntensity && (i2.lightMapIntensity = t2.lightMapIntensity), void 0 !== t2.aoMap && (i2.aoMap = n2(t2.aoMap)), void 0 !== t2.aoMapIntensity && (i2.aoMapIntensity = t2.aoMapIntensity), void 0 !== t2.gradientMap && (i2.gradientMap = n2(t2.gradientMap)), void 0 !== t2.clearcoatMap && (i2.clearcoatMap = n2(t2.clearcoatMap)), void 0 !== t2.clearcoatRoughnessMap && (i2.clearcoatRoughnessMap = n2(t2.clearcoatRoughnessMap)), void 0 !== t2.clearcoatNormalMap && (i2.clearcoatNormalMap = n2(t2.clearcoatNormalMap)), void 0 !== t2.clearcoatNormalScale && (i2.clearcoatNormalScale = new vt().fromArray(t2.clearcoatNormalScale)), void 0 !== t2.transmissionMap && (i2.transmissionMap = n2(t2.transmissionMap)), void 0 !== t2.thicknessMap && (i2.thicknessMap = n2(t2.thicknessMap)), i2;
        }
        setTextures(t2) {
          return this.textures = t2, this;
        }
      }
      class Pc {
        static decodeText(t2) {
          if ("undefined" != typeof TextDecoder)
            return new TextDecoder().decode(t2);
          let e2 = "";
          for (let n2 = 0, i2 = t2.length; n2 < i2; n2++)
            e2 += String.fromCharCode(t2[n2]);
          try {
            return decodeURIComponent(escape(e2));
          } catch (t3) {
            return e2;
          }
        }
        static extractUrlBase(t2) {
          const e2 = t2.lastIndexOf("/");
          return -1 === e2 ? "./" : t2.substr(0, e2 + 1);
        }
      }
      class Ic extends wn {
        constructor() {
          super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
        }
        copy(t2) {
          return super.copy(t2), this.instanceCount = t2.instanceCount, this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t2 = super.toJSON(this);
          return t2.instanceCount = this.instanceCount, t2.isInstancedBufferGeometry = true, t2;
        }
      }
      Ic.prototype.isInstancedBufferGeometry = true;
      class Dc extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = this, s2 = new ic(r2.manager);
          s2.setPath(r2.path), s2.setRequestHeader(r2.requestHeader), s2.setWithCredentials(r2.withCredentials), s2.load(t2, function(n3) {
            try {
              e2(r2.parse(JSON.parse(n3)));
            } catch (e3) {
              i2 ? i2(e3) : console.error(e3), r2.manager.itemError(t2);
            }
          }, n2, i2);
        }
        parse(t2) {
          const e2 = {}, n2 = {};
          function i2(t3, i3) {
            if (void 0 !== e2[i3])
              return e2[i3];
            const r3 = t3.interleavedBuffers[i3], s3 = function(t4, e3) {
              if (void 0 !== n2[e3])
                return n2[e3];
              const i4 = t4.arrayBuffers[e3], r4 = new Uint32Array(i4).buffer;
              return n2[e3] = r4, r4;
            }(t3, r3.buffer), a3 = fn(r3.type, s3), o4 = new Ks(a3, r3.stride);
            return o4.uuid = r3.uuid, e2[i3] = o4, o4;
          }
          const r2 = t2.isInstancedBufferGeometry ? new Ic() : new wn(), s2 = t2.data.index;
          if (void 0 !== s2) {
            const t3 = fn(s2.type, s2.array);
            r2.setIndex(new en(t3, 1));
          }
          const a2 = t2.data.attributes;
          for (const e3 in a2) {
            const n3 = a2[e3];
            let s3;
            if (n3.isInterleavedBufferAttribute) {
              const e4 = i2(t2.data, n3.data);
              s3 = new ta(e4, n3.itemSize, n3.offset, n3.normalized);
            } else {
              const t3 = fn(n3.type, n3.array);
              s3 = new (n3.isInstancedBufferAttribute ? Pa : en)(t3, n3.itemSize, n3.normalized);
            }
            void 0 !== n3.name && (s3.name = n3.name), void 0 !== n3.usage && s3.setUsage(n3.usage), void 0 !== n3.updateRange && (s3.updateRange.offset = n3.updateRange.offset, s3.updateRange.count = n3.updateRange.count), r2.setAttribute(e3, s3);
          }
          const o3 = t2.data.morphAttributes;
          if (o3)
            for (const e3 in o3) {
              const n3 = o3[e3], s3 = [];
              for (let e4 = 0, r3 = n3.length; e4 < r3; e4++) {
                const r4 = n3[e4];
                let a3;
                if (r4.isInterleavedBufferAttribute) {
                  const e5 = i2(t2.data, r4.data);
                  a3 = new ta(e5, r4.itemSize, r4.offset, r4.normalized);
                } else {
                  const t3 = fn(r4.type, r4.array);
                  a3 = new en(t3, r4.itemSize, r4.normalized);
                }
                void 0 !== r4.name && (a3.name = r4.name), s3.push(a3);
              }
              r2.morphAttributes[e3] = s3;
            }
          t2.data.morphTargetsRelative && (r2.morphTargetsRelative = true);
          const l2 = t2.data.groups || t2.data.drawcalls || t2.data.offsets;
          if (void 0 !== l2)
            for (let t3 = 0, e3 = l2.length; t3 !== e3; ++t3) {
              const e4 = l2[t3];
              r2.addGroup(e4.start, e4.count, e4.materialIndex);
            }
          const c2 = t2.data.boundingSphere;
          if (void 0 !== c2) {
            const t3 = new Rt();
            void 0 !== c2.center && t3.fromArray(c2.center), r2.boundingSphere = new Qt(t3, c2.radius);
          }
          return t2.name && (r2.name = t2.name), t2.userData && (r2.userData = t2.userData), r2;
        }
      }
      const Nc = { UVMapping: i, CubeReflectionMapping: r, CubeRefractionMapping: s, EquirectangularReflectionMapping: a, EquirectangularRefractionMapping: o2, CubeUVReflectionMapping: l, CubeUVRefractionMapping: c }, zc = { RepeatWrapping: h, ClampToEdgeWrapping: u, MirroredRepeatWrapping: d }, Bc = { NearestFilter: p, NearestMipmapNearestFilter: m, NearestMipmapLinearFilter: f, LinearFilter: g, LinearMipmapNearestFilter: v, LinearMipmapLinearFilter: y };
      class Fc extends ec {
        constructor(t2) {
          super(t2), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
        }
        setOptions(t2) {
          return this.options = t2, this;
        }
        load(t2, e2, n2, i2) {
          void 0 === t2 && (t2 = ""), void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
          const r2 = this, s2 = Kl.get(t2);
          if (void 0 !== s2)
            return r2.manager.itemStart(t2), setTimeout(function() {
              e2 && e2(s2), r2.manager.itemEnd(t2);
            }, 0), s2;
          const a2 = {};
          a2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a2.headers = this.requestHeader, fetch(t2, a2).then(function(t3) {
            return t3.blob();
          }).then(function(t3) {
            return createImageBitmap(t3, Object.assign(r2.options, { colorSpaceConversion: "none" }));
          }).then(function(n3) {
            Kl.add(t2, n3), e2 && e2(n3), r2.manager.itemEnd(t2);
          }).catch(function(e3) {
            i2 && i2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
          }), r2.manager.itemStart(t2);
        }
      }
      Fc.prototype.isImageBitmapLoader = true;
      class Oc {
        constructor() {
          this.type = "ShapePath", this.color = new Qe(), this.subPaths = [], this.currentPath = null;
        }
        moveTo(t2, e2) {
          return this.currentPath = new cc(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t2, e2), this;
        }
        lineTo(t2, e2) {
          return this.currentPath.lineTo(t2, e2), this;
        }
        quadraticCurveTo(t2, e2, n2, i2) {
          return this.currentPath.quadraticCurveTo(t2, e2, n2, i2), this;
        }
        bezierCurveTo(t2, e2, n2, i2, r2, s2) {
          return this.currentPath.bezierCurveTo(t2, e2, n2, i2, r2, s2), this;
        }
        splineThru(t2) {
          return this.currentPath.splineThru(t2), this;
        }
        toShapes(t2, e2) {
          function n2(t3) {
            const e3 = [];
            for (let n3 = 0, i3 = t3.length; n3 < i3; n3++) {
              const i4 = t3[n3], r3 = new hc();
              r3.curves = i4.curves, e3.push(r3);
            }
            return e3;
          }
          function i2(t3, e3) {
            const n3 = e3.length;
            let i3 = false;
            for (let r3 = n3 - 1, s3 = 0; s3 < n3; r3 = s3++) {
              let n4 = e3[r3], a3 = e3[s3], o4 = a3.x - n4.x, l3 = a3.y - n4.y;
              if (Math.abs(l3) > Number.EPSILON) {
                if (l3 < 0 && (n4 = e3[s3], o4 = -o4, a3 = e3[r3], l3 = -l3), t3.y < n4.y || t3.y > a3.y)
                  continue;
                if (t3.y === n4.y) {
                  if (t3.x === n4.x)
                    return true;
                } else {
                  const e4 = l3 * (t3.x - n4.x) - o4 * (t3.y - n4.y);
                  if (0 === e4)
                    return true;
                  if (e4 < 0)
                    continue;
                  i3 = !i3;
                }
              } else {
                if (t3.y !== n4.y)
                  continue;
                if (a3.x <= t3.x && t3.x <= n4.x || n4.x <= t3.x && t3.x <= a3.x)
                  return true;
              }
            }
            return i3;
          }
          const r2 = ol.isClockWise, s2 = this.subPaths;
          if (0 === s2.length)
            return [];
          if (true === e2)
            return n2(s2);
          let a2, o3, l2;
          const c2 = [];
          if (1 === s2.length)
            return o3 = s2[0], l2 = new hc(), l2.curves = o3.curves, c2.push(l2), c2;
          let h2 = !r2(s2[0].getPoints());
          h2 = t2 ? !h2 : h2;
          const u2 = [], d2 = [];
          let p2, m2, f2 = [], g2 = 0;
          d2[g2] = void 0, f2[g2] = [];
          for (let e3 = 0, n3 = s2.length; e3 < n3; e3++)
            o3 = s2[e3], p2 = o3.getPoints(), a2 = r2(p2), a2 = t2 ? !a2 : a2, a2 ? (!h2 && d2[g2] && g2++, d2[g2] = { s: new hc(), p: p2 }, d2[g2].s.curves = o3.curves, h2 && g2++, f2[g2] = []) : f2[g2].push({ h: o3, p: p2[0] });
          if (!d2[0])
            return n2(s2);
          if (d2.length > 1) {
            let t3 = false;
            const e3 = [];
            for (let t4 = 0, e4 = d2.length; t4 < e4; t4++)
              u2[t4] = [];
            for (let n3 = 0, r3 = d2.length; n3 < r3; n3++) {
              const r4 = f2[n3];
              for (let s3 = 0; s3 < r4.length; s3++) {
                const a3 = r4[s3];
                let o4 = true;
                for (let r5 = 0; r5 < d2.length; r5++)
                  i2(a3.p, d2[r5].p) && (n3 !== r5 && e3.push({ froms: n3, tos: r5, hole: s3 }), o4 ? (o4 = false, u2[r5].push(a3)) : t3 = true);
                o4 && u2[n3].push(a3);
              }
            }
            e3.length > 0 && (t3 || (f2 = u2));
          }
          for (let t3 = 0, e3 = d2.length; t3 < e3; t3++) {
            l2 = d2[t3].s, c2.push(l2), m2 = f2[t3];
            for (let t4 = 0, e4 = m2.length; t4 < e4; t4++)
              l2.holes.push(m2[t4].h);
          }
          return c2;
        }
      }
      class Uc {
        constructor(t2) {
          this.type = "Font", this.data = t2;
        }
        generateShapes(t2, e2 = 100) {
          const n2 = [], i2 = function(t3, e3, n3) {
            const i3 = Array.from(t3), r2 = e3 / n3.resolution, s2 = (n3.boundingBox.yMax - n3.boundingBox.yMin + n3.underlineThickness) * r2, a2 = [];
            let o3 = 0, l2 = 0;
            for (let t4 = 0; t4 < i3.length; t4++) {
              const e4 = i3[t4];
              if ("\n" === e4)
                o3 = 0, l2 -= s2;
              else {
                const t5 = Hc(e4, r2, o3, l2, n3);
                o3 += t5.offsetX, a2.push(t5.path);
              }
            }
            return a2;
          }(t2, e2, this.data);
          for (let t3 = 0, e3 = i2.length; t3 < e3; t3++)
            Array.prototype.push.apply(n2, i2[t3].toShapes());
          return n2;
        }
      }
      function Hc(t2, e2, n2, i2, r2) {
        const s2 = r2.glyphs[t2] || r2.glyphs["?"];
        if (!s2)
          return void console.error('THREE.Font: character "' + t2 + '" does not exists in font family ' + r2.familyName + ".");
        const a2 = new Oc();
        let o3, l2, c2, h2, u2, d2, p2, m2;
        if (s2.o) {
          const t3 = s2._cachedOutline || (s2._cachedOutline = s2.o.split(" "));
          for (let r3 = 0, s3 = t3.length; r3 < s3; ) {
            switch (t3[r3++]) {
              case "m":
                o3 = t3[r3++] * e2 + n2, l2 = t3[r3++] * e2 + i2, a2.moveTo(o3, l2);
                break;
              case "l":
                o3 = t3[r3++] * e2 + n2, l2 = t3[r3++] * e2 + i2, a2.lineTo(o3, l2);
                break;
              case "q":
                c2 = t3[r3++] * e2 + n2, h2 = t3[r3++] * e2 + i2, u2 = t3[r3++] * e2 + n2, d2 = t3[r3++] * e2 + i2, a2.quadraticCurveTo(u2, d2, c2, h2);
                break;
              case "b":
                c2 = t3[r3++] * e2 + n2, h2 = t3[r3++] * e2 + i2, u2 = t3[r3++] * e2 + n2, d2 = t3[r3++] * e2 + i2, p2 = t3[r3++] * e2 + n2, m2 = t3[r3++] * e2 + i2, a2.bezierCurveTo(u2, d2, p2, m2, c2, h2);
            }
          }
        }
        return { offsetX: s2.ha * e2, path: a2 };
      }
      Uc.prototype.isFont = true;
      let Gc;
      const kc = { getContext: function() {
        return void 0 === Gc && (Gc = new (window.AudioContext || window.webkitAudioContext)()), Gc;
      }, setContext: function(t2) {
        Gc = t2;
      } };
      class Vc extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = this, s2 = new ic(this.manager);
          s2.setResponseType("arraybuffer"), s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(t2, function(n3) {
            try {
              const t3 = n3.slice(0);
              kc.getContext().decodeAudioData(t3, function(t4) {
                e2(t4);
              });
            } catch (e3) {
              i2 ? i2(e3) : console.error(e3), r2.manager.itemError(t2);
            }
          }, n2, i2);
        }
      }
      class Wc extends Rc {
        constructor(t2, e2, n2 = 1) {
          super(void 0, n2);
          const i2 = new Qe().set(t2), r2 = new Qe().set(e2), s2 = new Rt(i2.r, i2.g, i2.b), a2 = new Rt(r2.r, r2.g, r2.b), o3 = Math.sqrt(Math.PI), l2 = o3 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(s2).add(a2).multiplyScalar(o3), this.sh.coefficients[1].copy(s2).sub(a2).multiplyScalar(l2);
        }
      }
      Wc.prototype.isHemisphereLightProbe = true;
      class jc extends Rc {
        constructor(t2, e2 = 1) {
          super(void 0, e2);
          const n2 = new Qe().set(t2);
          this.sh.coefficients[0].set(n2.r, n2.g, n2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }
      jc.prototype.isAmbientLightProbe = true;
      const qc = new ae(), Xc = new ae();
      class Yc {
        constructor(t2 = true) {
          this.autoStart = t2, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
        }
        start() {
          this.startTime = Jc(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
        }
        stop() {
          this.getElapsedTime(), this.running = false, this.autoStart = false;
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let t2 = 0;
          if (this.autoStart && !this.running)
            return this.start(), 0;
          if (this.running) {
            const e2 = Jc();
            t2 = (e2 - this.oldTime) / 1e3, this.oldTime = e2, this.elapsedTime += t2;
          }
          return t2;
        }
      }
      function Jc() {
        return ("undefined" == typeof performance ? Date : performance).now();
      }
      const Zc = new Rt(), Qc = new Lt(), Kc = new Rt(), $c = new Rt();
      class th extends Pe {
        constructor(t2) {
          super(), this.type = "Audio", this.listener = t2, this.context = t2.context, this.gain = this.context.createGain(), this.gain.connect(t2.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t2, this.connect(), this;
        }
        setMediaElementSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t2), this.connect(), this;
        }
        setMediaStreamSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t2), this.connect(), this;
        }
        setBuffer(t2) {
          return this.buffer = t2, this.sourceType = "buffer", this.autoplay && this.play(), this;
        }
        play(t2 = 0) {
          if (true === this.isPlaying)
            return void console.warn("THREE.Audio: Audio is already playing.");
          if (false === this.hasPlaybackControl)
            return void console.warn("THREE.Audio: this Audio has no playback control.");
          this._startedAt = this.context.currentTime + t2;
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.buffer, e2.loop = this.loop, e2.loopStart = this.loopStart, e2.loopEnd = this.loopEnd, e2.onended = this.onEnded.bind(this), e2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }
        pause() {
          if (false !== this.hasPlaybackControl)
            return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (false !== this.hasPlaybackControl)
            return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++)
              this.filters[t2 - 1].connect(this.filters[t2]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else
            this.source.connect(this.getOutput());
          return this._connected = true, this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++)
              this.filters[t2 - 1].disconnect(this.filters[t2]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else
            this.source.disconnect(this.getOutput());
          return this._connected = false, this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(t2) {
          return t2 || (t2 = []), true === this._connected ? (this.disconnect(), this.filters = t2.slice(), this.connect()) : this.filters = t2.slice(), this;
        }
        setDetune(t2) {
          if (this.detune = t2, void 0 !== this.source.detune)
            return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(t2) {
          return this.setFilters(t2 ? [t2] : []);
        }
        setPlaybackRate(t2) {
          if (false !== this.hasPlaybackControl)
            return this.playbackRate = t2, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
        }
        setLoop(t2) {
          if (false !== this.hasPlaybackControl)
            return this.loop = t2, true === this.isPlaying && (this.source.loop = this.loop), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(t2) {
          return this.loopStart = t2, this;
        }
        setLoopEnd(t2) {
          return this.loopEnd = t2, this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(t2) {
          return this.gain.gain.setTargetAtTime(t2, this.context.currentTime, 0.01), this;
        }
      }
      const eh = new Rt(), nh = new Lt(), ih = new Rt(), rh = new Rt();
      class sh {
        constructor(t2, e2 = 2048) {
          this.analyser = t2.context.createAnalyser(), this.analyser.fftSize = e2, this.data = new Uint8Array(this.analyser.frequencyBinCount), t2.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let t2 = 0;
          const e2 = this.getFrequencyData();
          for (let n2 = 0; n2 < e2.length; n2++)
            t2 += e2[n2];
          return t2 / e2.length;
        }
      }
      class ah {
        constructor(t2, e2, n2) {
          let i2, r2, s2;
          switch (this.binding = t2, this.valueSize = n2, e2) {
            case "quaternion":
              i2 = this._slerp, r2 = this._slerpAdditive, s2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n2), this._workIndex = 5;
              break;
            case "string":
            case "bool":
              i2 = this._select, r2 = this._select, s2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n2);
              break;
            default:
              i2 = this._lerp, r2 = this._lerpAdditive, s2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n2);
          }
          this._mixBufferRegion = i2, this._mixBufferRegionAdditive = r2, this._setIdentity = s2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(t2, e2) {
          const n2 = this.buffer, i2 = this.valueSize, r2 = t2 * i2 + i2;
          let s2 = this.cumulativeWeight;
          if (0 === s2) {
            for (let t3 = 0; t3 !== i2; ++t3)
              n2[r2 + t3] = n2[t3];
            s2 = e2;
          } else {
            s2 += e2;
            const t3 = e2 / s2;
            this._mixBufferRegion(n2, r2, 0, t3, i2);
          }
          this.cumulativeWeight = s2;
        }
        accumulateAdditive(t2) {
          const e2 = this.buffer, n2 = this.valueSize, i2 = n2 * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e2, i2, 0, t2, n2), this.cumulativeWeightAdditive += t2;
        }
        apply(t2) {
          const e2 = this.valueSize, n2 = this.buffer, i2 = t2 * e2 + e2, r2 = this.cumulativeWeight, s2 = this.cumulativeWeightAdditive, a2 = this.binding;
          if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r2 < 1) {
            const t3 = e2 * this._origIndex;
            this._mixBufferRegion(n2, i2, t3, 1 - r2, e2);
          }
          s2 > 0 && this._mixBufferRegionAdditive(n2, i2, this._addIndex * e2, 1, e2);
          for (let t3 = e2, r3 = e2 + e2; t3 !== r3; ++t3)
            if (n2[t3] !== n2[t3 + e2]) {
              a2.setValue(n2, i2);
              break;
            }
        }
        saveOriginalState() {
          const t2 = this.binding, e2 = this.buffer, n2 = this.valueSize, i2 = n2 * this._origIndex;
          t2.getValue(e2, i2);
          for (let t3 = n2, r2 = i2; t3 !== r2; ++t3)
            e2[t3] = e2[i2 + t3 % n2];
          this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const t2 = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t2);
        }
        _setAdditiveIdentityNumeric() {
          const t2 = this._addIndex * this.valueSize, e2 = t2 + this.valueSize;
          for (let n2 = t2; n2 < e2; n2++)
            this.buffer[n2] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const t2 = this._origIndex * this.valueSize, e2 = this._addIndex * this.valueSize;
          for (let n2 = 0; n2 < this.valueSize; n2++)
            this.buffer[e2 + n2] = this.buffer[t2 + n2];
        }
        _select(t2, e2, n2, i2, r2) {
          if (i2 >= 0.5)
            for (let i3 = 0; i3 !== r2; ++i3)
              t2[e2 + i3] = t2[n2 + i3];
        }
        _slerp(t2, e2, n2, i2) {
          Lt.slerpFlat(t2, e2, t2, e2, t2, n2, i2);
        }
        _slerpAdditive(t2, e2, n2, i2, r2) {
          const s2 = this._workIndex * r2;
          Lt.multiplyQuaternionsFlat(t2, s2, t2, e2, t2, n2), Lt.slerpFlat(t2, e2, t2, e2, t2, s2, i2);
        }
        _lerp(t2, e2, n2, i2, r2) {
          const s2 = 1 - i2;
          for (let a2 = 0; a2 !== r2; ++a2) {
            const r3 = e2 + a2;
            t2[r3] = t2[r3] * s2 + t2[n2 + a2] * i2;
          }
        }
        _lerpAdditive(t2, e2, n2, i2, r2) {
          for (let s2 = 0; s2 !== r2; ++s2) {
            const r3 = e2 + s2;
            t2[r3] = t2[r3] + t2[n2 + s2] * i2;
          }
        }
      }
      const oh = "\\[\\]\\.:\\/", lh = new RegExp("[\\[\\]\\.:\\/]", "g"), ch = "[^\\[\\]\\.:\\/]", hh = "[^" + oh.replace("\\.", "") + "]", uh = /((?:WC+[\/:])*)/.source.replace("WC", ch), dh = /(WCOD+)?/.source.replace("WCOD", hh), ph = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ch), mh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ch), fh = new RegExp("^" + uh + dh + ph + mh + "$"), gh = ["material", "materials", "bones"];
      class vh {
        constructor(t2, e2, n2) {
          this.path = e2, this.parsedPath = n2 || vh.parseTrackName(e2), this.node = vh.findNode(t2, this.parsedPath.nodeName) || t2, this.rootNode = t2, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(t2, e2, n2) {
          return t2 && t2.isAnimationObjectGroup ? new vh.Composite(t2, e2, n2) : new vh(t2, e2, n2);
        }
        static sanitizeNodeName(t2) {
          return t2.replace(/\s/g, "_").replace(lh, "");
        }
        static parseTrackName(t2) {
          const e2 = fh.exec(t2);
          if (!e2)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t2);
          const n2 = { nodeName: e2[2], objectName: e2[3], objectIndex: e2[4], propertyName: e2[5], propertyIndex: e2[6] }, i2 = n2.nodeName && n2.nodeName.lastIndexOf(".");
          if (void 0 !== i2 && -1 !== i2) {
            const t3 = n2.nodeName.substring(i2 + 1);
            -1 !== gh.indexOf(t3) && (n2.nodeName = n2.nodeName.substring(0, i2), n2.objectName = t3);
          }
          if (null === n2.propertyName || 0 === n2.propertyName.length)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t2);
          return n2;
        }
        static findNode(t2, e2) {
          if (!e2 || "" === e2 || "." === e2 || -1 === e2 || e2 === t2.name || e2 === t2.uuid)
            return t2;
          if (t2.skeleton) {
            const n2 = t2.skeleton.getBoneByName(e2);
            if (void 0 !== n2)
              return n2;
          }
          if (t2.children) {
            const n2 = function(t3) {
              for (let i3 = 0; i3 < t3.length; i3++) {
                const r2 = t3[i3];
                if (r2.name === e2 || r2.uuid === e2)
                  return r2;
                const s2 = n2(r2.children);
                if (s2)
                  return s2;
              }
              return null;
            }, i2 = n2(t2.children);
            if (i2)
              return i2;
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(t2, e2) {
          t2[e2] = this.targetObject[this.propertyName];
        }
        _getValue_array(t2, e2) {
          const n2 = this.resolvedProperty;
          for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2)
            t2[e2++] = n2[i2];
        }
        _getValue_arrayElement(t2, e2) {
          t2[e2] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t2, e2) {
          this.resolvedProperty.toArray(t2, e2);
        }
        _setValue_direct(t2, e2) {
          this.targetObject[this.propertyName] = t2[e2];
        }
        _setValue_direct_setNeedsUpdate(t2, e2) {
          this.targetObject[this.propertyName] = t2[e2], this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t2, e2) {
          this.targetObject[this.propertyName] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(t2, e2) {
          const n2 = this.resolvedProperty;
          for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2)
            n2[i2] = t2[e2++];
        }
        _setValue_array_setNeedsUpdate(t2, e2) {
          const n2 = this.resolvedProperty;
          for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2)
            n2[i2] = t2[e2++];
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t2, e2) {
          const n2 = this.resolvedProperty;
          for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2)
            n2[i2] = t2[e2++];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(t2, e2) {
          this.resolvedProperty[this.propertyIndex] = t2[e2];
        }
        _setValue_arrayElement_setNeedsUpdate(t2, e2) {
          this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t2, e2) {
          this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(t2, e2) {
          this.resolvedProperty.fromArray(t2, e2);
        }
        _setValue_fromArray_setNeedsUpdate(t2, e2) {
          this.resolvedProperty.fromArray(t2, e2), this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t2, e2) {
          this.resolvedProperty.fromArray(t2, e2), this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(t2, e2) {
          this.bind(), this.getValue(t2, e2);
        }
        _setValue_unbound(t2, e2) {
          this.bind(), this.setValue(t2, e2);
        }
        bind() {
          let t2 = this.node;
          const e2 = this.parsedPath, n2 = e2.objectName, i2 = e2.propertyName;
          let r2 = e2.propertyIndex;
          if (t2 || (t2 = vh.findNode(this.rootNode, e2.nodeName) || this.rootNode, this.node = t2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t2)
            return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          if (n2) {
            let i3 = e2.objectIndex;
            switch (n2) {
              case "materials":
                if (!t2.material)
                  return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                if (!t2.material.materials)
                  return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                t2 = t2.material.materials;
                break;
              case "bones":
                if (!t2.skeleton)
                  return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                t2 = t2.skeleton.bones;
                for (let e3 = 0; e3 < t2.length; e3++)
                  if (t2[e3].name === i3) {
                    i3 = e3;
                    break;
                  }
                break;
              default:
                if (void 0 === t2[n2])
                  return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                t2 = t2[n2];
            }
            if (void 0 !== i3) {
              if (void 0 === t2[i3])
                return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t2);
              t2 = t2[i3];
            }
          }
          const s2 = t2[i2];
          if (void 0 === s2) {
            const n3 = e2.nodeName;
            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n3 + "." + i2 + " but it wasn't found.", t2);
          }
          let a2 = this.Versioning.None;
          this.targetObject = t2, void 0 !== t2.needsUpdate ? a2 = this.Versioning.NeedsUpdate : void 0 !== t2.matrixWorldNeedsUpdate && (a2 = this.Versioning.MatrixWorldNeedsUpdate);
          let o3 = this.BindingType.Direct;
          if (void 0 !== r2) {
            if ("morphTargetInfluences" === i2) {
              if (!t2.geometry)
                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              if (!t2.geometry.isBufferGeometry)
                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
              if (!t2.geometry.morphAttributes)
                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              void 0 !== t2.morphTargetDictionary[r2] && (r2 = t2.morphTargetDictionary[r2]);
            }
            o3 = this.BindingType.ArrayElement, this.resolvedProperty = s2, this.propertyIndex = r2;
          } else
            void 0 !== s2.fromArray && void 0 !== s2.toArray ? (o3 = this.BindingType.HasFromToArray, this.resolvedProperty = s2) : Array.isArray(s2) ? (o3 = this.BindingType.EntireArray, this.resolvedProperty = s2) : this.propertyName = i2;
          this.getValue = this.GetterByBindingType[o3], this.setValue = this.SetterByBindingTypeAndVersioning[o3][a2];
        }
        unbind() {
          this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
      }
      vh.Composite = class {
        constructor(t2, e2, n2) {
          const i2 = n2 || vh.parseTrackName(e2);
          this._targetGroup = t2, this._bindings = t2.subscribe_(e2, i2);
        }
        getValue(t2, e2) {
          this.bind();
          const n2 = this._targetGroup.nCachedObjects_, i2 = this._bindings[n2];
          void 0 !== i2 && i2.getValue(t2, e2);
        }
        setValue(t2, e2) {
          const n2 = this._bindings;
          for (let i2 = this._targetGroup.nCachedObjects_, r2 = n2.length; i2 !== r2; ++i2)
            n2[i2].setValue(t2, e2);
        }
        bind() {
          const t2 = this._bindings;
          for (let e2 = this._targetGroup.nCachedObjects_, n2 = t2.length; e2 !== n2; ++e2)
            t2[e2].bind();
        }
        unbind() {
          const t2 = this._bindings;
          for (let e2 = this._targetGroup.nCachedObjects_, n2 = t2.length; e2 !== n2; ++e2)
            t2[e2].unbind();
        }
      }, vh.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, vh.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, vh.prototype.GetterByBindingType = [vh.prototype._getValue_direct, vh.prototype._getValue_array, vh.prototype._getValue_arrayElement, vh.prototype._getValue_toArray], vh.prototype.SetterByBindingTypeAndVersioning = [[vh.prototype._setValue_direct, vh.prototype._setValue_direct_setNeedsUpdate, vh.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [vh.prototype._setValue_array, vh.prototype._setValue_array_setNeedsUpdate, vh.prototype._setValue_array_setMatrixWorldNeedsUpdate], [vh.prototype._setValue_arrayElement, vh.prototype._setValue_arrayElement_setNeedsUpdate, vh.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [vh.prototype._setValue_fromArray, vh.prototype._setValue_fromArray_setNeedsUpdate, vh.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
      class yh {
        constructor() {
          this.uuid = ct(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
          const t2 = {};
          this._indicesByUUID = t2;
          for (let e3 = 0, n2 = arguments.length; e3 !== n2; ++e3)
            t2[arguments[e3].uuid] = e3;
          this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
          const e2 = this;
          this.stats = { objects: { get total() {
            return e2._objects.length;
          }, get inUse() {
            return this.total - e2.nCachedObjects_;
          } }, get bindingsPerObject() {
            return e2._bindings.length;
          } };
        }
        add() {
          const t2 = this._objects, e2 = this._indicesByUUID, n2 = this._paths, i2 = this._parsedPaths, r2 = this._bindings, s2 = r2.length;
          let a2, o3 = t2.length, l2 = this.nCachedObjects_;
          for (let c2 = 0, h2 = arguments.length; c2 !== h2; ++c2) {
            const h3 = arguments[c2], u2 = h3.uuid;
            let d2 = e2[u2];
            if (void 0 === d2) {
              d2 = o3++, e2[u2] = d2, t2.push(h3);
              for (let t3 = 0, e3 = s2; t3 !== e3; ++t3)
                r2[t3].push(new vh(h3, n2[t3], i2[t3]));
            } else if (d2 < l2) {
              a2 = t2[d2];
              const o4 = --l2, c3 = t2[o4];
              e2[c3.uuid] = d2, t2[d2] = c3, e2[u2] = o4, t2[o4] = h3;
              for (let t3 = 0, e3 = s2; t3 !== e3; ++t3) {
                const e4 = r2[t3], s3 = e4[o4];
                let a3 = e4[d2];
                e4[d2] = s3, void 0 === a3 && (a3 = new vh(h3, n2[t3], i2[t3])), e4[o4] = a3;
              }
            } else
              t2[d2] !== a2 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
          this.nCachedObjects_ = l2;
        }
        remove() {
          const t2 = this._objects, e2 = this._indicesByUUID, n2 = this._bindings, i2 = n2.length;
          let r2 = this.nCachedObjects_;
          for (let s2 = 0, a2 = arguments.length; s2 !== a2; ++s2) {
            const a3 = arguments[s2], o3 = a3.uuid, l2 = e2[o3];
            if (void 0 !== l2 && l2 >= r2) {
              const s3 = r2++, c2 = t2[s3];
              e2[c2.uuid] = l2, t2[l2] = c2, e2[o3] = s3, t2[s3] = a3;
              for (let t3 = 0, e3 = i2; t3 !== e3; ++t3) {
                const e4 = n2[t3], i3 = e4[s3], r3 = e4[l2];
                e4[l2] = i3, e4[s3] = r3;
              }
            }
          }
          this.nCachedObjects_ = r2;
        }
        uncache() {
          const t2 = this._objects, e2 = this._indicesByUUID, n2 = this._bindings, i2 = n2.length;
          let r2 = this.nCachedObjects_, s2 = t2.length;
          for (let a2 = 0, o3 = arguments.length; a2 !== o3; ++a2) {
            const o4 = arguments[a2].uuid, l2 = e2[o4];
            if (void 0 !== l2)
              if (delete e2[o4], l2 < r2) {
                const a3 = --r2, o5 = t2[a3], c2 = --s2, h2 = t2[c2];
                e2[o5.uuid] = l2, t2[l2] = o5, e2[h2.uuid] = a3, t2[a3] = h2, t2.pop();
                for (let t3 = 0, e3 = i2; t3 !== e3; ++t3) {
                  const e4 = n2[t3], i3 = e4[a3], r3 = e4[c2];
                  e4[l2] = i3, e4[a3] = r3, e4.pop();
                }
              } else {
                const r3 = --s2, a3 = t2[r3];
                r3 > 0 && (e2[a3.uuid] = l2), t2[l2] = a3, t2.pop();
                for (let t3 = 0, e3 = i2; t3 !== e3; ++t3) {
                  const e4 = n2[t3];
                  e4[l2] = e4[r3], e4.pop();
                }
              }
          }
          this.nCachedObjects_ = r2;
        }
        subscribe_(t2, e2) {
          const n2 = this._bindingsIndicesByPath;
          let i2 = n2[t2];
          const r2 = this._bindings;
          if (void 0 !== i2)
            return r2[i2];
          const s2 = this._paths, a2 = this._parsedPaths, o3 = this._objects, l2 = o3.length, c2 = this.nCachedObjects_, h2 = new Array(l2);
          i2 = r2.length, n2[t2] = i2, s2.push(t2), a2.push(e2), r2.push(h2);
          for (let n3 = c2, i3 = o3.length; n3 !== i3; ++n3) {
            const i4 = o3[n3];
            h2[n3] = new vh(i4, t2, e2);
          }
          return h2;
        }
        unsubscribe_(t2) {
          const e2 = this._bindingsIndicesByPath, n2 = e2[t2];
          if (void 0 !== n2) {
            const i2 = this._paths, r2 = this._parsedPaths, s2 = this._bindings, a2 = s2.length - 1, o3 = s2[a2];
            e2[t2[a2]] = n2, s2[n2] = o3, s2.pop(), r2[n2] = r2[a2], r2.pop(), i2[n2] = i2[a2], i2.pop();
          }
        }
      }
      yh.prototype.isAnimationObjectGroup = true;
      class xh {
        constructor(t2, e2, n2 = null, i2 = e2.blendMode) {
          this._mixer = t2, this._clip = e2, this._localRoot = n2, this.blendMode = i2;
          const r2 = e2.tracks, s2 = r2.length, a2 = new Array(s2), o3 = { endingStart: k, endingEnd: k };
          for (let t3 = 0; t3 !== s2; ++t3) {
            const e3 = r2[t3].createInterpolant(null);
            a2[t3] = e3, e3.settings = o3;
          }
          this._interpolantSettings = o3, this._interpolants = a2, this._propertyBindings = new Array(s2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(t2) {
          return this._startTime = t2, this;
        }
        setLoop(t2, e2) {
          return this.loop = t2, this.repetitions = e2, this;
        }
        setEffectiveWeight(t2) {
          return this.weight = t2, this._effectiveWeight = this.enabled ? t2 : 0, this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(t2) {
          return this._scheduleFading(t2, 0, 1);
        }
        fadeOut(t2) {
          return this._scheduleFading(t2, 1, 0);
        }
        crossFadeFrom(t2, e2, n2) {
          if (t2.fadeOut(e2), this.fadeIn(e2), n2) {
            const n3 = this._clip.duration, i2 = t2._clip.duration, r2 = i2 / n3, s2 = n3 / i2;
            t2.warp(1, r2, e2), this.warp(s2, 1, e2);
          }
          return this;
        }
        crossFadeTo(t2, e2, n2) {
          return t2.crossFadeFrom(this, e2, n2);
        }
        stopFading() {
          const t2 = this._weightInterpolant;
          return null !== t2 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
        }
        setEffectiveTimeScale(t2) {
          return this.timeScale = t2, this._effectiveTimeScale = this.paused ? 0 : t2, this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(t2) {
          return this.timeScale = this._clip.duration / t2, this.stopWarping();
        }
        syncWith(t2) {
          return this.time = t2.time, this.timeScale = t2.timeScale, this.stopWarping();
        }
        halt(t2) {
          return this.warp(this._effectiveTimeScale, 0, t2);
        }
        warp(t2, e2, n2) {
          const i2 = this._mixer, r2 = i2.time, s2 = this.timeScale;
          let a2 = this._timeScaleInterpolant;
          null === a2 && (a2 = i2._lendControlInterpolant(), this._timeScaleInterpolant = a2);
          const o3 = a2.parameterPositions, l2 = a2.sampleValues;
          return o3[0] = r2, o3[1] = r2 + n2, l2[0] = t2 / s2, l2[1] = e2 / s2, this;
        }
        stopWarping() {
          const t2 = this._timeScaleInterpolant;
          return null !== t2 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(t2, e2, n2, i2) {
          if (!this.enabled)
            return void this._updateWeight(t2);
          const r2 = this._startTime;
          if (null !== r2) {
            const i3 = (t2 - r2) * n2;
            if (i3 < 0 || 0 === n2)
              return;
            this._startTime = null, e2 = n2 * i3;
          }
          e2 *= this._updateTimeScale(t2);
          const s2 = this._updateTime(e2), a2 = this._updateWeight(t2);
          if (a2 > 0) {
            const t3 = this._interpolants, e3 = this._propertyBindings;
            switch (this.blendMode) {
              case q:
                for (let n3 = 0, i3 = t3.length; n3 !== i3; ++n3)
                  t3[n3].evaluate(s2), e3[n3].accumulateAdditive(a2);
                break;
              case j:
              default:
                for (let n3 = 0, r3 = t3.length; n3 !== r3; ++n3)
                  t3[n3].evaluate(s2), e3[n3].accumulate(i2, a2);
            }
          }
        }
        _updateWeight(t2) {
          let e2 = 0;
          if (this.enabled) {
            e2 = this.weight;
            const n2 = this._weightInterpolant;
            if (null !== n2) {
              const i2 = n2.evaluate(t2)[0];
              e2 *= i2, t2 > n2.parameterPositions[1] && (this.stopFading(), 0 === i2 && (this.enabled = false));
            }
          }
          return this._effectiveWeight = e2, e2;
        }
        _updateTimeScale(t2) {
          let e2 = 0;
          if (!this.paused) {
            e2 = this.timeScale;
            const n2 = this._timeScaleInterpolant;
            if (null !== n2) {
              e2 *= n2.evaluate(t2)[0], t2 > n2.parameterPositions[1] && (this.stopWarping(), 0 === e2 ? this.paused = true : this.timeScale = e2);
            }
          }
          return this._effectiveTimeScale = e2, e2;
        }
        _updateTime(t2) {
          const e2 = this._clip.duration, n2 = this.loop;
          let i2 = this.time + t2, r2 = this._loopCount;
          const s2 = 2202 === n2;
          if (0 === t2)
            return -1 === r2 ? i2 : s2 && 1 == (1 & r2) ? e2 - i2 : i2;
          if (2200 === n2) {
            -1 === r2 && (this._loopCount = 0, this._setEndings(true, true, false));
            t: {
              if (i2 >= e2)
                i2 = e2;
              else {
                if (!(i2 < 0)) {
                  this.time = i2;
                  break t;
                }
                i2 = 0;
              }
              this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = i2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 < 0 ? -1 : 1 });
            }
          } else {
            if (-1 === r2 && (t2 >= 0 ? (r2 = 0, this._setEndings(true, 0 === this.repetitions, s2)) : this._setEndings(0 === this.repetitions, true, s2)), i2 >= e2 || i2 < 0) {
              const n3 = Math.floor(i2 / e2);
              i2 -= e2 * n3, r2 += Math.abs(n3);
              const a2 = this.repetitions - r2;
              if (a2 <= 0)
                this.clampWhenFinished ? this.paused = true : this.enabled = false, i2 = t2 > 0 ? e2 : 0, this.time = i2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 > 0 ? 1 : -1 });
              else {
                if (1 === a2) {
                  const e3 = t2 < 0;
                  this._setEndings(e3, !e3, s2);
                } else
                  this._setEndings(false, false, s2);
                this._loopCount = r2, this.time = i2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n3 });
              }
            } else
              this.time = i2;
            if (s2 && 1 == (1 & r2))
              return e2 - i2;
          }
          return i2;
        }
        _setEndings(t2, e2, n2) {
          const i2 = this._interpolantSettings;
          n2 ? (i2.endingStart = V, i2.endingEnd = V) : (i2.endingStart = t2 ? this.zeroSlopeAtStart ? V : k : W, i2.endingEnd = e2 ? this.zeroSlopeAtEnd ? V : k : W);
        }
        _scheduleFading(t2, e2, n2) {
          const i2 = this._mixer, r2 = i2.time;
          let s2 = this._weightInterpolant;
          null === s2 && (s2 = i2._lendControlInterpolant(), this._weightInterpolant = s2);
          const a2 = s2.parameterPositions, o3 = s2.sampleValues;
          return a2[0] = r2, o3[0] = e2, a2[1] = r2 + t2, o3[1] = n2, this;
        }
      }
      class _h extends rt {
        constructor(t2) {
          super(), this._root = t2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(t2, e2) {
          const n2 = t2._localRoot || this._root, i2 = t2._clip.tracks, r2 = i2.length, s2 = t2._propertyBindings, a2 = t2._interpolants, o3 = n2.uuid, l2 = this._bindingsByRootAndName;
          let c2 = l2[o3];
          void 0 === c2 && (c2 = {}, l2[o3] = c2);
          for (let t3 = 0; t3 !== r2; ++t3) {
            const r3 = i2[t3], l3 = r3.name;
            let h2 = c2[l3];
            if (void 0 !== h2)
              s2[t3] = h2;
            else {
              if (h2 = s2[t3], void 0 !== h2) {
                null === h2._cacheIndex && (++h2.referenceCount, this._addInactiveBinding(h2, o3, l3));
                continue;
              }
              const i3 = e2 && e2._propertyBindings[t3].binding.parsedPath;
              h2 = new ah(vh.create(n2, l3, i3), r3.ValueTypeName, r3.getValueSize()), ++h2.referenceCount, this._addInactiveBinding(h2, o3, l3), s2[t3] = h2;
            }
            a2[t3].resultBuffer = h2.buffer;
          }
        }
        _activateAction(t2) {
          if (!this._isActiveAction(t2)) {
            if (null === t2._cacheIndex) {
              const e3 = (t2._localRoot || this._root).uuid, n2 = t2._clip.uuid, i2 = this._actionsByClip[n2];
              this._bindAction(t2, i2 && i2.knownActions[0]), this._addInactiveAction(t2, n2, e3);
            }
            const e2 = t2._propertyBindings;
            for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
              const n3 = e2[t3];
              0 == n3.useCount++ && (this._lendBinding(n3), n3.saveOriginalState());
            }
            this._lendAction(t2);
          }
        }
        _deactivateAction(t2) {
          if (this._isActiveAction(t2)) {
            const e2 = t2._propertyBindings;
            for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
              const n3 = e2[t3];
              0 == --n3.useCount && (n3.restoreOriginalState(), this._takeBackBinding(n3));
            }
            this._takeBackAction(t2);
          }
        }
        _initMemoryManager() {
          this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
          const t2 = this;
          this.stats = { actions: { get total() {
            return t2._actions.length;
          }, get inUse() {
            return t2._nActiveActions;
          } }, bindings: { get total() {
            return t2._bindings.length;
          }, get inUse() {
            return t2._nActiveBindings;
          } }, controlInterpolants: { get total() {
            return t2._controlInterpolants.length;
          }, get inUse() {
            return t2._nActiveControlInterpolants;
          } } };
        }
        _isActiveAction(t2) {
          const e2 = t2._cacheIndex;
          return null !== e2 && e2 < this._nActiveActions;
        }
        _addInactiveAction(t2, e2, n2) {
          const i2 = this._actions, r2 = this._actionsByClip;
          let s2 = r2[e2];
          if (void 0 === s2)
            s2 = { knownActions: [t2], actionByRoot: {} }, t2._byClipCacheIndex = 0, r2[e2] = s2;
          else {
            const e3 = s2.knownActions;
            t2._byClipCacheIndex = e3.length, e3.push(t2);
          }
          t2._cacheIndex = i2.length, i2.push(t2), s2.actionByRoot[n2] = t2;
        }
        _removeInactiveAction(t2) {
          const e2 = this._actions, n2 = e2[e2.length - 1], i2 = t2._cacheIndex;
          n2._cacheIndex = i2, e2[i2] = n2, e2.pop(), t2._cacheIndex = null;
          const r2 = t2._clip.uuid, s2 = this._actionsByClip, a2 = s2[r2], o3 = a2.knownActions, l2 = o3[o3.length - 1], c2 = t2._byClipCacheIndex;
          l2._byClipCacheIndex = c2, o3[c2] = l2, o3.pop(), t2._byClipCacheIndex = null;
          delete a2.actionByRoot[(t2._localRoot || this._root).uuid], 0 === o3.length && delete s2[r2], this._removeInactiveBindingsForAction(t2);
        }
        _removeInactiveBindingsForAction(t2) {
          const e2 = t2._propertyBindings;
          for (let t3 = 0, n2 = e2.length; t3 !== n2; ++t3) {
            const n3 = e2[t3];
            0 == --n3.referenceCount && this._removeInactiveBinding(n3);
          }
        }
        _lendAction(t2) {
          const e2 = this._actions, n2 = t2._cacheIndex, i2 = this._nActiveActions++, r2 = e2[i2];
          t2._cacheIndex = i2, e2[i2] = t2, r2._cacheIndex = n2, e2[n2] = r2;
        }
        _takeBackAction(t2) {
          const e2 = this._actions, n2 = t2._cacheIndex, i2 = --this._nActiveActions, r2 = e2[i2];
          t2._cacheIndex = i2, e2[i2] = t2, r2._cacheIndex = n2, e2[n2] = r2;
        }
        _addInactiveBinding(t2, e2, n2) {
          const i2 = this._bindingsByRootAndName, r2 = this._bindings;
          let s2 = i2[e2];
          void 0 === s2 && (s2 = {}, i2[e2] = s2), s2[n2] = t2, t2._cacheIndex = r2.length, r2.push(t2);
        }
        _removeInactiveBinding(t2) {
          const e2 = this._bindings, n2 = t2.binding, i2 = n2.rootNode.uuid, r2 = n2.path, s2 = this._bindingsByRootAndName, a2 = s2[i2], o3 = e2[e2.length - 1], l2 = t2._cacheIndex;
          o3._cacheIndex = l2, e2[l2] = o3, e2.pop(), delete a2[r2], 0 === Object.keys(a2).length && delete s2[i2];
        }
        _lendBinding(t2) {
          const e2 = this._bindings, n2 = t2._cacheIndex, i2 = this._nActiveBindings++, r2 = e2[i2];
          t2._cacheIndex = i2, e2[i2] = t2, r2._cacheIndex = n2, e2[n2] = r2;
        }
        _takeBackBinding(t2) {
          const e2 = this._bindings, n2 = t2._cacheIndex, i2 = --this._nActiveBindings, r2 = e2[i2];
          t2._cacheIndex = i2, e2[i2] = t2, r2._cacheIndex = n2, e2[n2] = r2;
        }
        _lendControlInterpolant() {
          const t2 = this._controlInterpolants, e2 = this._nActiveControlInterpolants++;
          let n2 = t2[e2];
          return void 0 === n2 && (n2 = new Hl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n2.__cacheIndex = e2, t2[e2] = n2), n2;
        }
        _takeBackControlInterpolant(t2) {
          const e2 = this._controlInterpolants, n2 = t2.__cacheIndex, i2 = --this._nActiveControlInterpolants, r2 = e2[i2];
          t2.__cacheIndex = i2, e2[i2] = t2, r2.__cacheIndex = n2, e2[n2] = r2;
        }
        clipAction(t2, e2, n2) {
          const i2 = e2 || this._root, r2 = i2.uuid;
          let s2 = "string" == typeof t2 ? Zl.findByName(i2, t2) : t2;
          const a2 = null !== s2 ? s2.uuid : t2, o3 = this._actionsByClip[a2];
          let l2 = null;
          if (void 0 === n2 && (n2 = null !== s2 ? s2.blendMode : j), void 0 !== o3) {
            const t3 = o3.actionByRoot[r2];
            if (void 0 !== t3 && t3.blendMode === n2)
              return t3;
            l2 = o3.knownActions[0], null === s2 && (s2 = l2._clip);
          }
          if (null === s2)
            return null;
          const c2 = new xh(this, s2, e2, n2);
          return this._bindAction(c2, l2), this._addInactiveAction(c2, a2, r2), c2;
        }
        existingAction(t2, e2) {
          const n2 = e2 || this._root, i2 = n2.uuid, r2 = "string" == typeof t2 ? Zl.findByName(n2, t2) : t2, s2 = r2 ? r2.uuid : t2, a2 = this._actionsByClip[s2];
          return void 0 !== a2 && a2.actionByRoot[i2] || null;
        }
        stopAllAction() {
          const t2 = this._actions;
          for (let e2 = this._nActiveActions - 1; e2 >= 0; --e2)
            t2[e2].stop();
          return this;
        }
        update(t2) {
          t2 *= this.timeScale;
          const e2 = this._actions, n2 = this._nActiveActions, i2 = this.time += t2, r2 = Math.sign(t2), s2 = this._accuIndex ^= 1;
          for (let a3 = 0; a3 !== n2; ++a3) {
            e2[a3]._update(i2, t2, r2, s2);
          }
          const a2 = this._bindings, o3 = this._nActiveBindings;
          for (let t3 = 0; t3 !== o3; ++t3)
            a2[t3].apply(s2);
          return this;
        }
        setTime(t2) {
          this.time = 0;
          for (let t3 = 0; t3 < this._actions.length; t3++)
            this._actions[t3].time = 0;
          return this.update(t2);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(t2) {
          const e2 = this._actions, n2 = t2.uuid, i2 = this._actionsByClip, r2 = i2[n2];
          if (void 0 !== r2) {
            const t3 = r2.knownActions;
            for (let n3 = 0, i3 = t3.length; n3 !== i3; ++n3) {
              const i4 = t3[n3];
              this._deactivateAction(i4);
              const r3 = i4._cacheIndex, s2 = e2[e2.length - 1];
              i4._cacheIndex = null, i4._byClipCacheIndex = null, s2._cacheIndex = r3, e2[r3] = s2, e2.pop(), this._removeInactiveBindingsForAction(i4);
            }
            delete i2[n2];
          }
        }
        uncacheRoot(t2) {
          const e2 = t2.uuid, n2 = this._actionsByClip;
          for (const t3 in n2) {
            const i3 = n2[t3].actionByRoot[e2];
            void 0 !== i3 && (this._deactivateAction(i3), this._removeInactiveAction(i3));
          }
          const i2 = this._bindingsByRootAndName[e2];
          if (void 0 !== i2)
            for (const t3 in i2) {
              const e3 = i2[t3];
              e3.restoreOriginalState(), this._removeInactiveBinding(e3);
            }
        }
        uncacheAction(t2, e2) {
          const n2 = this.existingAction(t2, e2);
          null !== n2 && (this._deactivateAction(n2), this._removeInactiveAction(n2));
        }
      }
      _h.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class bh {
        constructor(t2) {
          "string" == typeof t2 && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t2 = arguments[1]), this.value = t2;
        }
        clone() {
          return new bh(void 0 === this.value.clone ? this.value : this.value.clone());
        }
      }
      class Mh extends Ks {
        constructor(t2, e2, n2 = 1) {
          super(t2, e2), this.meshPerAttribute = n2;
        }
        copy(t2) {
          return super.copy(t2), this.meshPerAttribute = t2.meshPerAttribute, this;
        }
        clone(t2) {
          const e2 = super.clone(t2);
          return e2.meshPerAttribute = this.meshPerAttribute, e2;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.isInstancedInterleavedBuffer = true, e2.meshPerAttribute = this.meshPerAttribute, e2;
        }
      }
      Mh.prototype.isInstancedInterleavedBuffer = true;
      class wh {
        constructor(t2, e2, n2, i2, r2) {
          this.buffer = t2, this.type = e2, this.itemSize = n2, this.elementSize = i2, this.count = r2, this.version = 0;
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
        setBuffer(t2) {
          return this.buffer = t2, this;
        }
        setType(t2, e2) {
          return this.type = t2, this.elementSize = e2, this;
        }
        setItemSize(t2) {
          return this.itemSize = t2, this;
        }
        setCount(t2) {
          return this.count = t2, this;
        }
      }
      wh.prototype.isGLBufferAttribute = true;
      function Sh(t2, e2) {
        return t2.distance - e2.distance;
      }
      function Th(t2, e2, n2, i2) {
        if (t2.layers.test(e2.layers) && t2.raycast(e2, n2), true === i2) {
          const i3 = t2.children;
          for (let t3 = 0, r2 = i3.length; t3 < r2; t3++)
            Th(i3[t3], e2, n2, true);
        }
      }
      const Eh = new vt();
      class Ah {
        constructor(t2 = new vt(1 / 0, 1 / 0), e2 = new vt(-1 / 0, -1 / 0)) {
          this.min = t2, this.max = e2;
        }
        set(t2, e2) {
          return this.min.copy(t2), this.max.copy(e2), this;
        }
        setFromPoints(t2) {
          this.makeEmpty();
          for (let e2 = 0, n2 = t2.length; e2 < n2; e2++)
            this.expandByPoint(t2[e2]);
          return this;
        }
        setFromCenterAndSize(t2, e2) {
          const n2 = Eh.copy(e2).multiplyScalar(0.5);
          return this.min.copy(t2).sub(n2), this.max.copy(t2).add(n2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.min.copy(t2.min), this.max.copy(t2.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(t2) {
          return this.isEmpty() ? t2.set(0, 0) : t2.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t2) {
          return this.isEmpty() ? t2.set(0, 0) : t2.subVectors(this.max, this.min);
        }
        expandByPoint(t2) {
          return this.min.min(t2), this.max.max(t2), this;
        }
        expandByVector(t2) {
          return this.min.sub(t2), this.max.add(t2), this;
        }
        expandByScalar(t2) {
          return this.min.addScalar(-t2), this.max.addScalar(t2), this;
        }
        containsPoint(t2) {
          return !(t2.x < this.min.x || t2.x > this.max.x || t2.y < this.min.y || t2.y > this.max.y);
        }
        containsBox(t2) {
          return this.min.x <= t2.min.x && t2.max.x <= this.max.x && this.min.y <= t2.min.y && t2.max.y <= this.max.y;
        }
        getParameter(t2, e2) {
          return e2.set((t2.x - this.min.x) / (this.max.x - this.min.x), (t2.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(t2) {
          return !(t2.max.x < this.min.x || t2.min.x > this.max.x || t2.max.y < this.min.y || t2.min.y > this.max.y);
        }
        clampPoint(t2, e2) {
          return e2.copy(t2).clamp(this.min, this.max);
        }
        distanceToPoint(t2) {
          return Eh.copy(t2).clamp(this.min, this.max).sub(t2).length();
        }
        intersect(t2) {
          return this.min.max(t2.min), this.max.min(t2.max), this;
        }
        union(t2) {
          return this.min.min(t2.min), this.max.max(t2.max), this;
        }
        translate(t2) {
          return this.min.add(t2), this.max.add(t2), this;
        }
        equals(t2) {
          return t2.min.equals(this.min) && t2.max.equals(this.max);
        }
      }
      Ah.prototype.isBox2 = true;
      const Lh = new Rt(), Rh = new Rt();
      class Ch {
        constructor(t2 = new Rt(), e2 = new Rt()) {
          this.start = t2, this.end = e2;
        }
        set(t2, e2) {
          return this.start.copy(t2), this.end.copy(e2), this;
        }
        copy(t2) {
          return this.start.copy(t2.start), this.end.copy(t2.end), this;
        }
        getCenter(t2) {
          return t2.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(t2) {
          return t2.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t2, e2) {
          return this.delta(e2).multiplyScalar(t2).add(this.start);
        }
        closestPointToPointParameter(t2, e2) {
          Lh.subVectors(t2, this.start), Rh.subVectors(this.end, this.start);
          const n2 = Rh.dot(Rh);
          let i2 = Rh.dot(Lh) / n2;
          return e2 && (i2 = ht(i2, 0, 1)), i2;
        }
        closestPointToPoint(t2, e2, n2) {
          const i2 = this.closestPointToPointParameter(t2, e2);
          return this.delta(n2).multiplyScalar(i2).add(this.start);
        }
        applyMatrix4(t2) {
          return this.start.applyMatrix4(t2), this.end.applyMatrix4(t2), this;
        }
        equals(t2) {
          return t2.start.equals(this.start) && t2.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Ph extends Pe {
        constructor(t2) {
          super(), this.material = t2, this.render = function() {
          }, this.hasPositions = false, this.hasNormals = false, this.hasColors = false, this.hasUvs = false, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
        }
      }
      Ph.prototype.isImmediateRenderObject = true;
      const Ih = new Rt();
      const Dh = new Rt(), Nh = new ae(), zh = new ae();
      class Bh extends qa {
        constructor(t2) {
          const e2 = Fh(t2), n2 = new wn(), i2 = [], r2 = [], s2 = new Qe(0, 0, 1), a2 = new Qe(0, 1, 0);
          for (let t3 = 0; t3 < e2.length; t3++) {
            const n3 = e2[t3];
            n3.parent && n3.parent.isBone && (i2.push(0, 0, 0), i2.push(0, 0, 0), r2.push(s2.r, s2.g, s2.b), r2.push(a2.r, a2.g, a2.b));
          }
          n2.setAttribute("position", new un(i2, 3)), n2.setAttribute("color", new un(r2, 3));
          super(n2, new Fa({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t2, this.bones = e2, this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(t2) {
          const e2 = this.bones, n2 = this.geometry, i2 = n2.getAttribute("position");
          zh.copy(this.root.matrixWorld).invert();
          for (let t3 = 0, n3 = 0; t3 < e2.length; t3++) {
            const r2 = e2[t3];
            r2.parent && r2.parent.isBone && (Nh.multiplyMatrices(zh, r2.matrixWorld), Dh.setFromMatrixPosition(Nh), i2.setXYZ(n3, Dh.x, Dh.y, Dh.z), Nh.multiplyMatrices(zh, r2.parent.matrixWorld), Dh.setFromMatrixPosition(Nh), i2.setXYZ(n3 + 1, Dh.x, Dh.y, Dh.z), n3 += 2);
          }
          n2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t2);
        }
      }
      function Fh(t2) {
        const e2 = [];
        t2 && t2.isBone && e2.push(t2);
        for (let n2 = 0; n2 < t2.children.length; n2++)
          e2.push.apply(e2, Fh(t2.children[n2]));
        return e2;
      }
      const Oh = new Rt(), Uh = new Qe(), Hh = new Qe();
      class Gh extends qa {
        constructor(t2 = 10, e2 = 10, n2 = 4473924, i2 = 8947848) {
          n2 = new Qe(n2), i2 = new Qe(i2);
          const r2 = e2 / 2, s2 = t2 / e2, a2 = t2 / 2, o3 = [], l2 = [];
          for (let t3 = 0, c3 = 0, h2 = -a2; t3 <= e2; t3++, h2 += s2) {
            o3.push(-a2, 0, h2, a2, 0, h2), o3.push(h2, 0, -a2, h2, 0, a2);
            const e3 = t3 === r2 ? n2 : i2;
            e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3;
          }
          const c2 = new wn();
          c2.setAttribute("position", new un(o3, 3)), c2.setAttribute("color", new un(l2, 3));
          super(c2, new Fa({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
        }
      }
      const kh = new Rt(), Vh = new Rt(), Wh = new Rt();
      const jh = new Rt(), qh = new Yn();
      function Xh(t2, e2, n2, i2, r2, s2, a2) {
        jh.set(r2, s2, a2).unproject(i2);
        const o3 = e2[t2];
        if (void 0 !== o3) {
          const t3 = n2.getAttribute("position");
          for (let e3 = 0, n3 = o3.length; e3 < n3; e3++)
            t3.setXYZ(o3[e3], jh.x, jh.y, jh.z);
        }
      }
      const Yh = new It();
      class Jh extends qa {
        constructor(t2, e2 = 16776960) {
          const n2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i2 = new Float32Array(24), r2 = new wn();
          r2.setIndex(new en(n2, 1)), r2.setAttribute("position", new en(i2, 3)), super(r2, new Fa({ color: e2, toneMapped: false })), this.object = t2, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
        }
        update(t2) {
          if (void 0 !== t2 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Yh.setFromObject(this.object), Yh.isEmpty())
            return;
          const e2 = Yh.min, n2 = Yh.max, i2 = this.geometry.attributes.position, r2 = i2.array;
          r2[0] = n2.x, r2[1] = n2.y, r2[2] = n2.z, r2[3] = e2.x, r2[4] = n2.y, r2[5] = n2.z, r2[6] = e2.x, r2[7] = e2.y, r2[8] = n2.z, r2[9] = n2.x, r2[10] = e2.y, r2[11] = n2.z, r2[12] = n2.x, r2[13] = n2.y, r2[14] = e2.z, r2[15] = e2.x, r2[16] = n2.y, r2[17] = e2.z, r2[18] = e2.x, r2[19] = e2.y, r2[20] = e2.z, r2[21] = n2.x, r2[22] = e2.y, r2[23] = e2.z, i2.needsUpdate = true, this.geometry.computeBoundingSphere();
        }
        setFromObject(t2) {
          return this.object = t2, this.update(), this;
        }
        copy(t2) {
          return qa.prototype.copy.call(this, t2), this.object = t2.object, this;
        }
      }
      const Zh = new Rt();
      let Qh, Kh;
      class $h extends qa {
        constructor(t2 = 1) {
          const e2 = [0, 0, 0, t2, 0, 0, 0, 0, 0, 0, t2, 0, 0, 0, 0, 0, 0, t2], n2 = new wn();
          n2.setAttribute("position", new un(e2, 3)), n2.setAttribute("color", new un([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
          super(n2, new Fa({ vertexColors: true, toneMapped: false })), this.type = "AxesHelper";
        }
        setColors(t2, e2, n2) {
          const i2 = new Qe(), r2 = this.geometry.attributes.color.array;
          return i2.set(t2), i2.toArray(r2, 0), i2.toArray(r2, 3), i2.set(e2), i2.toArray(r2, 6), i2.toArray(r2, 9), i2.set(n2), i2.toArray(r2, 12), i2.toArray(r2, 15), this.geometry.attributes.color.needsUpdate = true, this;
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      const tu = new Float32Array(1), eu = new Int32Array(tu.buffer);
      go.create = function(t2, e2) {
        return console.log("THREE.Curve.create() has been deprecated"), t2.prototype = Object.create(go.prototype), t2.prototype.constructor = t2, t2.prototype.getPoint = e2, t2;
      }, cc.prototype.fromPoints = function(t2) {
        return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t2);
      }, Gh.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      }, Bh.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      }, ec.prototype.extractUrlBase = function(t2) {
        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Pc.extractUrlBase(t2);
      }, ec.Handlers = { add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
      }, get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
      } }, Ah.prototype.center = function(t2) {
        return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, Ah.prototype.empty = function() {
        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, Ah.prototype.isIntersectionBox = function(t2) {
        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, Ah.prototype.size = function(t2) {
        return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t2);
      }, It.prototype.center = function(t2) {
        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, It.prototype.empty = function() {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, It.prototype.isIntersectionBox = function(t2) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, It.prototype.isIntersectionSphere = function(t2) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
      }, It.prototype.size = function(t2) {
        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t2);
      }, Qt.prototype.empty = function() {
        return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, ai.prototype.setFromMatrix = function(t2) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t2);
      }, Ch.prototype.center = function(t2) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, yt.prototype.flattenToArrayOffset = function(t2, e2) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
      }, yt.prototype.multiplyVector3 = function(t2) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
      }, yt.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      }, yt.prototype.applyToBufferAttribute = function(t2) {
        return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
      }, yt.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      }, yt.prototype.getInverse = function(t2) {
        return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
      }, ae.prototype.extractPosition = function(t2) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t2);
      }, ae.prototype.flattenToArrayOffset = function(t2, e2) {
        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
      }, ae.prototype.getPosition = function() {
        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new Rt().setFromMatrixColumn(this, 3);
      }, ae.prototype.setRotationFromQuaternion = function(t2) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t2);
      }, ae.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      }, ae.prototype.multiplyVector3 = function(t2) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, ae.prototype.multiplyVector4 = function(t2) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, ae.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      }, ae.prototype.rotateAxis = function(t2) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t2.transformDirection(this);
      }, ae.prototype.crossVector = function(t2) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, ae.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      }, ae.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      }, ae.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      }, ae.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      }, ae.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      }, ae.prototype.applyToBufferAttribute = function(t2) {
        return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, ae.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      }, ae.prototype.makeFrustum = function(t2, e2, n2, i2, r2, s2) {
        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t2, e2, i2, n2, r2, s2);
      }, ae.prototype.getInverse = function(t2) {
        return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
      }, ii.prototype.isIntersectionLine = function(t2) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t2);
      }, Lt.prototype.multiplyVector3 = function(t2) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t2.applyQuaternion(this);
      }, Lt.prototype.inverse = function() {
        return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
      }, se.prototype.isIntersectionBox = function(t2) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, se.prototype.isIntersectionPlane = function(t2) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t2);
      }, se.prototype.isIntersectionSphere = function(t2) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
      }, ke.prototype.area = function() {
        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
      }, ke.prototype.barycoordFromPoint = function(t2, e2) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t2, e2);
      }, ke.prototype.midpoint = function(t2) {
        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t2);
      }, ke.prototypenormal = function(t2) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t2);
      }, ke.prototype.plane = function(t2) {
        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t2);
      }, ke.barycoordFromPoint = function(t2, e2, n2, i2, r2) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), ke.getBarycoord(t2, e2, n2, i2, r2);
      }, ke.normal = function(t2, e2, n2, i2) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), ke.getNormal(t2, e2, n2, i2);
      }, hc.prototype.extractAllPoints = function(t2) {
        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t2);
      }, hc.prototype.extrude = function(t2) {
        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new hl(this, t2);
      }, hc.prototype.makeGeometry = function(t2) {
        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new vl(this, t2);
      }, vt.prototype.fromAttribute = function(t2, e2, n2) {
        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
      }, vt.prototype.distanceToManhattan = function(t2) {
        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
      }, vt.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      }, Rt.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      }, Rt.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      }, Rt.prototype.getPositionFromMatrix = function(t2) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t2);
      }, Rt.prototype.getScaleFromMatrix = function(t2) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t2);
      }, Rt.prototype.getColumnFromMatrix = function(t2, e2) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e2, t2);
      }, Rt.prototype.applyProjection = function(t2) {
        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t2);
      }, Rt.prototype.fromAttribute = function(t2, e2, n2) {
        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
      }, Rt.prototype.distanceToManhattan = function(t2) {
        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
      }, Rt.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      }, St.prototype.fromAttribute = function(t2, e2, n2) {
        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, n2);
      }, St.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      }, Pe.prototype.getChildByName = function(t2) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t2);
      }, Pe.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      }, Pe.prototype.translate = function(t2, e2) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e2, t2);
      }, Pe.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      }, Pe.prototype.applyMatrix = function(t2) {
        return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
      }, Object.defineProperties(Pe.prototype, { eulerOrder: { get: function() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      }, set: function(t2) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t2;
      } }, useQuaternion: { get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }, set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      } } }), Gn.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      }, Object.defineProperties(Gn.prototype, { drawMode: { get: function() {
        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
      }, set: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      } } }), Ta.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }, Jn.prototype.setLens = function(t2, e2) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e2 && (this.filmGauge = e2), this.setFocalLength(t2);
      }, Object.defineProperties(uc.prototype, { onlyShadow: { set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      } }, shadowCameraFov: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t2;
      } }, shadowCameraLeft: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t2;
      } }, shadowCameraRight: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t2;
      } }, shadowCameraTop: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t2;
      } }, shadowCameraBottom: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t2;
      } }, shadowCameraNear: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t2;
      } }, shadowCameraFar: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t2;
      } }, shadowCameraVisible: { set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      } }, shadowBias: { set: function(t2) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t2;
      } }, shadowDarkness: { set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      } }, shadowMapWidth: { set: function(t2) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t2;
      } }, shadowMapHeight: { set: function(t2) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t2;
      } } }), Object.defineProperties(en.prototype, { length: { get: function() {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
      } }, dynamic: { get: function() {
        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === nt;
      }, set: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(nt);
      } } }), en.prototype.setDynamic = function(t2) {
        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t2 ? nt : et), this;
      }, en.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      }, en.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      }, wn.prototype.addIndex = function(t2) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t2);
      }, wn.prototype.addAttribute = function(t2, e2) {
        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e2 && e2.isBufferAttribute || e2 && e2.isInterleavedBufferAttribute ? "index" === t2 ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e2), this) : this.setAttribute(t2, e2) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t2, new en(arguments[1], arguments[2])));
      }, wn.prototype.addDrawCall = function(t2, e2, n2) {
        void 0 !== n2 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t2, e2);
      }, wn.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
      }, wn.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      }, wn.prototype.removeAttribute = function(t2) {
        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t2);
      }, wn.prototype.applyMatrix = function(t2) {
        return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
      }, Object.defineProperties(wn.prototype, { drawcalls: { get: function() {
        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
      } }, offsets: { get: function() {
        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
      } } }), Ks.prototype.setDynamic = function(t2) {
        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t2 ? nt : et), this;
      }, Ks.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      }, hl.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      }, hl.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
      }, hl.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      }, Qs.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.");
      }, bh.prototype.onUpdate = function() {
        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
      }, Object.defineProperties(We.prototype, { wrapAround: { get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }, set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      } }, overdraw: { get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }, set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      } }, wrapRGB: { get: function() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new Qe();
      } }, shading: { get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      }, set: function(t2) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t2;
      } }, stencilMask: { get: function() {
        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
      }, set: function(t2) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t2;
      } }, vertexTangents: { get: function() {
        console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
      }, set: function() {
        console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
      } } }), Object.defineProperties(Xn.prototype, { derivatives: { get: function() {
        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
      }, set: function(t2) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t2;
      } } }), Xs.prototype.clearTarget = function(t2, e2, n2, i2) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t2), this.clear(e2, n2, i2);
      }, Xs.prototype.animate = function(t2) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t2);
      }, Xs.prototype.getCurrentRenderTarget = function() {
        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
      }, Xs.prototype.getMaxAnisotropy = function() {
        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
      }, Xs.prototype.getPrecision = function() {
        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
      }, Xs.prototype.resetGLState = function() {
        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
      }, Xs.prototype.supportsFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
      }, Xs.prototype.supportsHalfFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
      }, Xs.prototype.supportsStandardDerivatives = function() {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
      }, Xs.prototype.supportsCompressedTextureS3TC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
      }, Xs.prototype.supportsCompressedTexturePVRTC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
      }, Xs.prototype.supportsBlendMinMax = function() {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
      }, Xs.prototype.supportsVertexTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
      }, Xs.prototype.supportsInstancedArrays = function() {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
      }, Xs.prototype.enableScissorTest = function(t2) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t2);
      }, Xs.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      }, Xs.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      }, Xs.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      }, Xs.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      }, Xs.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      }, Xs.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      }, Xs.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      }, Xs.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      }, Xs.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      }, Xs.prototype.getActiveMipMapLevel = function() {
        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
      }, Object.defineProperties(Xs.prototype, { shadowMapEnabled: { get: function() {
        return this.shadowMap.enabled;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t2;
      } }, shadowMapType: { get: function() {
        return this.shadowMap.type;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t2;
      } }, shadowMapCullFace: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      } }, context: { get: function() {
        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
      } }, vr: { get: function() {
        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
      } }, gammaInput: { get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      } }, gammaOutput: { get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = true === t2 ? Y : X;
      } }, toneMappingWhitePoint: { get: function() {
        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      } } }), Object.defineProperties(Fs.prototype, { cullFace: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      } }, renderReverseSided: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      } }, renderSingleSided: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      } } }), Object.defineProperties(Tt.prototype, { wrapS: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t2;
      } }, wrapT: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t2;
      } }, magFilter: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t2;
      } }, minFilter: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t2;
      } }, anisotropy: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t2;
      } }, offset: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t2;
      } }, repeat: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t2;
      } }, format: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t2;
      } }, type: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t2;
      } }, generateMipmaps: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t2;
      } } }), th.prototype.load = function(t2) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const e2 = this;
        return new Vc().load(t2, function(t3) {
          e2.setBuffer(t3);
        }), this;
      }, sh.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
      }, Qn.prototype.updateCubeMap = function(t2, e2) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t2, e2);
      }, Qn.prototype.clear = function(t2, e2, n2, i2) {
        return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t2, e2, n2, i2);
      }, _t.crossOrigin = void 0, _t.loadTexture = function(t2, e2, n2, i2) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const r2 = new oc();
        r2.setCrossOrigin(this.crossOrigin);
        const s2 = r2.load(t2, n2, void 0, i2);
        return e2 && (s2.mapping = e2), s2;
      }, _t.loadTextureCube = function(t2, e2, n2, i2) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const r2 = new sc();
        r2.setCrossOrigin(this.crossOrigin);
        const s2 = r2.load(t2, n2, void 0, i2);
        return e2 && (s2.mapping = e2), s2;
      }, _t.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      }, _t.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      const nu = { createMultiMaterialObject: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      }, detach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      }, attach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      } };
      "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: e } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = e), t.ACESFilmicToneMapping = 4, t.AddEquation = n, t.AddOperation = 2, t.AdditiveAnimationBlendMode = q, t.AdditiveBlending = 2, t.AlphaFormat = 1021, t.AlwaysDepth = 1, t.AlwaysStencilFunc = 519, t.AmbientLight = Ec, t.AmbientLightProbe = jc, t.AnimationClip = Zl, t.AnimationLoader = class extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = this, s2 = new ic(this.manager);
          s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(t2, function(n3) {
            try {
              e2(r2.parse(JSON.parse(n3)));
            } catch (e3) {
              i2 ? i2(e3) : console.error(e3), r2.manager.itemError(t2);
            }
          }, n2, i2);
        }
        parse(t2) {
          const e2 = [];
          for (let n2 = 0; n2 < t2.length; n2++) {
            const i2 = Zl.parse(t2[n2]);
            e2.push(i2);
          }
          return e2;
        }
      }, t.AnimationMixer = _h, t.AnimationObjectGroup = yh, t.AnimationUtils = Fl, t.ArcCurve = yo, t.ArrayCamera = Gs, t.ArrowHelper = class extends Pe {
        constructor(t2 = new Rt(0, 0, 1), e2 = new Rt(0, 0, 0), n2 = 1, i2 = 16776960, r2 = 0.2 * n2, s2 = 0.2 * r2) {
          super(), this.type = "ArrowHelper", void 0 === Qh && (Qh = new wn(), Qh.setAttribute("position", new un([0, 0, 0, 0, 1, 0], 3)), Kh = new ao(0, 0.5, 1, 5, 1), Kh.translate(0, -0.5, 0)), this.position.copy(e2), this.line = new Va(Qh, new Fa({ color: i2, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Gn(Kh, new Ke({ color: i2, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(t2), this.setLength(n2, r2, s2);
        }
        setDirection(t2) {
          if (t2.y > 0.99999)
            this.quaternion.set(0, 0, 0, 1);
          else if (t2.y < -0.99999)
            this.quaternion.set(1, 0, 0, 0);
          else {
            Zh.set(t2.z, 0, -t2.x).normalize();
            const e2 = Math.acos(t2.y);
            this.quaternion.setFromAxisAngle(Zh, e2);
          }
        }
        setLength(t2, e2 = 0.2 * t2, n2 = 0.2 * e2) {
          this.line.scale.set(1, Math.max(1e-4, t2 - e2), 1), this.line.updateMatrix(), this.cone.scale.set(n2, e2, n2), this.cone.position.y = t2, this.cone.updateMatrix();
        }
        setColor(t2) {
          this.line.material.color.set(t2), this.cone.material.color.set(t2);
        }
        copy(t2) {
          return super.copy(t2, false), this.line.copy(t2.line), this.cone.copy(t2.cone), this;
        }
      }, t.Audio = th, t.AudioAnalyser = sh, t.AudioContext = kc, t.AudioListener = class extends Pe {
        constructor() {
          super(), this.type = "AudioListener", this.context = kc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Yc();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(t2) {
          return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t2, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(t2) {
          return this.gain.gain.setTargetAtTime(t2, this.context.currentTime, 0.01), this;
        }
        updateMatrixWorld(t2) {
          super.updateMatrixWorld(t2);
          const e2 = this.context.listener, n2 = this.up;
          if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Zc, Qc, Kc), $c.set(0, 0, -1).applyQuaternion(Qc), e2.positionX) {
            const t3 = this.context.currentTime + this.timeDelta;
            e2.positionX.linearRampToValueAtTime(Zc.x, t3), e2.positionY.linearRampToValueAtTime(Zc.y, t3), e2.positionZ.linearRampToValueAtTime(Zc.z, t3), e2.forwardX.linearRampToValueAtTime($c.x, t3), e2.forwardY.linearRampToValueAtTime($c.y, t3), e2.forwardZ.linearRampToValueAtTime($c.z, t3), e2.upX.linearRampToValueAtTime(n2.x, t3), e2.upY.linearRampToValueAtTime(n2.y, t3), e2.upZ.linearRampToValueAtTime(n2.z, t3);
          } else
            e2.setPosition(Zc.x, Zc.y, Zc.z), e2.setOrientation($c.x, $c.y, $c.z, n2.x, n2.y, n2.z);
        }
      }, t.AudioLoader = Vc, t.AxesHelper = $h, t.AxisHelper = function(t2) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new $h(t2);
      }, t.BackSide = 1, t.BasicDepthPacking = 3200, t.BasicShadowMap = 0, t.BinaryTextureLoader = function(t2) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new ac(t2);
      }, t.Bone = Ea, t.BooleanKeyframeTrack = Vl, t.BoundingBoxHelper = function(t2, e2) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Jh(t2, e2);
      }, t.Box2 = Ah, t.Box3 = It, t.Box3Helper = class extends qa {
        constructor(t2, e2 = 16776960) {
          const n2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i2 = new wn();
          i2.setIndex(new en(n2, 1)), i2.setAttribute("position", new un([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i2, new Fa({ color: e2, toneMapped: false })), this.box = t2, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(t2) {
          const e2 = this.box;
          e2.isEmpty() || (e2.getCenter(this.position), e2.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(t2));
        }
      }, t.BoxBufferGeometry = Vn, t.BoxGeometry = Vn, t.BoxHelper = Jh, t.BufferAttribute = en, t.BufferGeometry = wn, t.BufferGeometryLoader = Dc, t.ByteType = 1010, t.Cache = Kl, t.Camera = Yn, t.CameraHelper = class extends qa {
        constructor(t2) {
          const e2 = new wn(), n2 = new Fa({ color: 16777215, vertexColors: true, toneMapped: false }), i2 = [], r2 = [], s2 = {}, a2 = new Qe(16755200), o3 = new Qe(16711680), l2 = new Qe(43775), c2 = new Qe(16777215), h2 = new Qe(3355443);
          function u2(t3, e3, n3) {
            d2(t3, n3), d2(e3, n3);
          }
          function d2(t3, e3) {
            i2.push(0, 0, 0), r2.push(e3.r, e3.g, e3.b), void 0 === s2[t3] && (s2[t3] = []), s2[t3].push(i2.length / 3 - 1);
          }
          u2("n1", "n2", a2), u2("n2", "n4", a2), u2("n4", "n3", a2), u2("n3", "n1", a2), u2("f1", "f2", a2), u2("f2", "f4", a2), u2("f4", "f3", a2), u2("f3", "f1", a2), u2("n1", "f1", a2), u2("n2", "f2", a2), u2("n3", "f3", a2), u2("n4", "f4", a2), u2("p", "n1", o3), u2("p", "n2", o3), u2("p", "n3", o3), u2("p", "n4", o3), u2("u1", "u2", l2), u2("u2", "u3", l2), u2("u3", "u1", l2), u2("c", "t", c2), u2("p", "c", h2), u2("cn1", "cn2", h2), u2("cn3", "cn4", h2), u2("cf1", "cf2", h2), u2("cf3", "cf4", h2), e2.setAttribute("position", new un(i2, 3)), e2.setAttribute("color", new un(r2, 3)), super(e2, n2), this.type = "CameraHelper", this.camera = t2, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = s2, this.update();
        }
        update() {
          const t2 = this.geometry, e2 = this.pointMap;
          qh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Xh("c", e2, t2, qh, 0, 0, -1), Xh("t", e2, t2, qh, 0, 0, 1), Xh("n1", e2, t2, qh, -1, -1, -1), Xh("n2", e2, t2, qh, 1, -1, -1), Xh("n3", e2, t2, qh, -1, 1, -1), Xh("n4", e2, t2, qh, 1, 1, -1), Xh("f1", e2, t2, qh, -1, -1, 1), Xh("f2", e2, t2, qh, 1, -1, 1), Xh("f3", e2, t2, qh, -1, 1, 1), Xh("f4", e2, t2, qh, 1, 1, 1), Xh("u1", e2, t2, qh, 0.7, 1.1, -1), Xh("u2", e2, t2, qh, -0.7, 1.1, -1), Xh("u3", e2, t2, qh, 0, 2, -1), Xh("cf1", e2, t2, qh, -1, 0, 1), Xh("cf2", e2, t2, qh, 1, 0, 1), Xh("cf3", e2, t2, qh, 0, -1, 1), Xh("cf4", e2, t2, qh, 0, 1, 1), Xh("cn1", e2, t2, qh, -1, 0, -1), Xh("cn2", e2, t2, qh, 1, 0, -1), Xh("cn3", e2, t2, qh, 0, -1, -1), Xh("cn4", e2, t2, qh, 0, 1, -1), t2.getAttribute("position").needsUpdate = true;
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }, t.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been removed");
      }, t.CanvasTexture = io, t.CatmullRomCurve3 = So, t.CineonToneMapping = 3, t.CircleBufferGeometry = so, t.CircleGeometry = so, t.ClampToEdgeWrapping = u, t.Clock = Yc, t.Color = Qe, t.ColorKeyframeTrack = Wl, t.CompressedTexture = no, t.CompressedTextureLoader = class extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = this, s2 = [], a2 = new no(), o3 = new ic(this.manager);
          o3.setPath(this.path), o3.setResponseType("arraybuffer"), o3.setRequestHeader(this.requestHeader), o3.setWithCredentials(r2.withCredentials);
          let l2 = 0;
          function c2(c3) {
            o3.load(t2[c3], function(t3) {
              const n3 = r2.parse(t3, true);
              s2[c3] = { width: n3.width, height: n3.height, format: n3.format, mipmaps: n3.mipmaps }, l2 += 1, 6 === l2 && (1 === n3.mipmapCount && (a2.minFilter = g), a2.image = s2, a2.format = n3.format, a2.needsUpdate = true, e2 && e2(a2));
            }, n2, i2);
          }
          if (Array.isArray(t2))
            for (let e3 = 0, n3 = t2.length; e3 < n3; ++e3)
              c2(e3);
          else
            o3.load(t2, function(t3) {
              const n3 = r2.parse(t3, true);
              if (n3.isCubemap) {
                const t4 = n3.mipmaps.length / n3.mipmapCount;
                for (let e3 = 0; e3 < t4; e3++) {
                  s2[e3] = { mipmaps: [] };
                  for (let t5 = 0; t5 < n3.mipmapCount; t5++)
                    s2[e3].mipmaps.push(n3.mipmaps[e3 * n3.mipmapCount + t5]), s2[e3].format = n3.format, s2[e3].width = n3.width, s2[e3].height = n3.height;
                }
                a2.image = s2;
              } else
                a2.image.width = n3.width, a2.image.height = n3.height, a2.mipmaps = n3.mipmaps;
              1 === n3.mipmapCount && (a2.minFilter = g), a2.format = n3.format, a2.needsUpdate = true, e2 && e2(a2);
            }, n2, i2);
          return a2;
        }
      }, t.ConeBufferGeometry = oo, t.ConeGeometry = oo, t.CubeCamera = Qn, t.CubeReflectionMapping = r, t.CubeRefractionMapping = s, t.CubeTexture = Kn, t.CubeTextureLoader = sc, t.CubeUVReflectionMapping = l, t.CubeUVRefractionMapping = c, t.CubicBezierCurve = Lo, t.CubicBezierCurve3 = Ro, t.CubicInterpolant = Ul, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.CullFaceNone = 0, t.Curve = go, t.CurvePath = lc, t.CustomBlending = 5, t.CustomToneMapping = 5, t.CylinderBufferGeometry = ao, t.CylinderGeometry = ao, t.Cylindrical = class {
        constructor(t2 = 1, e2 = 0, n2 = 0) {
          return this.radius = t2, this.theta = e2, this.y = n2, this;
        }
        set(t2, e2, n2) {
          return this.radius = t2, this.theta = e2, this.y = n2, this;
        }
        copy(t2) {
          return this.radius = t2.radius, this.theta = t2.theta, this.y = t2.y, this;
        }
        setFromVector3(t2) {
          return this.setFromCartesianCoords(t2.x, t2.y, t2.z);
        }
        setFromCartesianCoords(t2, e2, n2) {
          return this.radius = Math.sqrt(t2 * t2 + n2 * n2), this.theta = Math.atan2(t2, n2), this.y = e2, this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }, t.DataTexture = Aa, t.DataTexture2DArray = $i, t.DataTexture3D = tr, t.DataTextureLoader = ac, t.DataUtils = class {
        static toHalfFloat(t2) {
          tu[0] = t2;
          const e2 = eu[0];
          let n2 = e2 >> 16 & 32768, i2 = e2 >> 12 & 2047;
          const r2 = e2 >> 23 & 255;
          return r2 < 103 ? n2 : r2 > 142 ? (n2 |= 31744, n2 |= (255 == r2 ? 0 : 1) && 8388607 & e2, n2) : r2 < 113 ? (i2 |= 2048, n2 |= (i2 >> 114 - r2) + (i2 >> 113 - r2 & 1), n2) : (n2 |= r2 - 112 << 10 | i2 >> 1, n2 += 1 & i2, n2);
        }
      }, t.DecrementStencilOp = 7683, t.DecrementWrapStencilOp = 34056, t.DefaultLoadingManager = tc, t.DepthFormat = A, t.DepthStencilFormat = L, t.DepthTexture = ro, t.DirectionalLight = Tc, t.DirectionalLightHelper = class extends Pe {
        constructor(t2, e2, n2) {
          super(), this.light = t2, this.light.updateMatrixWorld(), this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false, this.color = n2, void 0 === e2 && (e2 = 1);
          let i2 = new wn();
          i2.setAttribute("position", new un([-e2, e2, 0, e2, e2, 0, e2, -e2, 0, -e2, -e2, 0, -e2, e2, 0], 3));
          const r2 = new Fa({ fog: false, toneMapped: false });
          this.lightPlane = new Va(i2, r2), this.add(this.lightPlane), i2 = new wn(), i2.setAttribute("position", new un([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Va(i2, r2), this.add(this.targetLine), this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
        }
        update() {
          kh.setFromMatrixPosition(this.light.matrixWorld), Vh.setFromMatrixPosition(this.light.target.matrixWorld), Wh.subVectors(Vh, kh), this.lightPlane.lookAt(Vh), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Vh), this.targetLine.scale.z = Wh.length();
        }
      }, t.DiscreteInterpolant = Gl, t.DodecahedronBufferGeometry = co, t.DodecahedronGeometry = co, t.DoubleSide = 2, t.DstAlphaFactor = 206, t.DstColorFactor = 208, t.DynamicBufferAttribute = function(t2, e2) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new en(t2, e2).setUsage(nt);
      }, t.DynamicCopyUsage = 35050, t.DynamicDrawUsage = nt, t.DynamicReadUsage = 35049, t.EdgesGeometry = fo, t.EdgesHelper = function(t2, e2) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new qa(new fo(t2.geometry), new Fa({ color: void 0 !== e2 ? e2 : 16777215 }));
      }, t.EllipseCurve = vo, t.EqualDepth = 4, t.EqualStencilFunc = 514, t.EquirectangularReflectionMapping = a, t.EquirectangularRefractionMapping = o2, t.Euler = ge, t.EventDispatcher = rt, t.ExtrudeBufferGeometry = hl, t.ExtrudeGeometry = hl, t.FaceColors = 1, t.FileLoader = ic, t.FlatShading = 1, t.Float16BufferAttribute = hn, t.Float32Attribute = function(t2, e2) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new un(t2, e2);
      }, t.Float32BufferAttribute = un, t.Float64Attribute = function(t2, e2) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new dn(t2, e2);
      }, t.Float64BufferAttribute = dn, t.FloatType = M, t.Fog = Zs, t.FogExp2 = Js, t.Font = Uc, t.FontLoader = class extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = this, s2 = new ic(this.manager);
          s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(r2.withCredentials), s2.load(t2, function(t3) {
            let n3;
            try {
              n3 = JSON.parse(t3);
            } catch (e3) {
              console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n3 = JSON.parse(t3.substring(65, t3.length - 2));
            }
            const i3 = r2.parse(n3);
            e2 && e2(i3);
          }, n2, i2);
        }
        parse(t2) {
          return new Uc(t2);
        }
      }, t.FrontSide = 0, t.Frustum = ai, t.GLBufferAttribute = wh, t.GLSL1 = "100", t.GLSL3 = it, t.GammaEncoding = J, t.GreaterDepth = 6, t.GreaterEqualDepth = 5, t.GreaterEqualStencilFunc = 518, t.GreaterStencilFunc = 516, t.GridHelper = Gh, t.Group = ks, t.HalfFloatType = w, t.HemisphereLight = dc, t.HemisphereLightHelper = class extends Pe {
        constructor(t2, e2, n2) {
          super(), this.light = t2, this.light.updateMatrixWorld(), this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false, this.color = n2;
          const i2 = new ml(e2);
          i2.rotateY(0.5 * Math.PI), this.material = new Ke({ wireframe: true, fog: false, toneMapped: false }), void 0 === this.color && (this.material.vertexColors = true);
          const r2 = i2.getAttribute("position"), s2 = new Float32Array(3 * r2.count);
          i2.setAttribute("color", new en(s2, 3)), this.add(new Gn(i2, this.material)), this.update();
        }
        dispose() {
          this.children[0].geometry.dispose(), this.children[0].material.dispose();
        }
        update() {
          const t2 = this.children[0];
          if (void 0 !== this.color)
            this.material.color.set(this.color);
          else {
            const e2 = t2.geometry.getAttribute("color");
            Uh.copy(this.light.color), Hh.copy(this.light.groundColor);
            for (let t3 = 0, n2 = e2.count; t3 < n2; t3++) {
              const i2 = t3 < n2 / 2 ? Uh : Hh;
              e2.setXYZ(t3, i2.r, i2.g, i2.b);
            }
            e2.needsUpdate = true;
          }
          t2.lookAt(Oh.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
      }, t.HemisphereLightProbe = Wc, t.IcosahedronBufferGeometry = dl, t.IcosahedronGeometry = dl, t.ImageBitmapLoader = Fc, t.ImageLoader = rc, t.ImageUtils = _t, t.ImmediateRenderObject = Ph, t.IncrementStencilOp = 7682, t.IncrementWrapStencilOp = 34055, t.InstancedBufferAttribute = Pa, t.InstancedBufferGeometry = Ic, t.InstancedInterleavedBuffer = Mh, t.InstancedMesh = Ba, t.Int16Attribute = function(t2, e2) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new an(t2, e2);
      }, t.Int16BufferAttribute = an, t.Int32Attribute = function(t2, e2) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new ln(t2, e2);
      }, t.Int32BufferAttribute = ln, t.Int8Attribute = function(t2, e2) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new nn(t2, e2);
      }, t.Int8BufferAttribute = nn, t.IntType = 1013, t.InterleavedBuffer = Ks, t.InterleavedBufferAttribute = ta, t.Interpolant = Ol, t.InterpolateDiscrete = U, t.InterpolateLinear = H, t.InterpolateSmooth = G, t.InvertStencilOp = 5386, t.JSONLoader = function() {
        console.error("THREE.JSONLoader has been removed.");
      }, t.KeepStencilOp = tt, t.KeyframeTrack = kl, t.LOD = xa, t.LatheBufferGeometry = pl, t.LatheGeometry = pl, t.Layers = ve, t.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
      }, t.LessDepth = 2, t.LessEqualDepth = 3, t.LessEqualStencilFunc = 515, t.LessStencilFunc = 513, t.Light = uc, t.LightProbe = Rc, t.Line = Va, t.Line3 = Ch, t.LineBasicMaterial = Fa, t.LineCurve = Co, t.LineCurve3 = Po, t.LineDashedMaterial = zl, t.LineLoop = Xa, t.LinePieces = 1, t.LineSegments = qa, t.LineStrip = 0, t.LinearEncoding = X, t.LinearFilter = g, t.LinearInterpolant = Hl, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearMipmapLinearFilter = y, t.LinearMipmapNearestFilter = v, t.LinearToneMapping = 1, t.Loader = ec, t.LoaderUtils = Pc, t.LoadingManager = $l, t.LogLuvEncoding = 3003, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = 2201, t.LuminanceAlphaFormat = 1025, t.LuminanceFormat = 1024, t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, t.Material = We, t.MaterialLoader = Cc, t.Math = gt, t.MathUtils = gt, t.Matrix3 = yt, t.Matrix4 = ae, t.MaxEquation = 104, t.Mesh = Gn, t.MeshBasicMaterial = Ke, t.MeshDepthMaterial = zs, t.MeshDistanceMaterial = Bs, t.MeshFaceMaterial = function(t2) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t2;
      }, t.MeshLambertMaterial = Dl, t.MeshMatcapMaterial = Nl, t.MeshNormalMaterial = Il, t.MeshPhongMaterial = Cl, t.MeshPhysicalMaterial = Rl, t.MeshStandardMaterial = Ll, t.MeshToonMaterial = Pl, t.MinEquation = 103, t.MirroredRepeatWrapping = d, t.MixOperation = 1, t.MultiMaterial = function(t2 = []) {
        return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t2.isMultiMaterial = true, t2.materials = t2, t2.clone = function() {
          return t2.slice();
        }, t2;
      }, t.MultiplyBlending = 4, t.MultiplyOperation = 0, t.NearestFilter = p, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NearestMipmapLinearFilter = f, t.NearestMipmapNearestFilter = m, t.NeverDepth = 0, t.NeverStencilFunc = 512, t.NoBlending = 0, t.NoColors = 0, t.NoToneMapping = 0, t.NormalAnimationBlendMode = j, t.NormalBlending = 1, t.NotEqualDepth = 7, t.NotEqualStencilFunc = 517, t.NumberKeyframeTrack = jl, t.Object3D = Pe, t.ObjectLoader = class extends ec {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, n2, i2) {
          const r2 = this, s2 = "" === this.path ? Pc.extractUrlBase(t2) : this.path;
          this.resourcePath = this.resourcePath || s2;
          const a2 = new ic(this.manager);
          a2.setPath(this.path), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(this.withCredentials), a2.load(t2, function(n3) {
            let s3 = null;
            try {
              s3 = JSON.parse(n3);
            } catch (e3) {
              return void 0 !== i2 && i2(e3), void console.error("THREE:ObjectLoader: Can't parse " + t2 + ".", e3.message);
            }
            const a3 = s3.metadata;
            void 0 !== a3 && void 0 !== a3.type && "geometry" !== a3.type.toLowerCase() ? r2.parse(s3, e2) : console.error("THREE.ObjectLoader: Can't load " + t2);
          }, n2, i2);
        }
        async loadAsync(t2, e2) {
          const n2 = "" === this.path ? Pc.extractUrlBase(t2) : this.path;
          this.resourcePath = this.resourcePath || n2;
          const i2 = new ic(this.manager);
          i2.setPath(this.path), i2.setRequestHeader(this.requestHeader), i2.setWithCredentials(this.withCredentials);
          const r2 = await i2.loadAsync(t2, e2), s2 = JSON.parse(r2), a2 = s2.metadata;
          if (void 0 === a2 || void 0 === a2.type || "geometry" === a2.type.toLowerCase())
            throw new Error("THREE.ObjectLoader: Can't load " + t2);
          return await this.parseAsync(s2);
        }
        parse(t2, e2) {
          const n2 = this.parseAnimations(t2.animations), i2 = this.parseShapes(t2.shapes), r2 = this.parseGeometries(t2.geometries, i2), s2 = this.parseImages(t2.images, function() {
            void 0 !== e2 && e2(l2);
          }), a2 = this.parseTextures(t2.textures, s2), o3 = this.parseMaterials(t2.materials, a2), l2 = this.parseObject(t2.object, r2, o3, a2, n2), c2 = this.parseSkeletons(t2.skeletons, l2);
          if (this.bindSkeletons(l2, c2), void 0 !== e2) {
            let t3 = false;
            for (const e3 in s2)
              if (s2[e3] instanceof HTMLImageElement) {
                t3 = true;
                break;
              }
            false === t3 && e2(l2);
          }
          return l2;
        }
        async parseAsync(t2) {
          const e2 = this.parseAnimations(t2.animations), n2 = this.parseShapes(t2.shapes), i2 = this.parseGeometries(t2.geometries, n2), r2 = await this.parseImagesAsync(t2.images), s2 = this.parseTextures(t2.textures, r2), a2 = this.parseMaterials(t2.materials, s2), o3 = this.parseObject(t2.object, i2, a2, s2, e2), l2 = this.parseSkeletons(t2.skeletons, o3);
          return this.bindSkeletons(o3, l2), o3;
        }
        parseShapes(t2) {
          const e2 = {};
          if (void 0 !== t2)
            for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) {
              const i3 = new hc().fromJSON(t2[n2]);
              e2[i3.uuid] = i3;
            }
          return e2;
        }
        parseSkeletons(t2, e2) {
          const n2 = {}, i2 = {};
          if (e2.traverse(function(t3) {
            t3.isBone && (i2[t3.uuid] = t3);
          }), void 0 !== t2)
            for (let e3 = 0, r2 = t2.length; e3 < r2; e3++) {
              const r3 = new Ca().fromJSON(t2[e3], i2);
              n2[r3.uuid] = r3;
            }
          return n2;
        }
        parseGeometries(t2, e2) {
          const n2 = {};
          if (void 0 !== t2) {
            const i2 = new Dc();
            for (let r2 = 0, s2 = t2.length; r2 < s2; r2++) {
              let s3;
              const a2 = t2[r2];
              switch (a2.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                  s3 = i2.parse(a2);
                  break;
                case "Geometry":
                  console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                  break;
                default:
                  a2.type in El ? s3 = El[a2.type].fromJSON(a2, e2) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a2.type}"`);
              }
              s3.uuid = a2.uuid, void 0 !== a2.name && (s3.name = a2.name), true === s3.isBufferGeometry && void 0 !== a2.userData && (s3.userData = a2.userData), n2[a2.uuid] = s3;
            }
          }
          return n2;
        }
        parseMaterials(t2, e2) {
          const n2 = {}, i2 = {};
          if (void 0 !== t2) {
            const r2 = new Cc();
            r2.setTextures(e2);
            for (let e3 = 0, s2 = t2.length; e3 < s2; e3++) {
              const s3 = t2[e3];
              if ("MultiMaterial" === s3.type) {
                const t3 = [];
                for (let e4 = 0; e4 < s3.materials.length; e4++) {
                  const i3 = s3.materials[e4];
                  void 0 === n2[i3.uuid] && (n2[i3.uuid] = r2.parse(i3)), t3.push(n2[i3.uuid]);
                }
                i2[s3.uuid] = t3;
              } else
                void 0 === n2[s3.uuid] && (n2[s3.uuid] = r2.parse(s3)), i2[s3.uuid] = n2[s3.uuid];
            }
          }
          return i2;
        }
        parseAnimations(t2) {
          const e2 = {};
          if (void 0 !== t2)
            for (let n2 = 0; n2 < t2.length; n2++) {
              const i2 = t2[n2], r2 = Zl.parse(i2);
              e2[r2.uuid] = r2;
            }
          return e2;
        }
        parseImages(t2, e2) {
          const n2 = this, i2 = {};
          let r2;
          function s2(t3) {
            if ("string" == typeof t3) {
              const e3 = t3;
              return function(t4) {
                return n2.manager.itemStart(t4), r2.load(t4, function() {
                  n2.manager.itemEnd(t4);
                }, void 0, function() {
                  n2.manager.itemError(t4), n2.manager.itemEnd(t4);
                });
              }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e3) ? e3 : n2.resourcePath + e3);
            }
            return t3.data ? { data: fn(t3.type, t3.data), width: t3.width, height: t3.height } : null;
          }
          if (void 0 !== t2 && t2.length > 0) {
            const n3 = new $l(e2);
            r2 = new rc(n3), r2.setCrossOrigin(this.crossOrigin);
            for (let e3 = 0, n4 = t2.length; e3 < n4; e3++) {
              const n5 = t2[e3], r3 = n5.url;
              if (Array.isArray(r3)) {
                i2[n5.uuid] = [];
                for (let t3 = 0, e4 = r3.length; t3 < e4; t3++) {
                  const e5 = s2(r3[t3]);
                  null !== e5 && (e5 instanceof HTMLImageElement ? i2[n5.uuid].push(e5) : i2[n5.uuid].push(new Aa(e5.data, e5.width, e5.height)));
                }
              } else {
                const t3 = s2(n5.url);
                null !== t3 && (i2[n5.uuid] = t3);
              }
            }
          }
          return i2;
        }
        async parseImagesAsync(t2) {
          const e2 = this, n2 = {};
          let i2;
          async function r2(t3) {
            if ("string" == typeof t3) {
              const n3 = t3, r3 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n3) ? n3 : e2.resourcePath + n3;
              return await i2.loadAsync(r3);
            }
            return t3.data ? { data: fn(t3.type, t3.data), width: t3.width, height: t3.height } : null;
          }
          if (void 0 !== t2 && t2.length > 0) {
            i2 = new rc(this.manager), i2.setCrossOrigin(this.crossOrigin);
            for (let e3 = 0, i3 = t2.length; e3 < i3; e3++) {
              const i4 = t2[e3], s2 = i4.url;
              if (Array.isArray(s2)) {
                n2[i4.uuid] = [];
                for (let t3 = 0, e4 = s2.length; t3 < e4; t3++) {
                  const e5 = s2[t3], a2 = await r2(e5);
                  null !== a2 && (a2 instanceof HTMLImageElement ? n2[i4.uuid].push(a2) : n2[i4.uuid].push(new Aa(a2.data, a2.width, a2.height)));
                }
              } else {
                const t3 = await r2(i4.url);
                null !== t3 && (n2[i4.uuid] = t3);
              }
            }
          }
          return n2;
        }
        parseTextures(t2, e2) {
          function n2(t3, e3) {
            return "number" == typeof t3 ? t3 : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t3), e3[t3]);
          }
          const i2 = {};
          if (void 0 !== t2)
            for (let r2 = 0, s2 = t2.length; r2 < s2; r2++) {
              const s3 = t2[r2];
              let a2;
              void 0 === s3.image && console.warn('THREE.ObjectLoader: No "image" specified for', s3.uuid), void 0 === e2[s3.image] && console.warn("THREE.ObjectLoader: Undefined image", s3.image);
              const o3 = e2[s3.image];
              Array.isArray(o3) ? (a2 = new Kn(o3), 6 === o3.length && (a2.needsUpdate = true)) : (a2 = o3 && o3.data ? new Aa(o3.data, o3.width, o3.height) : new Mt(o3), o3 && (a2.needsUpdate = true)), a2.uuid = s3.uuid, void 0 !== s3.name && (a2.name = s3.name), void 0 !== s3.mapping && (a2.mapping = n2(s3.mapping, Nc)), void 0 !== s3.offset && a2.offset.fromArray(s3.offset), void 0 !== s3.repeat && a2.repeat.fromArray(s3.repeat), void 0 !== s3.center && a2.center.fromArray(s3.center), void 0 !== s3.rotation && (a2.rotation = s3.rotation), void 0 !== s3.wrap && (a2.wrapS = n2(s3.wrap[0], zc), a2.wrapT = n2(s3.wrap[1], zc)), void 0 !== s3.format && (a2.format = s3.format), void 0 !== s3.type && (a2.type = s3.type), void 0 !== s3.encoding && (a2.encoding = s3.encoding), void 0 !== s3.minFilter && (a2.minFilter = n2(s3.minFilter, Bc)), void 0 !== s3.magFilter && (a2.magFilter = n2(s3.magFilter, Bc)), void 0 !== s3.anisotropy && (a2.anisotropy = s3.anisotropy), void 0 !== s3.flipY && (a2.flipY = s3.flipY), void 0 !== s3.premultiplyAlpha && (a2.premultiplyAlpha = s3.premultiplyAlpha), void 0 !== s3.unpackAlignment && (a2.unpackAlignment = s3.unpackAlignment), i2[s3.uuid] = a2;
            }
          return i2;
        }
        parseObject(t2, e2, n2, i2, r2) {
          let s2, a2, o3;
          function l2(t3) {
            return void 0 === e2[t3] && console.warn("THREE.ObjectLoader: Undefined geometry", t3), e2[t3];
          }
          function c2(t3) {
            if (void 0 !== t3) {
              if (Array.isArray(t3)) {
                const e3 = [];
                for (let i3 = 0, r3 = t3.length; i3 < r3; i3++) {
                  const r4 = t3[i3];
                  void 0 === n2[r4] && console.warn("THREE.ObjectLoader: Undefined material", r4), e3.push(n2[r4]);
                }
                return e3;
              }
              return void 0 === n2[t3] && console.warn("THREE.ObjectLoader: Undefined material", t3), n2[t3];
            }
          }
          function h2(t3) {
            return void 0 === i2[t3] && console.warn("THREE.ObjectLoader: Undefined texture", t3), i2[t3];
          }
          switch (t2.type) {
            case "Scene":
              s2 = new Qs(), void 0 !== t2.background && (Number.isInteger(t2.background) ? s2.background = new Qe(t2.background) : s2.background = h2(t2.background)), void 0 !== t2.environment && (s2.environment = h2(t2.environment)), void 0 !== t2.fog && ("Fog" === t2.fog.type ? s2.fog = new Zs(t2.fog.color, t2.fog.near, t2.fog.far) : "FogExp2" === t2.fog.type && (s2.fog = new Js(t2.fog.color, t2.fog.density)));
              break;
            case "PerspectiveCamera":
              s2 = new Jn(t2.fov, t2.aspect, t2.near, t2.far), void 0 !== t2.focus && (s2.focus = t2.focus), void 0 !== t2.zoom && (s2.zoom = t2.zoom), void 0 !== t2.filmGauge && (s2.filmGauge = t2.filmGauge), void 0 !== t2.filmOffset && (s2.filmOffset = t2.filmOffset), void 0 !== t2.view && (s2.view = Object.assign({}, t2.view));
              break;
            case "OrthographicCamera":
              s2 = new xi(t2.left, t2.right, t2.top, t2.bottom, t2.near, t2.far), void 0 !== t2.zoom && (s2.zoom = t2.zoom), void 0 !== t2.view && (s2.view = Object.assign({}, t2.view));
              break;
            case "AmbientLight":
              s2 = new Ec(t2.color, t2.intensity);
              break;
            case "DirectionalLight":
              s2 = new Tc(t2.color, t2.intensity);
              break;
            case "PointLight":
              s2 = new wc(t2.color, t2.intensity, t2.distance, t2.decay);
              break;
            case "RectAreaLight":
              s2 = new Ac(t2.color, t2.intensity, t2.width, t2.height);
              break;
            case "SpotLight":
              s2 = new yc(t2.color, t2.intensity, t2.distance, t2.angle, t2.penumbra, t2.decay);
              break;
            case "HemisphereLight":
              s2 = new dc(t2.color, t2.groundColor, t2.intensity);
              break;
            case "LightProbe":
              s2 = new Rc().fromJSON(t2);
              break;
            case "SkinnedMesh":
              a2 = l2(t2.geometry), o3 = c2(t2.material), s2 = new Ta(a2, o3), void 0 !== t2.bindMode && (s2.bindMode = t2.bindMode), void 0 !== t2.bindMatrix && s2.bindMatrix.fromArray(t2.bindMatrix), void 0 !== t2.skeleton && (s2.skeleton = t2.skeleton);
              break;
            case "Mesh":
              a2 = l2(t2.geometry), o3 = c2(t2.material), s2 = new Gn(a2, o3);
              break;
            case "InstancedMesh":
              a2 = l2(t2.geometry), o3 = c2(t2.material);
              const e3 = t2.count, n3 = t2.instanceMatrix, i3 = t2.instanceColor;
              s2 = new Ba(a2, o3, e3), s2.instanceMatrix = new Pa(new Float32Array(n3.array), 16), void 0 !== i3 && (s2.instanceColor = new Pa(new Float32Array(i3.array), i3.itemSize));
              break;
            case "LOD":
              s2 = new xa();
              break;
            case "Line":
              s2 = new Va(l2(t2.geometry), c2(t2.material));
              break;
            case "LineLoop":
              s2 = new Xa(l2(t2.geometry), c2(t2.material));
              break;
            case "LineSegments":
              s2 = new qa(l2(t2.geometry), c2(t2.material));
              break;
            case "PointCloud":
            case "Points":
              s2 = new $a(l2(t2.geometry), c2(t2.material));
              break;
            case "Sprite":
              s2 = new fa(c2(t2.material));
              break;
            case "Group":
              s2 = new ks();
              break;
            case "Bone":
              s2 = new Ea();
              break;
            default:
              s2 = new Pe();
          }
          if (s2.uuid = t2.uuid, void 0 !== t2.name && (s2.name = t2.name), void 0 !== t2.matrix ? (s2.matrix.fromArray(t2.matrix), void 0 !== t2.matrixAutoUpdate && (s2.matrixAutoUpdate = t2.matrixAutoUpdate), s2.matrixAutoUpdate && s2.matrix.decompose(s2.position, s2.quaternion, s2.scale)) : (void 0 !== t2.position && s2.position.fromArray(t2.position), void 0 !== t2.rotation && s2.rotation.fromArray(t2.rotation), void 0 !== t2.quaternion && s2.quaternion.fromArray(t2.quaternion), void 0 !== t2.scale && s2.scale.fromArray(t2.scale)), void 0 !== t2.castShadow && (s2.castShadow = t2.castShadow), void 0 !== t2.receiveShadow && (s2.receiveShadow = t2.receiveShadow), t2.shadow && (void 0 !== t2.shadow.bias && (s2.shadow.bias = t2.shadow.bias), void 0 !== t2.shadow.normalBias && (s2.shadow.normalBias = t2.shadow.normalBias), void 0 !== t2.shadow.radius && (s2.shadow.radius = t2.shadow.radius), void 0 !== t2.shadow.mapSize && s2.shadow.mapSize.fromArray(t2.shadow.mapSize), void 0 !== t2.shadow.camera && (s2.shadow.camera = this.parseObject(t2.shadow.camera))), void 0 !== t2.visible && (s2.visible = t2.visible), void 0 !== t2.frustumCulled && (s2.frustumCulled = t2.frustumCulled), void 0 !== t2.renderOrder && (s2.renderOrder = t2.renderOrder), void 0 !== t2.userData && (s2.userData = t2.userData), void 0 !== t2.layers && (s2.layers.mask = t2.layers), void 0 !== t2.children) {
            const a3 = t2.children;
            for (let t3 = 0; t3 < a3.length; t3++)
              s2.add(this.parseObject(a3[t3], e2, n2, i2, r2));
          }
          if (void 0 !== t2.animations) {
            const e3 = t2.animations;
            for (let t3 = 0; t3 < e3.length; t3++) {
              const n3 = e3[t3];
              s2.animations.push(r2[n3]);
            }
          }
          if ("LOD" === t2.type) {
            void 0 !== t2.autoUpdate && (s2.autoUpdate = t2.autoUpdate);
            const e3 = t2.levels;
            for (let t3 = 0; t3 < e3.length; t3++) {
              const n3 = e3[t3], i3 = s2.getObjectByProperty("uuid", n3.object);
              void 0 !== i3 && s2.addLevel(i3, n3.distance);
            }
          }
          return s2;
        }
        bindSkeletons(t2, e2) {
          0 !== Object.keys(e2).length && t2.traverse(function(t3) {
            if (true === t3.isSkinnedMesh && void 0 !== t3.skeleton) {
              const n2 = e2[t3.skeleton];
              void 0 === n2 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t3.skeleton) : t3.bind(n2, t3.bindMatrix);
            }
          });
        }
        setTexturePath(t2) {
          return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t2);
        }
      }, t.ObjectSpaceNormalMap = 1, t.OctahedronBufferGeometry = ml, t.OctahedronGeometry = ml, t.OneFactor = 201, t.OneMinusDstAlphaFactor = 207, t.OneMinusDstColorFactor = 209, t.OneMinusSrcAlphaFactor = 205, t.OneMinusSrcColorFactor = 203, t.OrthographicCamera = xi, t.PCFShadowMap = 1, t.PCFSoftShadowMap = 2, t.PMREMGenerator = zi, t.ParametricBufferGeometry = fl, t.ParametricGeometry = fl, t.Particle = function(t2) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new fa(t2);
      }, t.ParticleBasicMaterial = function(t2) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ya(t2);
      }, t.ParticleSystem = function(t2, e2) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new $a(t2, e2);
      }, t.ParticleSystemMaterial = function(t2) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ya(t2);
      }, t.Path = cc, t.PerspectiveCamera = Jn, t.Plane = ii, t.PlaneBufferGeometry = ci, t.PlaneGeometry = ci, t.PlaneHelper = class extends Va {
        constructor(t2, e2 = 1, n2 = 16776960) {
          const i2 = n2, r2 = new wn();
          r2.setAttribute("position", new un([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r2.computeBoundingSphere(), super(r2, new Fa({ color: i2, toneMapped: false })), this.type = "PlaneHelper", this.plane = t2, this.size = e2;
          const s2 = new wn();
          s2.setAttribute("position", new un([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s2.computeBoundingSphere(), this.add(new Gn(s2, new Ke({ color: i2, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
        }
        updateMatrixWorld(t2) {
          let e2 = -this.plane.constant;
          Math.abs(e2) < 1e-8 && (e2 = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e2), this.children[0].material.side = e2 < 0 ? 1 : 0, this.lookAt(this.plane.normal), super.updateMatrixWorld(t2);
        }
      }, t.PointCloud = function(t2, e2) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new $a(t2, e2);
      }, t.PointCloudMaterial = function(t2) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ya(t2);
      }, t.PointLight = wc, t.PointLightHelper = class extends Gn {
        constructor(t2, e2, n2) {
          super(new yl(e2, 4, 2), new Ke({ wireframe: true, fog: false, toneMapped: false })), this.light = t2, this.light.updateMatrixWorld(), this.color = n2, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
        update() {
          void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
        }
      }, t.Points = $a, t.PointsMaterial = Ya, t.PolarGridHelper = class extends qa {
        constructor(t2 = 10, e2 = 16, n2 = 8, i2 = 64, r2 = 4473924, s2 = 8947848) {
          r2 = new Qe(r2), s2 = new Qe(s2);
          const a2 = [], o3 = [];
          for (let n3 = 0; n3 <= e2; n3++) {
            const i3 = n3 / e2 * (2 * Math.PI), l3 = Math.sin(i3) * t2, c2 = Math.cos(i3) * t2;
            a2.push(0, 0, 0), a2.push(l3, 0, c2);
            const h2 = 1 & n3 ? r2 : s2;
            o3.push(h2.r, h2.g, h2.b), o3.push(h2.r, h2.g, h2.b);
          }
          for (let e3 = 0; e3 <= n2; e3++) {
            const l3 = 1 & e3 ? r2 : s2, c2 = t2 - t2 / n2 * e3;
            for (let t3 = 0; t3 < i2; t3++) {
              let e4 = t3 / i2 * (2 * Math.PI), n3 = Math.sin(e4) * c2, r3 = Math.cos(e4) * c2;
              a2.push(n3, 0, r3), o3.push(l3.r, l3.g, l3.b), e4 = (t3 + 1) / i2 * (2 * Math.PI), n3 = Math.sin(e4) * c2, r3 = Math.cos(e4) * c2, a2.push(n3, 0, r3), o3.push(l3.r, l3.g, l3.b);
            }
          }
          const l2 = new wn();
          l2.setAttribute("position", new un(a2, 3)), l2.setAttribute("color", new un(o3, 3));
          super(l2, new Fa({ vertexColors: true, toneMapped: false })), this.type = "PolarGridHelper";
        }
      }, t.PolyhedronBufferGeometry = lo, t.PolyhedronGeometry = lo, t.PositionalAudio = class extends th {
        constructor(t2) {
          super(t2), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(t2) {
          return this.panner.refDistance = t2, this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(t2) {
          return this.panner.rolloffFactor = t2, this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(t2) {
          return this.panner.distanceModel = t2, this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(t2) {
          return this.panner.maxDistance = t2, this;
        }
        setDirectionalCone(t2, e2, n2) {
          return this.panner.coneInnerAngle = t2, this.panner.coneOuterAngle = e2, this.panner.coneOuterGain = n2, this;
        }
        updateMatrixWorld(t2) {
          if (super.updateMatrixWorld(t2), true === this.hasPlaybackControl && false === this.isPlaying)
            return;
          this.matrixWorld.decompose(eh, nh, ih), rh.set(0, 0, 1).applyQuaternion(nh);
          const e2 = this.panner;
          if (e2.positionX) {
            const t3 = this.context.currentTime + this.listener.timeDelta;
            e2.positionX.linearRampToValueAtTime(eh.x, t3), e2.positionY.linearRampToValueAtTime(eh.y, t3), e2.positionZ.linearRampToValueAtTime(eh.z, t3), e2.orientationX.linearRampToValueAtTime(rh.x, t3), e2.orientationY.linearRampToValueAtTime(rh.y, t3), e2.orientationZ.linearRampToValueAtTime(rh.z, t3);
          } else
            e2.setPosition(eh.x, eh.y, eh.z), e2.setOrientation(rh.x, rh.y, rh.z);
        }
      }, t.PropertyBinding = vh, t.PropertyMixer = ah, t.QuadraticBezierCurve = Io, t.QuadraticBezierCurve3 = Do, t.Quaternion = Lt, t.QuaternionKeyframeTrack = Xl, t.QuaternionLinearInterpolant = ql, t.REVISION = e, t.RGBADepthPacking = 3201, t.RGBAFormat = E, t.RGBAIntegerFormat = 1033, t.RGBA_ASTC_10x10_Format = 37819, t.RGBA_ASTC_10x5_Format = 37816, t.RGBA_ASTC_10x6_Format = 37817, t.RGBA_ASTC_10x8_Format = 37818, t.RGBA_ASTC_12x10_Format = 37820, t.RGBA_ASTC_12x12_Format = 37821, t.RGBA_ASTC_4x4_Format = 37808, t.RGBA_ASTC_5x4_Format = 37809, t.RGBA_ASTC_5x5_Format = 37810, t.RGBA_ASTC_6x5_Format = 37811, t.RGBA_ASTC_6x6_Format = 37812, t.RGBA_ASTC_8x5_Format = 37813, t.RGBA_ASTC_8x6_Format = 37814, t.RGBA_ASTC_8x8_Format = 37815, t.RGBA_BPTC_Format = 36492, t.RGBA_ETC2_EAC_Format = O, t.RGBA_PVRTC_2BPPV1_Format = B, t.RGBA_PVRTC_4BPPV1_Format = z, t.RGBA_S3TC_DXT1_Format = C, t.RGBA_S3TC_DXT3_Format = P, t.RGBA_S3TC_DXT5_Format = I, t.RGBDEncoding = $, t.RGBEEncoding = Z, t.RGBEFormat = 1023, t.RGBFormat = T, t.RGBIntegerFormat = 1032, t.RGBM16Encoding = K, t.RGBM7Encoding = Q, t.RGB_ETC1_Format = 36196, t.RGB_ETC2_Format = F, t.RGB_PVRTC_2BPPV1_Format = N, t.RGB_PVRTC_4BPPV1_Format = D, t.RGB_S3TC_DXT1_Format = R, t.RGFormat = 1030, t.RGIntegerFormat = 1031, t.RawShaderMaterial = _i, t.Ray = se, t.Raycaster = class {
        constructor(t2, e2, n2 = 0, i2 = 1 / 0) {
          this.ray = new se(t2, e2), this.near = n2, this.far = i2, this.camera = null, this.layers = new ve(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
        }
        set(t2, e2) {
          this.ray.set(t2, e2);
        }
        setFromCamera(t2, e2) {
          e2 && e2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e2.matrixWorld), this.ray.direction.set(t2.x, t2.y, 0.5).unproject(e2).sub(this.ray.origin).normalize(), this.camera = e2) : e2 && e2.isOrthographicCamera ? (this.ray.origin.set(t2.x, t2.y, (e2.near + e2.far) / (e2.near - e2.far)).unproject(e2), this.ray.direction.set(0, 0, -1).transformDirection(e2.matrixWorld), this.camera = e2) : console.error("THREE.Raycaster: Unsupported camera type: " + e2.type);
        }
        intersectObject(t2, e2 = false, n2 = []) {
          return Th(t2, this, n2, e2), n2.sort(Sh), n2;
        }
        intersectObjects(t2, e2 = false, n2 = []) {
          for (let i2 = 0, r2 = t2.length; i2 < r2; i2++)
            Th(t2[i2], this, n2, e2);
          return n2.sort(Sh), n2;
        }
      }, t.RectAreaLight = Ac, t.RedFormat = 1028, t.RedIntegerFormat = 1029, t.ReinhardToneMapping = 2, t.RepeatWrapping = h, t.ReplaceStencilOp = 7681, t.ReverseSubtractEquation = 102, t.RingBufferGeometry = gl, t.RingGeometry = gl, t.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, t.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, t.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, t.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, t.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, t.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, t.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, t.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, t.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, t.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, t.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, t.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, t.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, t.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, t.Scene = Qs, t.SceneUtils = nu, t.ShaderChunk = hi, t.ShaderLib = di, t.ShaderMaterial = Xn, t.ShadowMaterial = Al, t.Shape = hc, t.ShapeBufferGeometry = vl, t.ShapeGeometry = vl, t.ShapePath = Oc, t.ShapeUtils = ol, t.ShortType = 1011, t.Skeleton = Ca, t.SkeletonHelper = Bh, t.SkinnedMesh = Ta, t.SmoothShading = 2, t.Sphere = Qt, t.SphereBufferGeometry = yl, t.SphereGeometry = yl, t.Spherical = class {
        constructor(t2 = 1, e2 = 0, n2 = 0) {
          return this.radius = t2, this.phi = e2, this.theta = n2, this;
        }
        set(t2, e2, n2) {
          return this.radius = t2, this.phi = e2, this.theta = n2, this;
        }
        copy(t2) {
          return this.radius = t2.radius, this.phi = t2.phi, this.theta = t2.theta, this;
        }
        makeSafe() {
          const t2 = 1e-6;
          return this.phi = Math.max(t2, Math.min(Math.PI - t2, this.phi)), this;
        }
        setFromVector3(t2) {
          return this.setFromCartesianCoords(t2.x, t2.y, t2.z);
        }
        setFromCartesianCoords(t2, e2, n2) {
          return this.radius = Math.sqrt(t2 * t2 + e2 * e2 + n2 * n2), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t2, n2), this.phi = Math.acos(ht(e2 / this.radius, -1, 1))), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }, t.SphericalHarmonics3 = Lc, t.SplineCurve = No, t.SpotLight = yc, t.SpotLightHelper = class extends Pe {
        constructor(t2, e2) {
          super(), this.light = t2, this.light.updateMatrixWorld(), this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false, this.color = e2;
          const n2 = new wn(), i2 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
          for (let t3 = 0, e3 = 1, n3 = 32; t3 < n3; t3++, e3++) {
            const r3 = t3 / n3 * Math.PI * 2, s2 = e3 / n3 * Math.PI * 2;
            i2.push(Math.cos(r3), Math.sin(r3), 1, Math.cos(s2), Math.sin(s2), 1);
          }
          n2.setAttribute("position", new un(i2, 3));
          const r2 = new Fa({ fog: false, toneMapped: false });
          this.cone = new qa(n2, r2), this.add(this.cone), this.update();
        }
        dispose() {
          this.cone.geometry.dispose(), this.cone.material.dispose();
        }
        update() {
          this.light.updateMatrixWorld();
          const t2 = this.light.distance ? this.light.distance : 1e3, e2 = t2 * Math.tan(this.light.angle);
          this.cone.scale.set(e2, e2, t2), Ih.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Ih), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        }
      }, t.Sprite = fa, t.SpriteMaterial = ea, t.SrcAlphaFactor = 204, t.SrcAlphaSaturateFactor = 210, t.SrcColorFactor = 202, t.StaticCopyUsage = 35046, t.StaticDrawUsage = et, t.StaticReadUsage = 35045, t.StereoCamera = class {
        constructor() {
          this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Jn(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Jn(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
        }
        update(t2) {
          const e2 = this._cache;
          if (e2.focus !== t2.focus || e2.fov !== t2.fov || e2.aspect !== t2.aspect * this.aspect || e2.near !== t2.near || e2.far !== t2.far || e2.zoom !== t2.zoom || e2.eyeSep !== this.eyeSep) {
            e2.focus = t2.focus, e2.fov = t2.fov, e2.aspect = t2.aspect * this.aspect, e2.near = t2.near, e2.far = t2.far, e2.zoom = t2.zoom, e2.eyeSep = this.eyeSep;
            const n2 = t2.projectionMatrix.clone(), i2 = e2.eyeSep / 2, r2 = i2 * e2.near / e2.focus, s2 = e2.near * Math.tan(ot * e2.fov * 0.5) / e2.zoom;
            let a2, o3;
            Xc.elements[12] = -i2, qc.elements[12] = i2, a2 = -s2 * e2.aspect + r2, o3 = s2 * e2.aspect + r2, n2.elements[0] = 2 * e2.near / (o3 - a2), n2.elements[8] = (o3 + a2) / (o3 - a2), this.cameraL.projectionMatrix.copy(n2), a2 = -s2 * e2.aspect - r2, o3 = s2 * e2.aspect - r2, n2.elements[0] = 2 * e2.near / (o3 - a2), n2.elements[8] = (o3 + a2) / (o3 - a2), this.cameraR.projectionMatrix.copy(n2);
          }
          this.cameraL.matrixWorld.copy(t2.matrixWorld).multiply(Xc), this.cameraR.matrixWorld.copy(t2.matrixWorld).multiply(qc);
        }
      }, t.StreamCopyUsage = 35042, t.StreamDrawUsage = 35040, t.StreamReadUsage = 35041, t.StringKeyframeTrack = Yl, t.SubtractEquation = 101, t.SubtractiveBlending = 3, t.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, t.TangentSpaceNormalMap = 0, t.TetrahedronBufferGeometry = xl, t.TetrahedronGeometry = xl, t.TextBufferGeometry = _l, t.TextGeometry = _l, t.Texture = Mt, t.TextureLoader = oc, t.TorusBufferGeometry = bl, t.TorusGeometry = bl, t.TorusKnotBufferGeometry = Ml, t.TorusKnotGeometry = Ml, t.Triangle = ke, t.TriangleFanDrawMode = 2, t.TriangleStripDrawMode = 1, t.TrianglesDrawMode = 0, t.TubeBufferGeometry = wl, t.TubeGeometry = wl, t.UVMapping = i, t.Uint16Attribute = function(t2, e2) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new on(t2, e2);
      }, t.Uint16BufferAttribute = on, t.Uint32Attribute = function(t2, e2) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new cn(t2, e2);
      }, t.Uint32BufferAttribute = cn, t.Uint8Attribute = function(t2, e2) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new rn(t2, e2);
      }, t.Uint8BufferAttribute = rn, t.Uint8ClampedAttribute = function(t2, e2) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new sn(t2, e2);
      }, t.Uint8ClampedBufferAttribute = sn, t.Uniform = bh, t.UniformsLib = ui, t.UniformsUtils = qn, t.UnsignedByteType = x, t.UnsignedInt248Type = S, t.UnsignedIntType = b, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedShortType = _, t.VSMShadowMap = 3, t.Vector2 = vt, t.Vector3 = Rt, t.Vector4 = St, t.VectorKeyframeTrack = Jl, t.Vertex = function(t2, e2, n2) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Rt(t2, e2, n2);
      }, t.VertexColors = 2, t.VideoTexture = eo, t.WebGL1Renderer = Ys, t.WebGLCubeRenderTarget = $n, t.WebGLMultipleRenderTargets = Et, t.WebGLMultisampleRenderTarget = At, t.WebGLRenderTarget = Tt, t.WebGLRenderTargetCube = function(t2, e2, n2) {
        return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new $n(t2, n2);
      }, t.WebGLRenderer = Xs, t.WebGLUtils = Hs, t.WireframeGeometry = Sl, t.WireframeHelper = function(t2, e2) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new qa(new Sl(t2.geometry), new Fa({ color: void 0 !== e2 ? e2 : 16777215 }));
      }, t.WrapAroundEnding = W, t.XHRLoader = function(t2) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new ic(t2);
      }, t.ZeroCurvatureEnding = k, t.ZeroFactor = 200, t.ZeroSlopeEnding = V, t.ZeroStencilOp = 0, t.sRGBEncoding = Y, Object.defineProperty(t, "__esModule", { value: true });
    });
  }
});

// node_modules/threebox-plugin/src/utils/constants.js
var require_constants = __commonJS({
  "node_modules/threebox-plugin/src/utils/constants.js"(exports, module) {
    var WORLD_SIZE = 1024e3;
    var FOV_ORTHO = 0.1 / 180 * Math.PI;
    var FOV = Math.atan(3 / 4);
    var EARTH_RADIUS = 63710088e-1;
    var EARTH_CIRCUMFERENCE_EQUATOR = 40075017;
    module.exports = exports = {
      WORLD_SIZE,
      PROJECTION_WORLD_SIZE: WORLD_SIZE / (EARTH_RADIUS * Math.PI * 2),
      MERCATOR_A: EARTH_RADIUS,
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      EARTH_RADIUS,
      EARTH_CIRCUMFERENCE: 2 * Math.PI * EARTH_RADIUS,
      //40075000, // In meters
      EARTH_CIRCUMFERENCE_EQUATOR,
      FOV_ORTHO,
      // closest to 0
      FOV,
      // Math.atan(3/4) radians. If this value is changed, FOV_DEGREES must be calculated
      FOV_DEGREES: FOV * 180 / Math.PI,
      // Math.atan(3/4) in degrees
      TILE_SIZE: 512
    };
  }
});

// node_modules/threebox-plugin/src/utils/validate.js
var require_validate = __commonJS({
  "node_modules/threebox-plugin/src/utils/validate.js"(exports, module) {
    function Validate() {
    }
    Validate.prototype = {
      Coords: function(input) {
        if (input.constructor !== Array) {
          console.error("Coords must be an array");
          return;
        }
        if (input.length < 2) {
          console.error("Coords length must be at least 2");
          return;
        }
        for (const member of input) {
          if (member.constructor !== Number) {
            console.error("Coords values must be numbers");
            return;
          }
        }
        if (Math.abs(input[1]) > 90) {
          console.error("Latitude must be between -90 and 90");
          return;
        }
        return input;
      },
      Line: function(input) {
        var scope = this;
        if (input.constructor !== Array) {
          console.error("Line must be an array");
          return;
        }
        for (const coord of input) {
          if (!scope.Coords(coord)) {
            console.error("Each coordinate in a line must be a valid Coords type");
            return;
          }
        }
        return input;
      },
      Rotation: function(input) {
        if (input.constructor === Number)
          input = { z: input };
        else if (input.constructor === Object) {
          for (const key of Object.keys(input)) {
            if (!["x", "y", "z"].includes(key)) {
              console.error("Rotation parameters must be x, y, or z");
              return;
            }
            if (input[key].constructor !== Number) {
              console.error("Individual rotation values must be numbers");
              return;
            }
          }
        } else {
          console.error("Rotation must be an object or a number");
          return;
        }
        return input;
      },
      Scale: function(input) {
        if (input.constructor === Number) {
          input = { x: input, y: input, z: input };
        } else if (input.constructor === Object) {
          for (const key of Object.keys(input)) {
            if (!["x", "y", "z"].includes(key)) {
              console.error("Scale parameters must be x, y, or z");
              return;
            }
            if (input[key].constructor !== Number) {
              console.error("Individual scale values must be numbers");
              return;
            }
          }
        } else {
          console.error("Scale must be an object or a number");
          return;
        }
        return input;
      }
    };
    module.exports = exports = Validate;
  }
});

// node_modules/threebox-plugin/src/utils/utils.js
var require_utils = __commonJS({
  "node_modules/threebox-plugin/src/utils/utils.js"(exports, module) {
    var THREE2 = require_three();
    var Constants = require_constants();
    var validate = require_validate();
    var utils = {
      prettyPrintMatrix: function(uglymatrix) {
        for (var s = 0; s < 4; s++) {
          var quartet = [
            uglymatrix[s],
            uglymatrix[s + 4],
            uglymatrix[s + 8],
            uglymatrix[s + 12]
          ];
          console.log(quartet.map(function(num) {
            return num.toFixed(4);
          }));
        }
      },
      makePerspectiveMatrix: function(fovy, aspect, near, far) {
        var out = new THREE2.Matrix4();
        var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
        var newMatrix = [
          f / aspect,
          0,
          0,
          0,
          0,
          f,
          0,
          0,
          0,
          0,
          (far + near) * nf,
          -1,
          0,
          0,
          2 * far * near * nf,
          0
        ];
        out.elements = newMatrix;
        return out;
      },
      //[jscastro] new orthographic matrix calculations https://en.wikipedia.org/wiki/Orthographic_projection and validated with https://bit.ly/3rPvB9Y
      makeOrthographicMatrix: function(left, right, top, bottom, near, far) {
        var out = new THREE2.Matrix4();
        const w = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x = (right + left) * w;
        const y = (top + bottom) * h;
        const z = near * p;
        var newMatrix = [
          2 * w,
          0,
          0,
          0,
          0,
          2 * h,
          0,
          0,
          0,
          0,
          -1 * p,
          0,
          -x,
          -y,
          -z,
          1
        ];
        out.elements = newMatrix;
        return out;
      },
      //gimme radians
      radify: function(deg) {
        function convert(degrees) {
          degrees = degrees || 0;
          return Math.PI * 2 * degrees / 360;
        }
        if (typeof deg === "object") {
          if (deg.length > 0) {
            return deg.map(function(degree) {
              return convert(degree);
            });
          } else {
            return [convert(deg.x), convert(deg.y), convert(deg.z)];
          }
        } else
          return convert(deg);
      },
      //gimme degrees
      degreeify: function(rad) {
        function convert(radians) {
          radians = radians || 0;
          return radians * 360 / (Math.PI * 2);
        }
        if (typeof rad === "object") {
          return [convert(rad.x), convert(rad.y), convert(rad.z)];
        } else
          return convert(rad);
      },
      projectToWorld: function(coords) {
        var projected = [
          -Constants.MERCATOR_A * Constants.DEG2RAD * coords[0] * Constants.PROJECTION_WORLD_SIZE,
          -Constants.MERCATOR_A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * Constants.DEG2RAD * coords[1])) * Constants.PROJECTION_WORLD_SIZE
        ];
        if (!coords[2])
          projected.push(0);
        else {
          var pixelsPerMeter = this.projectedUnitsPerMeter(coords[1]);
          projected.push(coords[2] * pixelsPerMeter);
        }
        var result = new THREE2.Vector3(projected[0], projected[1], projected[2]);
        return result;
      },
      projectedUnitsPerMeter: function(latitude) {
        return Math.abs(Constants.WORLD_SIZE / Math.cos(Constants.DEG2RAD * latitude) / Constants.EARTH_CIRCUMFERENCE);
      },
      _circumferenceAtLatitude: function(latitude) {
        return Constants.EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);
      },
      mercatorZfromAltitude: function(altitude, lat) {
        return altitude / this._circumferenceAtLatitude(lat);
      },
      _scaleVerticesToMeters: function(centerLatLng, vertices) {
        var pixelsPerMeter = this.projectedUnitsPerMeter(centerLatLng[1]);
        var centerProjected = this.projectToWorld(centerLatLng);
        for (var i = 0; i < vertices.length; i++) {
          vertices[i].multiplyScalar(pixelsPerMeter);
        }
        return vertices;
      },
      projectToScreen: function(coords) {
        console.log("WARNING: Projecting to screen coordinates is not yet implemented");
      },
      unprojectFromScreen: function(pixel) {
        console.log("WARNING: unproject is not yet implemented");
      },
      //world units to lnglat
      unprojectFromWorld: function(worldUnits) {
        var unprojected = [
          -worldUnits.x / (Constants.MERCATOR_A * Constants.DEG2RAD * Constants.PROJECTION_WORLD_SIZE),
          2 * (Math.atan(Math.exp(worldUnits.y / (Constants.PROJECTION_WORLD_SIZE * -Constants.MERCATOR_A))) - Math.PI / 4) / Constants.DEG2RAD
        ];
        var pixelsPerMeter = this.projectedUnitsPerMeter(unprojected[1]);
        var height = worldUnits.z || 0;
        unprojected.push(height / pixelsPerMeter);
        return unprojected;
      },
      toScreenPosition: function(obj, camera) {
        var vector = new THREE2.Vector3();
        var widthHalf = 0.5 * renderer.context.canvas.width;
        var heightHalf = 0.5 * renderer.context.canvas.height;
        obj.updateMatrixWorld();
        vector.setFromMatrixPosition(obj.matrixWorld);
        vector.project(camera);
        vector.x = vector.x * widthHalf + widthHalf;
        vector.y = -(vector.y * heightHalf) + heightHalf;
        return {
          x: vector.x,
          y: vector.y
        };
      },
      //get the center point of a feature
      getFeatureCenter: function getFeatureCenter(feature, model, level) {
        let center = [];
        let latitude = 0;
        let longitude = 0;
        let height = 0;
        let coordinates = [...feature.geometry.coordinates[0]];
        if (feature.geometry.type === "Point") {
          center = [...coordinates[0]];
        } else {
          if (feature.geometry.type === "MultiPolygon")
            coordinates = coordinates[0];
          coordinates.splice(-1, 1);
          coordinates.forEach(function(c) {
            latitude += c[0];
            longitude += c[1];
          });
          center = [latitude / coordinates.length, longitude / coordinates.length];
        }
        height = this.getObjectHeightOnFloor(feature, model, level);
        center.length < 3 ? center.push(height) : center[2] = height;
        return center;
      },
      getObjectHeightOnFloor: function(feature, obj, level = feature.properties.level || 0) {
        let floorHeightMin = level * (feature.properties.levelHeight || 0);
        let base = feature.properties.base_height || feature.properties.min_height || 0;
        let height = obj && obj.model ? 0 : feature.properties.height - base;
        let objectHeight = height + base;
        let modelHeightFloor = floorHeightMin + objectHeight;
        return modelHeightFloor;
      },
      _flipMaterialSides: function(obj) {
      },
      // to improve precision, normalize a series of vector3's to their collective center, and move the resultant mesh to that center
      normalizeVertices(vertices) {
        let geometry = new THREE2.BufferGeometry();
        let positions = [];
        for (var j = 0; j < vertices.length; j++) {
          let p = vertices[j];
          positions.push(p.x, p.y, p.z);
          positions.push(p.x, p.y, p.z);
        }
        geometry.setAttribute("position", new THREE2.BufferAttribute(new Float32Array(positions), 3));
        geometry.computeBoundingSphere();
        var center = geometry.boundingSphere.center;
        var scaled = vertices.map(function(v3) {
          var normalized = v3.sub(center);
          return normalized;
        });
        return { vertices: scaled, position: center };
      },
      //flatten an array of Vector3's into a shallow array of values in x-y-z order, for bufferGeometry
      flattenVectors(vectors) {
        var flattenedArray = [];
        for (let vertex of vectors) {
          flattenedArray.push(vertex.x, vertex.y, vertex.z);
        }
        return flattenedArray;
      },
      //convert a line/polygon to Vector3's
      lnglatsToWorld: function(coords) {
        var vector3 = coords.map(
          function(pt) {
            var p = utils.projectToWorld(pt);
            var v3 = new THREE2.Vector3(p.x, p.y, p.z);
            return v3;
          }
        );
        return vector3;
      },
      extend: function(original, addition) {
        for (let key in addition)
          original[key] = addition[key];
      },
      clone: function(original) {
        var clone = {};
        for (let key in original)
          clone[key] = original[key];
        return clone;
      },
      clamp: function(n, min, max) {
        return Math.min(max, Math.max(min, n));
      },
      // retrieve object parameters from an options object
      types: {
        rotation: function(r, currentRotation) {
          if (!r) {
            r = 0;
          }
          ;
          if (typeof r === "number")
            r = { z: r };
          var degrees = this.applyDefault([r.x, r.y, r.z], currentRotation);
          var radians = utils.radify(degrees);
          return radians;
        },
        scale: function(s, currentScale) {
          if (!s) {
            s = 1;
          }
          ;
          if (typeof s === "number")
            return s = [s, s, s];
          else
            return this.applyDefault([s.x, s.y, s.z], currentScale);
        },
        applyDefault: function(array, current) {
          var output = array.map(function(item, index) {
            item = item || current[index];
            return item;
          });
          return output;
        }
      },
      toDecimal: function(n, d) {
        return Number(n.toFixed(d));
      },
      equal: function(obj1, obj2) {
        const keys1 = Object.keys(obj1);
        const keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
          return false;
        }
        if (keys1.length == 0 && keys2.length == 0 && keys1 !== keys2) {
          return false;
        }
        for (const key of keys1) {
          const val1 = obj1[key];
          const val2 = obj2[key];
          const areObjects = this.isObject(val1) && this.isObject(val2);
          if (areObjects && !equal(val1, val2) || !areObjects && val1 !== val2) {
            return false;
          }
        }
        return true;
      },
      isObject: function(object) {
        return object != null && typeof object === "object";
      },
      curveToLine: (curve, params) => {
        let { width, color } = params;
        let geometry = new THREE2.BufferGeometry().setFromPoints(
          curve.getPoints(100)
        );
        let material = new THREE2.LineBasicMaterial({
          color,
          linewidth: width
        });
        let line = new THREE2.Line(geometry, material);
        return line;
      },
      curvesToLines: (curves) => {
        var colors = [16711680, 2031360, 2490623];
        var lines = curves.map((curve, i) => {
          let params = {
            width: 3,
            color: colors[i] || "purple"
          };
          let curveline = curveToLine(curve, params);
          return curveline;
        });
        return lines;
      },
      _validate: function(userInputs, defaults) {
        userInputs = userInputs || {};
        var validatedOutput = {};
        utils.extend(validatedOutput, userInputs);
        for (let key of Object.keys(defaults)) {
          if (userInputs[key] === void 0) {
            if (defaults[key] === null) {
              console.error(key + " is required");
              return;
            } else
              validatedOutput[key] = defaults[key];
          } else
            validatedOutput[key] = userInputs[key];
        }
        return validatedOutput;
      },
      Validator: new validate(),
      exposedMethods: ["projectToWorld", "projectedUnitsPerMeter", "extend", "unprojectFromWorld"]
    };
    module.exports = exports = utils;
  }
});

// node_modules/threebox-plugin/src/camera/CameraSync.js
var require_CameraSync = __commonJS({
  "node_modules/threebox-plugin/src/camera/CameraSync.js"(exports, module) {
    var THREE2 = require_three();
    var utils = require_utils();
    var ThreeboxConstants = require_constants();
    function CameraSync(map, camera, world) {
      this.map = map;
      this.camera = camera;
      this.active = true;
      this.camera.matrixAutoUpdate = false;
      this.world = world || new THREE2.Group();
      this.world.position.x = this.world.position.y = ThreeboxConstants.WORLD_SIZE / 2;
      this.world.matrixAutoUpdate = false;
      this.state = {
        translateCenter: new THREE2.Matrix4().makeTranslation(ThreeboxConstants.WORLD_SIZE / 2, -ThreeboxConstants.WORLD_SIZE / 2, 0),
        worldSizeRatio: ThreeboxConstants.TILE_SIZE / ThreeboxConstants.WORLD_SIZE,
        worldSize: ThreeboxConstants.TILE_SIZE * this.map.transform.scale
      };
      let _this = this;
      this.map.on("move", function() {
        _this.updateCamera();
      }).on("resize", function() {
        _this.setupCamera();
      });
      this.setupCamera();
    }
    CameraSync.prototype = {
      setupCamera: function() {
        const t = this.map.transform;
        this.camera.aspect = t.width / t.height;
        this.halfFov = t._fov / 2;
        this.cameraToCenterDistance = 0.5 / Math.tan(this.halfFov) * t.height;
        const maxPitch = t._maxPitch * Math.PI / 180;
        this.acuteAngle = Math.PI / 2 - maxPitch;
        this.updateCamera();
      },
      updateCamera: function(ev) {
        if (!this.camera) {
          console.log("nocamera");
          return;
        }
        const t = this.map.transform;
        this.camera.aspect = t.width / t.height;
        const offset = t.centerOffset || new THREE2.Vector3();
        let farZ = 0;
        let furthestDistance = 0;
        this.halfFov = t._fov / 2;
        const groundAngle = Math.PI / 2 + t._pitch;
        const pitchAngle = Math.cos(Math.PI / 2 - t._pitch);
        this.cameraToCenterDistance = 0.5 / Math.tan(this.halfFov) * t.height;
        let pixelsPerMeter = 1;
        const worldSize = this.worldSize();
        if (this.map.tb.mapboxVersion >= 2) {
          pixelsPerMeter = this.mercatorZfromAltitude(1, t.center.lat) * worldSize;
          const fovAboveCenter = t._fov * (0.5 + t.centerOffset.y / t.height);
          const minElevationInPixels = t.elevation ? t.elevation.getMinElevationBelowMSL() * pixelsPerMeter : 0;
          const cameraToSeaLevelDistance = (t._camera.position[2] * worldSize - minElevationInPixels) / Math.cos(t._pitch);
          const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(utils.clamp(Math.PI - groundAngle - fovAboveCenter, 0.01, Math.PI - 0.01));
          furthestDistance = pitchAngle * topHalfSurfaceDistance + cameraToSeaLevelDistance;
          const horizonDistance = cameraToSeaLevelDistance * (1 / t._horizonShift);
          farZ = Math.min(furthestDistance * 1.01, horizonDistance);
        } else {
          const topHalfSurfaceDistance = Math.sin(this.halfFov) * this.cameraToCenterDistance / Math.sin(Math.PI - groundAngle - this.halfFov);
          furthestDistance = pitchAngle * topHalfSurfaceDistance + this.cameraToCenterDistance;
          farZ = furthestDistance * 1.01;
        }
        this.cameraTranslateZ = new THREE2.Matrix4().makeTranslation(0, 0, this.cameraToCenterDistance);
        const nz = t.height / 50;
        const nearZ = Math.max(nz * pitchAngle, nz);
        const h = t.height;
        const w = t.width;
        if (this.camera instanceof THREE2.OrthographicCamera) {
          this.camera.projectionMatrix = utils.makeOrthographicMatrix(w / -2, w / 2, h / 2, h / -2, nearZ, farZ);
        } else {
          this.camera.projectionMatrix = utils.makePerspectiveMatrix(t._fov, w / h, nearZ, farZ);
        }
        this.camera.projectionMatrix.elements[8] = -offset.x * 2 / t.width;
        this.camera.projectionMatrix.elements[9] = offset.y * 2 / t.height;
        let cameraWorldMatrix = this.calcCameraMatrix(t._pitch, t.angle);
        if (t.elevation)
          cameraWorldMatrix.elements[14] = t._camera.position[2] * worldSize;
        this.camera.matrixWorld.copy(cameraWorldMatrix);
        let zoomPow = t.scale * this.state.worldSizeRatio;
        let scale = new THREE2.Matrix4();
        let translateMap = new THREE2.Matrix4();
        let rotateMap = new THREE2.Matrix4();
        scale.makeScale(zoomPow, zoomPow, zoomPow);
        let x = t.x || t.point.x;
        let y = t.y || t.point.y;
        translateMap.makeTranslation(-x, y, 0);
        rotateMap.makeRotationZ(Math.PI);
        this.world.matrix = new THREE2.Matrix4().premultiply(rotateMap).premultiply(this.state.translateCenter).premultiply(scale).premultiply(translateMap);
        this.map.fire("CameraSynced", { detail: { nearZ, farZ, pitch: t._pitch, angle: t.angle, furthestDistance, cameraToCenterDistance: this.cameraToCenterDistance, t: this.map.transform, tbProjMatrix: this.camera.projectionMatrix.elements, tbWorldMatrix: this.world.matrix.elements, cameraSyn: CameraSync } });
      },
      worldSize() {
        let t = this.map.transform;
        return t.tileSize * t.scale;
      },
      worldSizeFromZoom() {
        let t = this.map.transform;
        return Math.pow(2, t.zoom) * t.tileSize;
      },
      mercatorZfromAltitude(altitude, lat) {
        return altitude / this.circumferenceAtLatitude(lat);
      },
      mercatorZfromZoom() {
        return this.cameraToCenterDistance / this.worldSizeFromZoom();
      },
      circumferenceAtLatitude(latitude) {
        return ThreeboxConstants.EARTH_CIRCUMFERENCE * Math.cos(latitude * Math.PI / 180);
      },
      calcCameraMatrix(pitch, angle, trz) {
        const t = this.map.transform;
        const _pitch = pitch === void 0 ? t._pitch : pitch;
        const _angle = angle === void 0 ? t.angle : angle;
        const _trz = trz === void 0 ? this.cameraTranslateZ : trz;
        return new THREE2.Matrix4().premultiply(_trz).premultiply(new THREE2.Matrix4().makeRotationX(_pitch)).premultiply(new THREE2.Matrix4().makeRotationZ(_angle));
      },
      updateCameraState() {
        let t = this.map.transform;
        if (!t.height)
          return;
        const dir = t._camera.forward();
        const distance = t.cameraToCenterDistance;
        const center = t.point;
        const zoom = t._cameraZoom ? t._cameraZoom : t._zoom;
        const altitude = this.mercatorZfromZoom(t);
        const height = altitude - this.mercatorZfromAltitude(t._centerAltitude, t.center.lat);
        const updatedWorldSize = t.cameraToCenterDistance / height;
        return [
          center.x / this.worldSize() - dir[0] * distance / updatedWorldSize,
          center.y / this.worldSize() - dir[1] * distance / updatedWorldSize,
          this.mercatorZfromAltitude(t._centerAltitude, t._center.lat) + -dir[2] * distance / updatedWorldSize
        ];
      },
      getWorldToCamera(worldSize, pixelsPerMeter) {
        let t = this.map.transform;
        const matrix = new THREE2.Matrix4();
        const matrixT = new THREE2.Matrix4();
        const o2 = t._camera._orientation;
        const p = t._camera.position;
        const invPosition = new THREE2.Vector3(p[0], p[1], p[2]);
        const quat = new THREE2.Quaternion();
        quat.set(o2[0], o2[1], o2[2], o2[3]);
        const invOrientation = quat.conjugate();
        invPosition.multiplyScalar(-worldSize);
        matrixT.makeTranslation(invPosition.x, invPosition.y, invPosition.z);
        matrix.makeRotationFromQuaternion(invOrientation).premultiply(matrixT);
        matrix.elements[1] *= -1;
        matrix.elements[5] *= -1;
        matrix.elements[9] *= -1;
        matrix.elements[13] *= -1;
        matrix.elements[8] *= pixelsPerMeter;
        matrix.elements[9] *= pixelsPerMeter;
        matrix.elements[10] *= pixelsPerMeter;
        matrix.elements[11] *= pixelsPerMeter;
        return matrix;
      },
      translate(out, a, v) {
        let x = v[0] || v.x, y = v[1] || v.y, z = v[2] || v.z;
        let a00, a01, a02, a03;
        let a10, a11, a12, a13;
        let a20, a21, a22, a23;
        if (a === out) {
          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a03;
          out[4] = a10;
          out[5] = a11;
          out[6] = a12;
          out[7] = a13;
          out[8] = a20;
          out[9] = a21;
          out[10] = a22;
          out[11] = a23;
          out[12] = a00 * x + a10 * y + a20 * z + a[12];
          out[13] = a01 * x + a11 * y + a21 * z + a[13];
          out[14] = a02 * x + a12 * y + a22 * z + a[14];
          out[15] = a03 * x + a13 * y + a23 * z + a[15];
        }
        return out;
      }
    };
    module.exports = exports = CameraSync;
  }
});

// node_modules/threebox-plugin/src/utils/suncalc.js
var require_suncalc = __commonJS({
  "node_modules/threebox-plugin/src/utils/suncalc.js"(exports, module) {
    (function() {
      "use strict";
      var PI = Math.PI, sin = Math.sin, cos = Math.cos, tan = Math.tan, asin = Math.asin, atan = Math.atan2, acos = Math.acos, rad = PI / 180;
      var dayMs = 1e3 * 60 * 60 * 24, J1970 = 2440588, J2000 = 2451545;
      function toJulian(date) {
        return date.valueOf() / dayMs - 0.5 + J1970;
      }
      function fromJulian(j) {
        return new Date((j + 0.5 - J1970) * dayMs);
      }
      function toDays(date) {
        return toJulian(date) - J2000;
      }
      var e = rad * 23.4397;
      function rightAscension(l, b) {
        return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));
      }
      function declination(l, b) {
        return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));
      }
      function azimuth(H, phi, dec) {
        return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
      }
      function altitude(H, phi, dec) {
        return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
      }
      function siderealTime(d, lw) {
        return rad * (280.16 + 360.9856235 * d) - lw;
      }
      function astroRefraction(h) {
        if (h < 0)
          h = 0;
        return 2967e-7 / Math.tan(h + 312536e-8 / (h + 0.08901179));
      }
      function solarMeanAnomaly(d) {
        return rad * (357.5291 + 0.98560028 * d);
      }
      function eclipticLongitude(M) {
        var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 3e-4 * sin(3 * M)), P = rad * 102.9372;
        return M + C + P + PI;
      }
      function sunCoords(d) {
        var M = solarMeanAnomaly(d), L = eclipticLongitude(M);
        return {
          dec: declination(L, 0),
          ra: rightAscension(L, 0)
        };
      }
      var SunCalc = {};
      SunCalc.getPosition = function(date, lat, lng) {
        var lw = rad * -lng, phi = rad * lat, d = toDays(date), c = sunCoords(d), H = siderealTime(d, lw) - c.ra;
        return {
          azimuth: azimuth(H, phi, c.dec),
          altitude: altitude(H, phi, c.dec)
        };
      };
      SunCalc.toJulian = function(date) {
        return toJulian(date);
      };
      var times = SunCalc.times = [
        [-0.833, "sunrise", "sunset"],
        [-0.3, "sunriseEnd", "sunsetStart"],
        [-6, "dawn", "dusk"],
        [-12, "nauticalDawn", "nauticalDusk"],
        [-18, "nightEnd", "night"],
        [6, "goldenHourEnd", "goldenHour"]
      ];
      SunCalc.addTime = function(angle, riseName, setName) {
        times.push([angle, riseName, setName]);
      };
      var J0 = 9e-4;
      function julianCycle(d, lw) {
        return Math.round(d - J0 - lw / (2 * PI));
      }
      function approxTransit(Ht, lw, n) {
        return J0 + (Ht + lw) / (2 * PI) + n;
      }
      function solarTransitJ(ds, M, L) {
        return J2000 + ds + 53e-4 * sin(M) - 69e-4 * sin(2 * L);
      }
      function hourAngle(h, phi, d) {
        return acos((sin(h) - sin(phi) * sin(d)) / (cos(phi) * cos(d)));
      }
      function observerAngle(height) {
        return -2.076 * Math.sqrt(height) / 60;
      }
      function getSetJ(h, lw, phi, dec, n, M, L) {
        var w = hourAngle(h, phi, dec), a = approxTransit(w, lw, n);
        return solarTransitJ(a, M, L);
      }
      SunCalc.getTimes = function(date, lat, lng, height) {
        height = height || 0;
        var lw = rad * -lng, phi = rad * lat, dh = observerAngle(height), d = toDays(date), n = julianCycle(d, lw), ds = approxTransit(0, lw, n), M = solarMeanAnomaly(ds), L = eclipticLongitude(M), dec = declination(L, 0), Jnoon = solarTransitJ(ds, M, L), i, len, time, h0, Jset, Jrise;
        var result = {
          solarNoon: fromJulian(Jnoon),
          nadir: fromJulian(Jnoon - 0.5)
        };
        for (i = 0, len = times.length; i < len; i += 1) {
          time = times[i];
          h0 = (time[0] + dh) * rad;
          Jset = getSetJ(h0, lw, phi, dec, n, M, L);
          Jrise = Jnoon - (Jset - Jnoon);
          result[time[1]] = fromJulian(Jrise);
          result[time[2]] = fromJulian(Jset);
        }
        return result;
      };
      function moonCoords(d) {
        var L = rad * (218.316 + 13.176396 * d), M = rad * (134.963 + 13.064993 * d), F = rad * (93.272 + 13.22935 * d), l = L + rad * 6.289 * sin(M), b = rad * 5.128 * sin(F), dt = 385001 - 20905 * cos(M);
        return {
          ra: rightAscension(l, b),
          dec: declination(l, b),
          dist: dt
        };
      }
      SunCalc.getMoonPosition = function(date, lat, lng) {
        var lw = rad * -lng, phi = rad * lat, d = toDays(date), c = moonCoords(d), H = siderealTime(d, lw) - c.ra, h = altitude(H, phi, c.dec), pa = atan(sin(H), tan(phi) * cos(c.dec) - sin(c.dec) * cos(H));
        h = h + astroRefraction(h);
        return {
          azimuth: azimuth(H, phi, c.dec),
          altitude: h,
          distance: c.dist,
          parallacticAngle: pa
        };
      };
      SunCalc.getMoonIllumination = function(date) {
        var d = toDays(date || /* @__PURE__ */ new Date()), s = sunCoords(d), m = moonCoords(d), sdist = 149598e3, phi = acos(sin(s.dec) * sin(m.dec) + cos(s.dec) * cos(m.dec) * cos(s.ra - m.ra)), inc = atan(sdist * sin(phi), m.dist - sdist * cos(phi)), angle = atan(cos(s.dec) * sin(s.ra - m.ra), sin(s.dec) * cos(m.dec) - cos(s.dec) * sin(m.dec) * cos(s.ra - m.ra));
        return {
          fraction: (1 + cos(inc)) / 2,
          phase: 0.5 + 0.5 * inc * (angle < 0 ? -1 : 1) / Math.PI,
          angle
        };
      };
      function hoursLater(date, h) {
        return new Date(date.valueOf() + h * dayMs / 24);
      }
      SunCalc.getMoonTimes = function(date, lat, lng, inUTC) {
        var t = new Date(date);
        if (inUTC)
          t.setUTCHours(0, 0, 0, 0);
        else
          t.setHours(0, 0, 0, 0);
        var hc = 0.133 * rad, h0 = SunCalc.getMoonPosition(t, lat, lng).altitude - hc, h1, h2, rise, set, a, b, xe, ye, d, roots, x1, x2, dx;
        for (var i = 1; i <= 24; i += 2) {
          h1 = SunCalc.getMoonPosition(hoursLater(t, i), lat, lng).altitude - hc;
          h2 = SunCalc.getMoonPosition(hoursLater(t, i + 1), lat, lng).altitude - hc;
          a = (h0 + h2) / 2 - h1;
          b = (h2 - h0) / 2;
          xe = -b / (2 * a);
          ye = (a * xe + b) * xe + h1;
          d = b * b - 4 * a * h1;
          roots = 0;
          if (d >= 0) {
            dx = Math.sqrt(d) / (Math.abs(a) * 2);
            x1 = xe - dx;
            x2 = xe + dx;
            if (Math.abs(x1) <= 1)
              roots++;
            if (Math.abs(x2) <= 1)
              roots++;
            if (x1 < -1)
              x1 = x2;
          }
          if (roots === 1) {
            if (h0 < 0)
              rise = i + x1;
            else
              set = i + x1;
          } else if (roots === 2) {
            rise = i + (ye < 0 ? x2 : x1);
            set = i + (ye < 0 ? x1 : x2);
          }
          if (rise && set)
            break;
          h0 = h2;
        }
        var result = {};
        if (rise)
          result.rise = hoursLater(t, rise);
        if (set)
          result.set = hoursLater(t, set);
        if (!rise && !set)
          result[ye > 0 ? "alwaysUp" : "alwaysDown"] = true;
        return result;
      };
      module.exports = exports = SunCalc;
    })();
  }
});

// node_modules/threebox-plugin/src/utils/material.js
var require_material = __commonJS({
  "node_modules/threebox-plugin/src/utils/material.js"(exports, module) {
    var utils = require_utils();
    var THREE2 = require_three();
    var defaults = {
      material: "MeshBasicMaterial",
      color: "black",
      opacity: 1
    };
    function material(options2) {
      var output;
      if (options2) {
        options2 = utils._validate(options2, defaults);
        if (options2.material && options2.material.isMaterial)
          output = options2.material;
        else if (options2.material || options2.color || options2.opacity) {
          output = new THREE2[options2.material]({ color: options2.color, transparent: options2.opacity < 1 });
        } else
          output = generateDefaultMaterial();
        output.opacity = options2.opacity;
        if (options2.side)
          output.side = options2.side;
      } else
        output = generateDefaultMaterial();
      function generateDefaultMaterial() {
        return new THREE2[defaults.material]({ color: defaults.color });
      }
      return output;
    }
    module.exports = exports = material;
  }
});

// node_modules/threebox-plugin/src/animation/AnimationManager.js
var require_AnimationManager = __commonJS({
  "node_modules/threebox-plugin/src/animation/AnimationManager.js"(exports, module) {
    var THREE2 = require_three();
    var utils = require_utils();
    function AnimationManager(map) {
      this.map = map;
      this.enrolledObjects = [];
      this.previousFrameTime;
    }
    AnimationManager.prototype = {
      unenroll: function(obj) {
        this.enrolledObjects.splice(this.enrolledObjects.indexOf(obj), 1);
      },
      enroll: function(obj) {
        obj.clock = new THREE2.Clock();
        obj.hasDefaultAnimation = false;
        obj.defaultAction;
        obj.actions = [];
        obj.mixer;
        if (obj.animations && obj.animations.length > 0) {
          obj.hasDefaultAnimation = true;
          let daIndex = obj.userData.defaultAnimation ? obj.userData.defaultAnimation : 0;
          obj.mixer = new THREE2.AnimationMixer(obj);
          setAction(daIndex);
        }
        function setAction(animationIndex) {
          for (let i = 0; i < obj.animations.length; i++) {
            if (animationIndex > obj.animations.length)
              console.log("The animation index " + animationIndex + " doesn't exist for this object");
            let animation = obj.animations[i];
            let action = obj.mixer.clipAction(animation);
            obj.actions.push(action);
            if (animationIndex === i) {
              obj.defaultAction = action;
              action.setEffectiveWeight(1);
            } else {
              action.setEffectiveWeight(0);
            }
            action.play();
          }
        }
        let _isPlaying = false;
        Object.defineProperty(obj, "isPlaying", {
          get() {
            return _isPlaying;
          },
          set(value) {
            if (_isPlaying != value) {
              _isPlaying = value;
              obj.dispatchEvent({ type: "IsPlayingChanged", detail: obj });
            }
          }
        });
        this.enrolledObjects.push(obj);
        obj.animationQueue = [];
        obj.set = function(options2) {
          if (options2.duration > 0) {
            let newParams = {
              start: Date.now(),
              expiration: Date.now() + options2.duration,
              endState: {}
            };
            utils.extend(options2, newParams);
            let translating = options2.coords;
            let rotating = options2.rotation;
            let scaling = options2.scale || options2.scaleX || options2.scaleY || options2.scaleZ;
            if (rotating) {
              let r = obj.rotation;
              options2.startRotation = [r.x, r.y, r.z];
              options2.endState.rotation = utils.types.rotation(options2.rotation, options2.startRotation);
              options2.rotationPerMs = options2.endState.rotation.map(function(angle, index) {
                return (angle - options2.startRotation[index]) / options2.duration;
              });
            }
            if (scaling) {
              let s = obj.scale;
              options2.startScale = [s.x, s.y, s.z];
              options2.endState.scale = utils.types.scale(options2.scale, options2.startScale);
              options2.scalePerMs = options2.endState.scale.map(function(scale, index) {
                return (scale - options2.startScale[index]) / options2.duration;
              });
            }
            if (translating)
              options2.pathCurve = new THREE2.CatmullRomCurve3(utils.lnglatsToWorld([obj.coordinates, options2.coords]));
            let entry = {
              type: "set",
              parameters: options2
            };
            this.animationQueue.push(entry);
            tb.map.repaint = true;
          } else {
            this.stop();
            options2.rotation = utils.radify(options2.rotation);
            this._setObject(options2);
          }
          return this;
        };
        obj.animationMethod = null;
        obj.stop = function(index) {
          if (obj.mixer) {
            obj.isPlaying = false;
            cancelAnimationFrame(obj.animationMethod);
          }
          this.animationQueue = [];
          return this;
        };
        obj.followPath = function(options2, cb) {
          let entry = {
            type: "followPath",
            parameters: utils._validate(options2, defaults.followPath)
          };
          utils.extend(
            entry.parameters,
            {
              pathCurve: new THREE2.CatmullRomCurve3(
                utils.lnglatsToWorld(options2.path)
              ),
              start: Date.now(),
              expiration: Date.now() + entry.parameters.duration,
              cb
            }
          );
          this.animationQueue.push(entry);
          tb.map.repaint = true;
          return this;
        };
        obj._setObject = function(options2) {
          obj.setScale();
          let p = options2.position;
          let r = options2.rotation;
          let s = options2.scale;
          let w = options2.worldCoordinates;
          let q = options2.quaternion;
          let t = options2.translate;
          let wt = options2.worldTranslate;
          if (p) {
            this.coordinates = p;
            let c = utils.projectToWorld(p);
            this.position.copy(c);
          }
          if (t) {
            this.coordinates = [this.coordinates[0] + t[0], this.coordinates[1] + t[1], this.coordinates[2] + t[2]];
            let c = utils.projectToWorld(t);
            this.position.copy(c);
            options2.position = this.coordinates;
          }
          if (wt) {
            this.translateX(wt.x);
            this.translateY(wt.y);
            this.translateZ(wt.z);
            let p2 = utils.unprojectFromWorld(this.position);
            this.coordinates = options2.position = p2;
          }
          if (r) {
            this.rotation.set(r[0], r[1], r[2]);
            options2.rotation = new THREE2.Vector3(r[0], r[1], r[2]);
          }
          if (s) {
            this.scale.set(s[0], s[1], s[2]);
            options2.scale = this.scale;
          }
          if (q) {
            this.quaternion.setFromAxisAngle(q[0], q[1]);
            options2.rotation = q[0].multiplyScalar(q[1]);
          }
          if (w) {
            this.position.copy(w);
            let p2 = utils.unprojectFromWorld(w);
            this.coordinates = options2.position = p2;
          }
          this.setBoundingBoxShadowFloor();
          this.setReceiveShadowFloor();
          this.updateMatrixWorld();
          tb.map.repaint = true;
          let e = { type: "ObjectChanged", detail: { object: this, action: { position: options2.position, rotation: options2.rotation, scale: options2.scale } } };
          this.dispatchEvent(e);
        };
        obj.playDefault = function(options2) {
          if (obj.mixer && obj.hasDefaultAnimation) {
            let newParams = {
              start: Date.now(),
              expiration: Date.now() + options2.duration,
              endState: {}
            };
            utils.extend(options2, newParams);
            obj.mixer.timeScale = options2.speed || 1;
            let entry = {
              type: "playDefault",
              parameters: options2
            };
            this.animationQueue.push(entry);
            tb.map.repaint = true;
            return this;
          }
        };
        obj.playAnimation = function(options2) {
          if (obj.mixer) {
            if (options2.animation) {
              setAction(options2.animation);
            }
            obj.playDefault(options2);
          }
        };
        obj.pauseAllActions = function() {
          if (obj.mixer) {
            obj.actions.forEach(function(action) {
              action.paused = true;
            });
          }
        };
        obj.unPauseAllActions = function() {
          if (obj.mixer) {
            obj.actions.forEach(function(action) {
              action.paused = false;
            });
          }
        };
        obj.deactivateAllActions = function() {
          if (obj.mixer) {
            obj.actions.forEach(function(action) {
              action.stop();
            });
          }
        };
        obj.activateAllActions = function() {
          if (obj.mixer) {
            obj.actions.forEach(function(action) {
              action.play();
            });
          }
        };
        obj.idle = function() {
          if (obj.mixer) {
            obj.mixer.update(0.01);
          }
          tb.map.repaint = true;
          return this;
        };
      },
      update: function(now) {
        if (this.previousFrameTime === void 0)
          this.previousFrameTime = now;
        let dimensions = ["X", "Y", "Z"];
        if (!this.enrolledObjects)
          return false;
        for (let a = this.enrolledObjects.length - 1; a >= 0; a--) {
          let object = this.enrolledObjects[a];
          if (!object.animationQueue || object.animationQueue.length === 0)
            continue;
          for (let i = object.animationQueue.length - 1; i >= 0; i--) {
            let item = object.animationQueue[i];
            if (!item)
              continue;
            let options2 = item.parameters;
            if (!options2.expiration) {
              object.animationQueue.splice(i, 1);
              if (object.animationQueue[i])
                object.animationQueue[i].parameters.start = now;
              return;
            }
            let expiring = now >= options2.expiration;
            if (expiring) {
              options2.expiration = false;
              if (item.type === "playDefault") {
                object.stop();
              } else {
                if (options2.endState)
                  object._setObject(options2.endState);
                if (typeof options2.cb != "undefined")
                  options2.cb();
              }
            } else {
              let timeProgress = (now - options2.start) / options2.duration;
              if (item.type === "set") {
                let objectState = {};
                if (options2.pathCurve)
                  objectState.worldCoordinates = options2.pathCurve.getPoint(timeProgress);
                if (options2.rotationPerMs) {
                  objectState.rotation = options2.startRotation.map(function(rad, index) {
                    return rad + options2.rotationPerMs[index] * timeProgress * options2.duration;
                  });
                }
                if (options2.scalePerMs) {
                  objectState.scale = options2.startScale.map(function(scale, index) {
                    return scale + options2.scalePerMs[index] * timeProgress * options2.duration;
                  });
                }
                object._setObject(objectState);
              }
              if (item.type === "followPath") {
                let position = options2.pathCurve.getPointAt(timeProgress);
                let objectState = { worldCoordinates: position };
                if (options2.trackHeading) {
                  let tangent = options2.pathCurve.getTangentAt(timeProgress).normalize();
                  let axis = new THREE2.Vector3(0, 0, 0);
                  let up = new THREE2.Vector3(0, 1, 0);
                  axis.crossVectors(up, tangent).normalize();
                  let radians = Math.acos(up.dot(tangent));
                  objectState.quaternion = [axis, radians];
                }
                object._setObject(objectState);
              }
              if (item.type === "playDefault") {
                object.activateAllActions();
                object.isPlaying = true;
                object.animationMethod = requestAnimationFrame(this.update);
                object.mixer.update(object.clock.getDelta());
                tb.map.repaint = true;
              }
            }
          }
        }
        this.previousFrameTime = now;
      }
    };
    var defaults = {
      followPath: {
        path: null,
        duration: 1e3,
        trackHeading: true
      }
    };
    module.exports = exports = AnimationManager;
  }
});

// node_modules/threebox-plugin/src/objects/CSS2DRenderer.js
var require_CSS2DRenderer = __commonJS({
  "node_modules/threebox-plugin/src/objects/CSS2DRenderer.js"(exports, module) {
    var THREE2 = require_three();
    (function() {
      class CSS2DObject extends THREE2.Object3D {
        constructor(element) {
          super();
          this.element = element || document.createElement("div");
          this.element.style.position = "absolute";
          this.element.style.userSelect = "none";
          this.element.setAttribute("draggable", false);
          this.alwaysVisible = false;
          Object.defineProperty(this, "layer", {
            get() {
              return this.parent && this.parent.parent ? this.parent.parent.layer : null;
            }
          });
          this.dispose = function() {
            this.remove();
            this.element = null;
          };
          this.remove = function() {
            if (this.element instanceof Element && this.element.parentNode !== null) {
              this.element.parentNode.removeChild(this.element);
            }
          };
          this.addEventListener("removed", function() {
            this.remove();
          });
        }
        copy(source, recursive) {
          super.copy(source, recursive);
          this.element = source.element.cloneNode(true);
          return this;
        }
      }
      CSS2DObject.prototype.isCSS2DObject = true;
      const _vector = new THREE2.Vector3();
      const _viewMatrix = new THREE2.Matrix4();
      const _viewProjectionMatrix = new THREE2.Matrix4();
      const _a = new THREE2.Vector3();
      const _b = new THREE2.Vector3();
      class CSS2DRenderer {
        constructor() {
          const _this = this;
          let _width, _height;
          let _widthHalf, _heightHalf;
          const cache = {
            objects: /* @__PURE__ */ new WeakMap(),
            list: /* @__PURE__ */ new Map()
          };
          this.cacheList = cache.list;
          const domElement = document.createElement("div");
          domElement.style.overflow = "hidden";
          this.domElement = domElement;
          this.getSize = function() {
            return {
              width: _width,
              height: _height
            };
          };
          this.render = function(scene, camera) {
            if (scene.autoUpdate === true)
              scene.updateMatrixWorld();
            if (camera.parent === null)
              camera.updateMatrixWorld();
            _viewMatrix.copy(camera.matrixWorldInverse);
            _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
            renderObject(scene, scene, camera);
            zOrder(scene);
          };
          this.setSize = function(width, height) {
            _width = width;
            _height = height;
            _widthHalf = _width / 2;
            _heightHalf = _height / 2;
            domElement.style.width = width + "px";
            domElement.style.height = height + "px";
          };
          function renderObject(object, scene, camera) {
            if (object.isCSS2DObject) {
              if (!object.visible) {
                cache.objects.delete({ key: object.uuid });
                cache.list.delete(object.uuid);
                object.remove();
              } else {
                object.onBeforeRender(_this, scene, camera);
                _vector.setFromMatrixPosition(object.matrixWorld);
                _vector.applyMatrix4(_viewProjectionMatrix);
                const element = object.element;
                var style;
                if (/apple/i.test(navigator.vendor)) {
                  style = "translate(-50%,-50%) translate(" + Math.round(_vector.x * _widthHalf + _widthHalf) + "px," + Math.round(-_vector.y * _heightHalf + _heightHalf) + "px)";
                } else {
                  style = "translate(-50%,-50%) translate(" + (_vector.x * _widthHalf + _widthHalf) + "px," + (-_vector.y * _heightHalf + _heightHalf) + "px)";
                }
                element.style.WebkitTransform = style;
                element.style.MozTransform = style;
                element.style.oTransform = style;
                element.style.transform = style;
                element.style.display = object.visible && _vector.z >= -1 && _vector.z <= 1 ? "" : "none";
                const objectData = {
                  distanceToCameraSquared: getDistanceToSquared(camera, object)
                };
                cache.objects.set({ key: object.uuid }, objectData);
                cache.list.set(object.uuid, object);
                if (element.parentNode !== domElement) {
                  domElement.appendChild(element);
                }
                object.onAfterRender(_this, scene, camera);
              }
            }
            for (let i = 0, l = object.children.length; i < l; i++) {
              renderObject(object.children[i], scene, camera);
            }
          }
          function getDistanceToSquared(object1, object2) {
            _a.setFromMatrixPosition(object1.matrixWorld);
            _b.setFromMatrixPosition(object2.matrixWorld);
            return _a.distanceToSquared(_b);
          }
          function filterAndFlatten(scene) {
            const result = [];
            scene.traverse(function(object) {
              if (object.isCSS2DObject)
                result.push(object);
            });
            return result;
          }
          function zOrder(scene) {
            const sorted = filterAndFlatten(scene).sort(function(a, b) {
              let cacheA = cache.objects.get({ key: a.uuid });
              let cacheB = cache.objects.get({ key: b.uuid });
              if (cacheA && cacheB) {
                const distanceA = cacheA.distanceToCameraSquared;
                const distanceB = cacheB.distanceToCameraSquared;
                return distanceA - distanceB;
              }
            });
            const zMax = sorted.length;
            for (let i = 0, l = sorted.length; i < l; i++) {
              sorted[i].element.style.zIndex = zMax - i;
            }
          }
        }
      }
      THREE2.CSS2DObject = CSS2DObject;
      THREE2.CSS2DRenderer = CSS2DRenderer;
    })();
    module.exports = exports = { CSS2DRenderer: THREE2.CSS2DRenderer, CSS2DObject: THREE2.CSS2DObject };
  }
});

// node_modules/threebox-plugin/src/objects/objects.js
var require_objects = __commonJS({
  "node_modules/threebox-plugin/src/objects/objects.js"(exports, module) {
    var utils = require_utils();
    var material = require_material();
    var THREE2 = require_three();
    var AnimationManager = require_AnimationManager();
    var CSS2D = require_CSS2DRenderer();
    function Objects() {
    }
    Objects.prototype = {
      // standard 1px line with gl
      line: function(obj) {
        obj = utils._validate(obj, this._defaults.line);
        var straightProject = utils.lnglatsToWorld(obj.geometry);
        var normalized = utils.normalizeVertices(straightProject);
        var flattenedArray = utils.flattenVectors(normalized.vertices);
        var positions = new Float32Array(flattenedArray);
        var geometry = new THREE2.BufferGeometry();
        geometry.setAttribute("position", new THREE2.BufferAttribute(positions, 3));
        var material2 = new THREE2.LineBasicMaterial({ color: 16711680, linewidth: 21 });
        var line = new THREE2.Line(geometry, material2);
        line.options = options || {};
        line.position.copy(normalized.position);
        return line;
      },
      extrusion: function(options2) {
      },
      unenroll: function(obj, isStatic) {
        var root = this;
        if (isStatic) {
        } else {
          root.animationManager.unenroll(obj);
        }
      },
      _addMethods: function(obj, isStatic) {
        var root = this;
        const labelName = "label";
        const tooltipName = "tooltip";
        const helpName = "help";
        const shadowPlane = "shadowPlane";
        if (isStatic) {
        } else {
          let _applyAxisAngle2 = function(model, point, axis, degrees) {
            let theta = utils.radify(degrees);
            model.position.sub(point);
            model.position.applyAxisAngle(axis, theta);
            model.position.add(point);
            model.rotateOnAxis(axis, theta);
            tb.map.repaint = true;
          }, zoomScale2 = function(zoom) {
            return Math.pow(2, zoom);
          };
          var _applyAxisAngle = _applyAxisAngle2, zoomScale = zoomScale2;
          if (!obj.coordinates)
            obj.coordinates = [0, 0, 0];
          Object.defineProperty(obj, "model", {
            get() {
              return obj.getObjectByName("model");
            }
          });
          let _animations;
          Object.defineProperty(obj, "animations", {
            get() {
              const model = obj.model;
              if (model) {
                return model.animations;
              } else
                return null;
            }
            //set(value) { _animations = value}
          });
          root.animationManager.enroll(obj);
          obj.setCoords = function(lnglat) {
            if (obj.userData.topMargin && obj.userData.feature) {
              lnglat[2] += ((obj.userData.feature.properties.height || 0) - (obj.userData.feature.properties.base_height || obj.userData.feature.properties.min_height || 0)) * (obj.userData.topMargin || 0);
            }
            obj.coordinates = lnglat;
            obj.set({ position: lnglat });
            return obj;
          };
          obj.setTranslate = function(lnglat) {
            obj.set({ translate: lnglat });
            return obj;
          };
          obj.setRotation = function(xyz) {
            if (typeof xyz === "number")
              xyz = { z: xyz };
            var r = {
              x: utils.radify(xyz.x) || obj.rotation.x,
              y: utils.radify(xyz.y) || obj.rotation.y,
              z: utils.radify(xyz.z) || obj.rotation.z
            };
            obj._setObject({ rotation: [r.x, r.y, r.z] });
          };
          obj.calculateAdjustedPosition = function(lnglat, xyz, inverse) {
            let location = lnglat.slice();
            let newCoords = utils.unprojectFromWorld(obj.modelSize);
            if (inverse) {
              location[0] -= xyz.x != 0 ? newCoords[0] / xyz.x : 0;
              location[1] -= xyz.y != 0 ? newCoords[1] / xyz.y : 0;
              location[2] -= xyz.z != 0 ? newCoords[2] / xyz.z : 0;
            } else {
              location[0] += xyz.x != 0 ? newCoords[0] / xyz.x : 0;
              location[1] += xyz.y != 0 ? newCoords[1] / xyz.y : 0;
              location[2] += xyz.z != 0 ? newCoords[2] / xyz.z : 0;
            }
            return location;
          };
          obj.setRotationAxis = function(xyz) {
            if (typeof xyz === "number")
              xyz = { z: xyz };
            let bb = obj.modelBox();
            let point = new THREE2.Vector3(bb.max.x, bb.max.y, bb.min.z);
            if (xyz.x != 0)
              _applyAxisAngle2(obj, point, new THREE2.Vector3(0, 0, 1), xyz.x);
            if (xyz.y != 0)
              _applyAxisAngle2(obj, point, new THREE2.Vector3(0, 0, 1), xyz.y);
            if (xyz.z != 0)
              _applyAxisAngle2(obj, point, new THREE2.Vector3(0, 0, 1), xyz.z);
          };
          Object.defineProperty(obj, "scaleGroup", {
            get() {
              return obj.getObjectByName("scaleGroup");
            }
          });
          Object.defineProperty(obj, "boxGroup", {
            get() {
              return obj.getObjectByName("boxGroup");
            }
          });
          Object.defineProperty(obj, "boundingBox", {
            get() {
              return obj.getObjectByName("boxModel");
            }
          });
          let _boundingBoxShadow;
          Object.defineProperty(obj, "boundingBoxShadow", {
            get() {
              return obj.getObjectByName("boxShadow");
            }
          });
          obj.drawBoundingBox = function() {
            let bb = obj.box3();
            let boxGroup = new THREE2.Group();
            boxGroup.name = "boxGroup";
            boxGroup.updateMatrixWorld(true);
            let boxModel = new THREE2.Box3Helper(bb, Objects.prototype._defaults.colors.yellow);
            boxModel.name = "boxModel";
            boxGroup.add(boxModel);
            boxModel.layers.disable(0);
            let bb2 = bb.clone();
            bb2.max.z = bb2.min.z;
            let boxShadow = new THREE2.Box3Helper(bb2, Objects.prototype._defaults.colors.black);
            boxShadow.name = "boxShadow";
            boxGroup.add(boxShadow);
            boxShadow.layers.disable(0);
            boxGroup.visible = false;
            obj.scaleGroup.add(boxGroup);
            obj.setBoundingBoxShadowFloor();
          };
          obj.setBoundingBoxShadowFloor = function() {
            if (obj.boundingBoxShadow) {
              let h = -obj.modelHeight, r = obj.rotation, o2 = obj.boundingBoxShadow;
              o2.box.max.z = o2.box.min.z = h;
              o2.rotation.y = r.y;
              o2.rotation.x = -r.x;
            }
          };
          obj.setAnchor = function(anchor) {
            const b = obj.box3();
            const c = b.getCenter(new THREE2.Vector3());
            obj.none = { x: 0, y: 0, z: 0 };
            obj.center = { x: c.x, y: c.y, z: b.min.z };
            obj.bottom = { x: c.x, y: b.max.y, z: b.min.z };
            obj.bottomLeft = { x: b.max.x, y: b.max.y, z: b.min.z };
            obj.bottomRight = { x: b.min.x, y: b.max.y, z: b.min.z };
            obj.top = { x: c.x, y: b.min.y, z: b.min.z };
            obj.topLeft = { x: b.max.x, y: b.min.y, z: b.min.z };
            obj.topRight = { x: b.min.x, y: b.min.y, z: b.min.z };
            obj.left = { x: b.max.x, y: c.y, z: b.min.z };
            obj.right = { x: b.min.x, y: c.y, z: b.min.z };
            switch (anchor) {
              case "center":
                obj.anchor = obj.center;
                break;
              case "top":
                obj.anchor = obj.top;
                break;
              case "top-left":
                obj.anchor = obj.topLeft;
                break;
              case "top-right":
                obj.anchor = obj.topRight;
                break;
              case "left":
                obj.anchor = obj.left;
                break;
              case "right":
                obj.anchor = obj.right;
                break;
              case "bottom":
                obj.anchor = obj.bottom;
                break;
              case "bottom-left":
              default:
                obj.anchor = obj.bottomLeft;
                break;
              case "bottom-right":
                obj.anchor = obj.bottomRight;
                break;
              case "auto":
              case "none":
                obj.anchor = obj.none;
            }
            obj.model.position.set(-obj.anchor.x, -obj.anchor.y, -obj.anchor.z);
          };
          obj.setCenter = function(center) {
            if (center && (center.x != 0 || center.y != 0 || center.z != 0)) {
              let size = obj.getSize();
              obj.anchor = { x: obj.anchor.x - size.x * center.x, y: obj.anchor.y - size.y * center.y, z: obj.anchor.z - size.z * center.z };
              obj.model.position.set(-obj.anchor.x, -obj.anchor.y, -obj.anchor.z);
            }
          };
          Object.defineProperty(obj, "label", {
            get() {
              return obj.getObjectByName(labelName);
            }
          });
          Object.defineProperty(obj, "tooltip", {
            get() {
              return obj.getObjectByName(tooltipName);
            }
          });
          Object.defineProperty(obj, "help", {
            get() {
              return obj.getObjectByName(helpName);
            }
          });
          let _hidden = false;
          Object.defineProperty(obj, "hidden", {
            get() {
              return _hidden;
            },
            set(value) {
              if (_hidden != value) {
                _hidden = value;
                obj.visibility = !_hidden;
              }
            }
          });
          Object.defineProperty(obj, "visibility", {
            get() {
              return obj.visible;
            },
            set(value) {
              let _value = value;
              if (value == "visible" || value == true) {
                _value = true;
                if (obj.label)
                  obj.label.visible = _value;
              } else if (value == "none" || value == false) {
                _value = false;
                if (obj.label && obj.label.alwaysVisible)
                  obj.label.visible = _value;
                if (obj.tooltip)
                  obj.tooltip.visible = _value;
              } else
                return;
              if (obj.visible != _value) {
                if (obj.hidden && _value)
                  return;
                obj.visible = _value;
                if (obj.model) {
                  obj.model.traverse(function(c) {
                    if (c.type == "Mesh" || c.type == "SkinnedMesh") {
                      if (_value && obj.raycasted) {
                        c.layers.enable(0);
                      } else {
                        c.layers.disable(0);
                      }
                    }
                    if (c.type == "LineSegments") {
                      c.layers.disableAll();
                    }
                  });
                }
              }
            }
          });
          obj.addLabel = function(HTMLElement, visible, center, height) {
            if (HTMLElement) {
              obj.drawLabelHTML(HTMLElement, visible, center, height);
            }
          };
          obj.removeLabel = function() {
            obj.removeCSS2D(labelName);
          };
          obj.drawLabelHTML = function(HTMLElement, visible = false, center = obj.anchor, height = 0.5) {
            let divLabel = root.drawLabelHTML(HTMLElement, Objects.prototype._defaults.label.cssClass);
            let label = obj.addCSS2D(divLabel, labelName, center, height);
            label.alwaysVisible = visible;
            label.visible = visible;
            return label;
          };
          obj.addTooltip = function(tooltipText, mapboxStyle, center, custom = true, height = 1) {
            let t = obj.addHelp(tooltipText, tooltipName, mapboxStyle, center, height);
            t.visible = false;
            t.custom = custom;
          };
          obj.removeTooltip = function() {
            obj.removeCSS2D(tooltipName);
          };
          obj.addHelp = function(helpText, objName = helpName, mapboxStyle = false, center = obj.anchor, height = 0) {
            let divHelp = root.drawTooltip(helpText, mapboxStyle);
            let h = obj.addCSS2D(divHelp, objName, center, height);
            h.visible = true;
            return h;
          };
          obj.removeHelp = function() {
            obj.removeCSS2D(helpName);
          };
          obj.addCSS2D = function(element, objName, center = obj.anchor, height = 1) {
            if (element) {
              const box = obj.box3();
              const size = box.getSize(new THREE2.Vector3());
              let bottomLeft = { x: box.max.x, y: box.max.y, z: box.min.z };
              obj.removeCSS2D(objName);
              let c = new CSS2D.CSS2DObject(element);
              c.name = objName;
              c.position.set(-size.x * 0.5 - obj.model.position.x - center.x + bottomLeft.x, -size.y * 0.5 - obj.model.position.y - center.y + bottomLeft.y, size.z * height);
              c.visible = false;
              obj.scaleGroup.add(c);
              return c;
            }
          };
          obj.removeCSS2D = function(objName) {
            let css2D = obj.getObjectByName(objName);
            if (css2D) {
              css2D.dispose();
              let g = obj.scaleGroup.children;
              g.splice(g.indexOf(css2D), 1);
            }
          };
          Object.defineProperty(obj, "shadowPlane", {
            get() {
              return obj.getObjectByName(shadowPlane);
            }
          });
          let _castShadow = false;
          Object.defineProperty(obj, "castShadow", {
            get() {
              return _castShadow;
            },
            set(value) {
              if (!obj.model || _castShadow === value)
                return;
              obj.model.traverse(function(c) {
                if (c.isMesh)
                  c.castShadow = true;
              });
              if (value) {
                const s = obj.modelSize;
                const sz = [s.x, s.y, s.z, obj.modelHeight];
                const pSize = Math.max(...sz) * 10;
                const pGeo = new THREE2.PlaneBufferGeometry(pSize, pSize);
                const pMat = new THREE2.ShadowMaterial();
                pMat.opacity = 0.5;
                let p = new THREE2.Mesh(pGeo, pMat);
                p.name = shadowPlane;
                p.layers.enable(1);
                p.layers.disable(0);
                p.receiveShadow = value;
                obj.add(p);
              } else {
                obj.traverse(function(c) {
                  if (c.isMesh && c.material instanceof THREE2.ShadowMaterial)
                    obj.remove(c);
                });
              }
              _castShadow = value;
            }
          });
          obj.setReceiveShadowFloor = function() {
            if (obj.castShadow) {
              let sp = obj.shadowPlane, p = sp.position, r = sp.rotation;
              p.z = -obj.modelHeight;
              r.y = obj.rotation.y;
              r.x = -obj.rotation.x;
              if (obj.userData.units === "meters") {
                const s = obj.modelSize;
                const sz = [s.x, s.y, s.z, -p.z];
                const ps = Math.max(...sz) * 10;
                const sc = ps / sp.geometry.parameters.width;
                sp.scale.set(sc, sc, sc);
              }
            }
          };
          let _receiveShadow = false;
          Object.defineProperty(obj, "receiveShadow", {
            get() {
              return _receiveShadow;
            },
            set(value) {
              if (!obj.model || _receiveShadow === value)
                return;
              obj.model.traverse(function(c) {
                if (c.isMesh)
                  c.receiveShadow = true;
              });
              _receiveShadow = value;
            }
          });
          let _wireframe = false;
          Object.defineProperty(obj, "wireframe", {
            get() {
              return _wireframe;
            },
            set(value) {
              if (!obj.model || _wireframe === value)
                return;
              obj.model.traverse(function(c) {
                if (c.type == "Mesh" || c.type == "SkinnedMesh") {
                  let materials = [];
                  if (!Array.isArray(c.material)) {
                    materials.push(c.material);
                  } else {
                    materials = c.material;
                  }
                  let m = materials[0];
                  if (value) {
                    c.userData.materials = m;
                    c.material = m.clone();
                    c.material.wireframe = c.material.transparent = value;
                    c.material.opacity = 0.3;
                  } else {
                    c.material.dispose();
                    c.material = c.userData.materials;
                    c.userData.materials.dispose();
                    c.userData.materials = null;
                  }
                  if (value) {
                    c.layers.disable(0);
                    c.layers.enable(1);
                  } else {
                    c.layers.disable(1);
                    c.layers.enable(0);
                  }
                }
                if (c.type == "LineSegments") {
                  c.layers.disableAll();
                }
              });
              _wireframe = value;
              obj.dispatchEvent({ type: "Wireframed", detail: obj });
            }
          });
          let _color = null;
          Object.defineProperty(obj, "color", {
            get() {
              return _color;
            },
            set(value) {
              if (!obj.model || _color === value)
                return;
              obj.model.traverse(function(c) {
                if (c.type == "Mesh" || c.type == "SkinnedMesh") {
                  let materials = [];
                  if (!Array.isArray(c.material)) {
                    materials.push(c.material);
                  } else {
                    materials = c.material;
                  }
                  let m = materials[0];
                  if (value) {
                    c.userData.materials = m;
                    c.material = new THREE2.MeshStandardMaterial();
                    c.material.color.setHex(value);
                  } else {
                    c.material.dispose();
                    c.material = c.userData.materials;
                    c.userData.materials.dispose();
                    c.userData.materials = null;
                  }
                }
              });
              _color = value;
            }
          });
          let _selected = false;
          Object.defineProperty(obj, "selected", {
            get() {
              return _selected;
            },
            set(value) {
              if (value) {
                if (obj.userData.bbox && !obj.boundingBox)
                  obj.drawBoundingBox();
                if (obj.boxGroup) {
                  obj.boundingBox.material = Objects.prototype._defaults.materials.boxSelectedMaterial;
                  obj.boundingBox.parent.visible = true;
                  obj.boundingBox.layers.enable(1);
                  obj.boundingBoxShadow.layers.enable(1);
                }
                if (obj.label && !obj.label.alwaysVisible)
                  obj.label.visible = true;
              } else {
                if (obj.boxGroup) {
                  obj.remove(obj.boxGroup);
                }
                if (obj.label && !obj.label.alwaysVisible)
                  obj.label.visible = false;
                obj.removeHelp();
              }
              if (obj.tooltip)
                obj.tooltip.visible = value;
              if (_selected != value) {
                _selected = value;
                obj.dispatchEvent({ type: "SelectedChange", detail: obj });
              }
            }
          });
          let _raycasted = true;
          Object.defineProperty(obj, "raycasted", {
            get() {
              return _raycasted;
            },
            set(value) {
              if (!obj.model || _raycasted === value)
                return;
              obj.model.traverse(function(c) {
                if (c.type == "Mesh" || c.type == "SkinnedMesh") {
                  if (!value) {
                    c.layers.disable(0);
                    c.layers.enable(1);
                  } else {
                    c.layers.disable(1);
                    c.layers.enable(0);
                  }
                }
              });
              _raycasted = value;
            }
          });
          let _over = false;
          Object.defineProperty(obj, "over", {
            get() {
              return _over;
            },
            set(value) {
              if (value) {
                if (!obj.selected) {
                  if (obj.userData.bbox && !obj.boundingBox)
                    obj.drawBoundingBox();
                  if (obj.userData.tooltip && !obj.tooltip)
                    obj.addTooltip(obj.uuid, true, obj.anchor, false);
                  if (obj.boxGroup) {
                    obj.boundingBox.material = Objects.prototype._defaults.materials.boxOverMaterial;
                    obj.boundingBox.parent.visible = true;
                    obj.boundingBox.layers.enable(1);
                    obj.boundingBoxShadow.layers.enable(1);
                  }
                }
                if (obj.label && !obj.label.alwaysVisible) {
                  obj.label.visible = true;
                }
                obj.dispatchEvent({ type: "ObjectMouseOver", detail: obj });
              } else {
                if (!obj.selected) {
                  if (obj.boxGroup) {
                    obj.remove(obj.boxGroup);
                    if (obj.tooltip && !obj.tooltip.custom)
                      obj.removeTooltip();
                  }
                  if (obj.label && !obj.label.alwaysVisible) {
                    obj.label.visible = false;
                  }
                }
                obj.dispatchEvent({ type: "ObjectMouseOut", detail: obj });
              }
              if (obj.tooltip)
                obj.tooltip.visible = value || obj.selected;
              _over = value;
            }
          });
          obj.box3 = function() {
            obj.updateMatrix();
            obj.updateMatrixWorld(true, true);
            let bounds;
            if (obj.model) {
              let dup = obj.clone(true);
              let model = obj.model.clone();
              bounds = new THREE2.Box3().setFromObject(model);
              if (obj.parent) {
                let rm = new THREE2.Matrix4();
                let rmi = new THREE2.Matrix4();
                obj.matrix.extractRotation(rm);
                rmi.copy(rm).invert();
                dup.setRotationFromMatrix(rmi);
                bounds = new THREE2.Box3().setFromObject(model);
              }
            }
            return bounds;
          };
          obj.modelBox = function() {
            return obj.box3();
          };
          obj.getSize = function() {
            return obj.box3().getSize(new THREE2.Vector3(0, 0, 0));
          };
          let _modelSize = false;
          Object.defineProperty(obj, "modelSize", {
            get() {
              _modelSize = obj.getSize();
              return _modelSize;
            },
            set(value) {
              if (_modelSize != value) {
                _modelSize = value;
              }
            }
          });
          Object.defineProperty(obj, "modelHeight", {
            get() {
              let h = obj.coordinates[2] || 0;
              if (obj.userData.units === "scene")
                h *= obj.unitsPerMeter / obj.scale.x;
              return h;
            }
          });
          Object.defineProperty(obj, "unitsPerMeter", {
            get() {
              return Number(utils.projectedUnitsPerMeter(obj.coordinates[1]).toFixed(7));
            }
          });
          let _fixedZoom = null;
          Object.defineProperty(obj, "fixedZoom", {
            get() {
              return obj.userData.fixedZoom;
            },
            set(value) {
              if (obj.userData.fixedZoom === value)
                return;
              obj.userData.fixedZoom = value;
              obj.userData.units = value ? "scene" : "meters";
            }
          });
          obj.setFixedZoom = function(scale) {
            if (obj.fixedZoom != null && obj.fixedZoom != 0) {
              if (!scale)
                scale = obj.userData.mapScale;
              let s = zoomScale2(obj.fixedZoom);
              if (s > scale) {
                let calc = s / scale;
                obj.scale.set(calc, calc, calc);
              } else {
                obj.scale.set(1, 1, 1);
              }
            }
          };
          obj.setScale = function(scale) {
            if (obj.userData.units != "scene") {
              let s = obj.unitsPerMeter;
              obj.scale.set(s, s, s);
            } else if (obj.fixedZoom) {
              if (scale)
                obj.userData.mapScale = scale;
              obj.setFixedZoom(obj.userData.mapScale);
            } else
              obj.scale.set(1, 1, 1);
          };
          obj.setObjectScale = function(scale) {
            obj.setScale(scale);
            obj.setBoundingBoxShadowFloor();
            obj.setReceiveShadowFloor();
          };
        }
        obj.add = function(o2) {
          obj.scaleGroup.add(o2);
          o2.position.z = obj.coordinates[2] ? -obj.coordinates[2] : 0;
          return o2;
        };
        obj.remove = function(o2) {
          if (!o2)
            return;
          o2.traverse((m) => {
            if (m.geometry)
              m.geometry.dispose();
            if (m.material) {
              if (m.material.isMaterial) {
                cleanMaterial(m.material);
              } else {
                for (const material2 of m.material)
                  cleanMaterial(material2);
              }
            }
            if (m.dispose)
              m.dispose();
          });
          obj.scaleGroup.remove(o2);
          tb.map.repaint = true;
        };
        obj.duplicate = function(options2) {
          let dupe = obj.clone(true);
          dupe.getObjectByName("model").animations = obj.animations;
          if (dupe.userData.feature) {
            if (options2 && options2.feature)
              dupe.userData.feature = options2.feature;
            dupe.userData.feature.properties.uuid = dupe.uuid;
          }
          root._addMethods(dupe);
          if (!options2 || utils.equal(options2.scale, obj.userData.scale)) {
            dupe.copyAnchor(obj);
            return dupe;
          } else {
            dupe.userData = options2;
            dupe.userData.isGeoGroup = true;
            dupe.remove(dupe.boxGroup);
            const r = utils.types.rotation(options2.rotation, [0, 0, 0]);
            const s = utils.types.scale(options2.scale, [1, 1, 1]);
            dupe.model.position.set(0, 0, 0);
            dupe.model.rotation.set(r[0], r[1], r[2]);
            dupe.model.scale.set(s[0], s[1], s[2]);
            dupe.setAnchor(options2.anchor);
            dupe.setCenter(options2.adjustment);
            return dupe;
          }
        };
        obj.copyAnchor = function(o2) {
          obj.anchor = o2.anchor;
          obj.none = { x: 0, y: 0, z: 0 };
          obj.center = o2.center;
          obj.bottom = o2.bottom;
          obj.bottomLeft = o2.bottomLeft;
          obj.bottomRight = o2.bottomRight;
          obj.top = o2.top;
          obj.topLeft = o2.topLeft;
          obj.topRight = o2.topRight;
          obj.left = o2.left;
          obj.right = o2.right;
        };
        obj.dispose = function() {
          Objects.prototype.unenroll(obj);
          obj.traverse((o2) => {
            if (o2.parent && o2.parent.name == "world")
              return;
            if (o2.name === "threeboxObject")
              return;
            if (o2.geometry)
              o2.geometry.dispose();
            if (o2.material) {
              if (o2.material.isMaterial) {
                cleanMaterial(o2.material);
              } else {
                for (const material2 of o2.material)
                  cleanMaterial(material2);
              }
            }
            if (o2.dispose)
              o2.dispose();
          });
          obj.children = [];
        };
        const cleanMaterial = (material2) => {
          material2.dispose();
          for (const key of Object.keys(material2)) {
            const value = material2[key];
            if (value && typeof value === "object" && "minFilter" in value) {
              value.dispose();
            }
          }
          let m = material2;
          let md = m.map || m.alphaMap || m.aoMap || m.bumpMap || m.displacementMap || m.emissiveMap || m.envMap || m.lightMap || m.metalnessMap || m.normalMap || m.roughnessMap;
          if (md) {
            if (m.map)
              m.map.dispose();
            if (m.alphaMap)
              m.alphaMap.dispose();
            if (m.aoMap)
              m.aoMap.dispose();
            if (m.bumpMap)
              m.bumpMap.dispose();
            if (m.displacementMap)
              m.displacementMap.dispose();
            if (m.emissiveMap)
              m.emissiveMap.dispose();
            if (m.envMap)
              m.envMap.dispose();
            if (m.lightMap)
              m.lightMap.dispose();
            if (m.metalnessMap)
              m.metalnessMap.dispose();
            if (m.normalMap)
              m.normalMap.dispose();
            if (m.roughnessMap)
              m.roughnessMap.dispose();
          }
        };
        return obj;
      },
      _makeGroup: function(obj, options2) {
        let projScaleGroup = new THREE2.Group();
        projScaleGroup.name = "scaleGroup";
        projScaleGroup.add(obj);
        var geoGroup = new THREE2.Group();
        geoGroup.userData = options2 || {};
        geoGroup.userData.isGeoGroup = true;
        if (geoGroup.userData.feature) {
          geoGroup.userData.feature.properties.uuid = geoGroup.uuid;
        }
        var isArrayOfObjects = projScaleGroup.length;
        if (isArrayOfObjects)
          for (o of projScaleGroup)
            geoGroup.add(o);
        else
          geoGroup.add(projScaleGroup);
        geoGroup.name = "threeboxObject";
        return geoGroup;
      },
      animationManager: new AnimationManager(),
      //[jscastro] add tooltip method 
      drawTooltip: function(tooltipText, mapboxStyle = false) {
        if (tooltipText) {
          let divToolTip;
          if (mapboxStyle) {
            let divContent = document.createElement("div");
            divContent.className = "mapboxgl-popup-content";
            let strong = document.createElement("strong");
            strong.innerHTML = tooltipText;
            divContent.appendChild(strong);
            let tip = document.createElement("div");
            tip.className = "mapboxgl-popup-tip";
            let div = document.createElement("div");
            div.className = "marker mapboxgl-popup-anchor-bottom";
            div.appendChild(tip);
            div.appendChild(divContent);
            divToolTip = document.createElement("div");
            divToolTip.className += "label3D";
            divToolTip.appendChild(div);
          } else {
            divToolTip = document.createElement("span");
            divToolTip.className = this._defaults.tooltip.cssClass;
            divToolTip.innerHTML = tooltipText;
          }
          return divToolTip;
        }
      },
      //[jscastro] draw label method can be invoked separately
      drawLabelHTML: function(HTMLElement, cssClass) {
        let div = document.createElement("div");
        div.className += cssClass;
        if (typeof HTMLElement == "string") {
          div.innerHTML = HTMLElement;
        } else {
          div.innerHTML = HTMLElement.outerHTML;
        }
        return div;
      },
      _defaults: {
        colors: {
          red: new THREE2.Color(16711680),
          yellow: new THREE2.Color(16776960),
          green: new THREE2.Color(65280),
          black: new THREE2.Color(0)
        },
        materials: {
          boxNormalMaterial: new THREE2.LineBasicMaterial({ color: new THREE2.Color(16711680) }),
          boxOverMaterial: new THREE2.LineBasicMaterial({ color: new THREE2.Color(16776960) }),
          boxSelectedMaterial: new THREE2.LineBasicMaterial({ color: new THREE2.Color(65280) })
        },
        line: {
          geometry: null,
          color: "black",
          width: 1,
          opacity: 1
        },
        label: {
          htmlElement: null,
          cssClass: " label3D",
          alwaysVisible: false,
          topMargin: -0.5
        },
        tooltip: {
          text: "",
          cssClass: "toolTip text-xs",
          mapboxStyle: false,
          topMargin: 0
        },
        sphere: {
          position: [0, 0, 0],
          radius: 1,
          sides: 20,
          units: "scene",
          material: "MeshBasicMaterial",
          anchor: "bottom-left",
          bbox: true,
          tooltip: true,
          raycasted: true
        },
        tube: {
          geometry: null,
          radius: 1,
          sides: 6,
          units: "scene",
          material: "MeshBasicMaterial",
          anchor: "center",
          bbox: true,
          tooltip: true,
          raycasted: true
        },
        loadObj: {
          type: null,
          obj: null,
          units: "scene",
          scale: 1,
          rotation: 0,
          defaultAnimation: 0,
          anchor: "bottom-left",
          bbox: true,
          tooltip: true,
          raycasted: true,
          clone: true
        },
        Object3D: {
          obj: null,
          units: "scene",
          anchor: "bottom-left",
          bbox: true,
          tooltip: true,
          raycasted: true
        },
        extrusion: {
          coordinates: [[[]]],
          geometryOptions: {},
          height: 100,
          materials: new THREE2.MeshPhongMaterial({ color: 6684672, side: THREE2.DoubleSide }),
          scale: 1,
          rotation: 0,
          units: "scene",
          anchor: "center",
          bbox: true,
          tooltip: true,
          raycasted: true
        }
      },
      geometries: {
        line: ["LineString"],
        tube: ["LineString"],
        sphere: ["Point"]
      }
    };
    module.exports = exports = Objects;
  }
});

// node_modules/threebox-plugin/src/objects/Object3D.js
var require_Object3D = __commonJS({
  "node_modules/threebox-plugin/src/objects/Object3D.js"(exports, module) {
    var Objects = require_objects();
    var utils = require_utils();
    function Object3D(opt) {
      opt = utils._validate(opt, Objects.prototype._defaults.Object3D);
      let obj = opt.obj;
      const r = utils.types.rotation(opt.rotation, [0, 0, 0]);
      const s = utils.types.scale(opt.scale, [1, 1, 1]);
      obj.rotation.set(r[0], r[1], r[2]);
      obj.scale.set(s[0], s[1], s[2]);
      obj.name = "model";
      let userScaleGroup = Objects.prototype._makeGroup(obj, opt);
      opt.obj.name = "model";
      Objects.prototype._addMethods(userScaleGroup);
      userScaleGroup.setAnchor(opt.anchor);
      userScaleGroup.setCenter(opt.adjustment);
      userScaleGroup.raycasted = opt.raycasted;
      userScaleGroup.visibility = true;
      return userScaleGroup;
    }
    module.exports = exports = Object3D;
  }
});

// node_modules/threebox-plugin/src/objects/sphere.js
var require_sphere = __commonJS({
  "node_modules/threebox-plugin/src/objects/sphere.js"(exports, module) {
    var utils = require_utils();
    var material = require_material();
    var THREE2 = require_three();
    var Objects = require_objects();
    var Object3D = require_Object3D();
    function Sphere(opt) {
      opt = utils._validate(opt, Objects.prototype._defaults.sphere);
      let geometry = new THREE2.SphereBufferGeometry(opt.radius, opt.sides, opt.sides);
      let mat = material(opt);
      let output = new THREE2.Mesh(geometry, mat);
      return new Object3D({ obj: output, units: opt.units, anchor: opt.anchor, adjustment: opt.adjustment, bbox: opt.bbox, tooltip: opt.tooltip, raycasted: opt.raycasted });
    }
    module.exports = exports = Sphere;
  }
});

// node_modules/threebox-plugin/src/objects/extrusion.js
var require_extrusion = __commonJS({
  "node_modules/threebox-plugin/src/objects/extrusion.js"(exports, module) {
    var Objects = require_objects();
    var utils = require_utils();
    var THREE2 = require_three();
    var Object3D = require_Object3D();
    function extrusion(opt) {
      opt = utils._validate(opt, Objects.prototype._defaults.extrusion);
      let shape = extrusion.prototype.buildShape(opt.coordinates);
      let geometry = extrusion.prototype.buildGeometry(shape, opt.geometryOptions);
      let mesh = new THREE2.Mesh(geometry, opt.materials);
      opt.obj = mesh;
      return new Object3D(opt);
    }
    extrusion.prototype = {
      buildShape: function(coords) {
        if (coords[0] instanceof (THREE2.Vector2 || THREE2.Vector3))
          return new THREE2.Shape(coords);
        let shape = new THREE2.Shape();
        for (let i = 0; i < coords.length; i++) {
          if (i === 0) {
            shape = new THREE2.Shape(this.buildPoints(coords[0], coords[0]));
          } else {
            shape.holes.push(new THREE2.Path(this.buildPoints(coords[i], coords[0])));
          }
        }
        return shape;
      },
      buildPoints: function(coords, initCoords) {
        const points = [];
        let init = utils.projectToWorld([initCoords[0][0], initCoords[0][1], 0]);
        for (let i = 0; i < coords.length; i++) {
          let pos = utils.projectToWorld([coords[i][0], coords[i][1], 0]);
          points.push(new THREE2.Vector2(utils.toDecimal(pos.x - init.x, 9), utils.toDecimal(pos.y - init.y, 9)));
        }
        return points;
      },
      buildGeometry: function(shape, settings) {
        let geometry = new THREE2.ExtrudeBufferGeometry(shape, settings);
        geometry.computeBoundingBox();
        return geometry;
      }
    };
    module.exports = exports = extrusion;
  }
});

// node_modules/threebox-plugin/src/objects/label.js
var require_label = __commonJS({
  "node_modules/threebox-plugin/src/objects/label.js"(exports, module) {
    var utils = require_utils();
    var Objects = require_objects();
    var CSS2D = require_CSS2DRenderer();
    function Label(obj) {
      obj = utils._validate(obj, Objects.prototype._defaults.label);
      let div = Objects.prototype.drawLabelHTML(obj.htmlElement, obj.cssClass);
      let label = new CSS2D.CSS2DObject(div);
      label.name = "label";
      label.visible = obj.alwaysVisible;
      label.alwaysVisible = obj.alwaysVisible;
      var userScaleGroup = Objects.prototype._makeGroup(label, obj);
      Objects.prototype._addMethods(userScaleGroup);
      userScaleGroup.visibility = obj.alwaysVisible;
      return userScaleGroup;
    }
    module.exports = exports = Label;
  }
});

// node_modules/threebox-plugin/src/objects/tooltip.js
var require_tooltip = __commonJS({
  "node_modules/threebox-plugin/src/objects/tooltip.js"(exports, module) {
    var utils = require_utils();
    var Objects = require_objects();
    var CSS2D = require_CSS2DRenderer();
    var THREE2 = require_three();
    function Tooltip(obj) {
      obj = utils._validate(obj, Objects.prototype._defaults.tooltip);
      if (obj.text) {
        let divToolTip = Objects.prototype.drawTooltip(obj.text, obj.mapboxStyle);
        let tooltip = new CSS2D.CSS2DObject(divToolTip);
        tooltip.visible = false;
        tooltip.name = "tooltip";
        var userScaleGroup = Objects.prototype._makeGroup(tooltip, obj);
        Objects.prototype._addMethods(userScaleGroup);
        return userScaleGroup;
      }
    }
    module.exports = exports = Tooltip;
  }
});

// node_modules/threebox-plugin/src/objects/loaders/OBJLoader.js
var require_OBJLoader = __commonJS({
  "node_modules/threebox-plugin/src/objects/loaders/OBJLoader.js"(exports, module) {
    var THREE2 = require_three();
    (function() {
      const _object_pattern = /^[og]\s*(.+)?/;
      const _material_library_pattern = /^mtllib /;
      const _material_use_pattern = /^usemtl /;
      const _map_use_pattern = /^usemap /;
      const _vA = new THREE2.Vector3();
      const _vB = new THREE2.Vector3();
      const _vC = new THREE2.Vector3();
      const _ab = new THREE2.Vector3();
      const _cb = new THREE2.Vector3();
      function ParserState() {
        const state = {
          objects: [],
          object: {},
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          materials: {},
          materialLibraries: [],
          startObject: function(name, fromDeclaration) {
            if (this.object && this.object.fromDeclaration === false) {
              this.object.name = name;
              this.object.fromDeclaration = fromDeclaration !== false;
              return;
            }
            const previousMaterial = this.object && typeof this.object.currentMaterial === "function" ? this.object.currentMaterial() : void 0;
            if (this.object && typeof this.object._finalize === "function") {
              this.object._finalize(true);
            }
            this.object = {
              name: name || "",
              fromDeclaration: fromDeclaration !== false,
              geometry: {
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                hasUVIndices: false
              },
              materials: [],
              smooth: true,
              startMaterial: function(name2, libraries) {
                const previous = this._finalize(false);
                if (previous && (previous.inherited || previous.groupCount <= 0)) {
                  this.materials.splice(previous.index, 1);
                }
                const material = {
                  index: this.materials.length,
                  name: name2 || "",
                  mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : "",
                  smooth: previous !== void 0 ? previous.smooth : this.smooth,
                  groupStart: previous !== void 0 ? previous.groupEnd : 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: false,
                  clone: function(index) {
                    const cloned = {
                      index: typeof index === "number" ? index : this.index,
                      name: this.name,
                      mtllib: this.mtllib,
                      smooth: this.smooth,
                      groupStart: 0,
                      groupEnd: -1,
                      groupCount: -1,
                      inherited: false
                    };
                    cloned.clone = this.clone.bind(cloned);
                    return cloned;
                  }
                };
                this.materials.push(material);
                return material;
              },
              currentMaterial: function() {
                if (this.materials.length > 0) {
                  return this.materials[this.materials.length - 1];
                }
                return void 0;
              },
              _finalize: function(end) {
                const lastMultiMaterial = this.currentMaterial();
                if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                  lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                  lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                  lastMultiMaterial.inherited = false;
                }
                if (end && this.materials.length > 1) {
                  for (let mi = this.materials.length - 1; mi >= 0; mi--) {
                    if (this.materials[mi].groupCount <= 0) {
                      this.materials.splice(mi, 1);
                    }
                  }
                }
                if (end && this.materials.length === 0) {
                  this.materials.push({
                    name: "",
                    smooth: this.smooth
                  });
                }
                return lastMultiMaterial;
              }
            };
            if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === "function") {
              const declared = previousMaterial.clone(0);
              declared.inherited = true;
              this.object.materials.push(declared);
            }
            this.objects.push(this.object);
          },
          finalize: function() {
            if (this.object && typeof this.object._finalize === "function") {
              this.object._finalize(true);
            }
          },
          parseVertexIndex: function(value, len) {
            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 3) * 3;
          },
          parseNormalIndex: function(value, len) {
            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 3) * 3;
          },
          parseUVIndex: function(value, len) {
            const index = parseInt(value, 10);
            return (index >= 0 ? index - 1 : index + len / 2) * 2;
          },
          addVertex: function(a, b, c) {
            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
            dst.push(src[b + 0], src[b + 1], src[b + 2]);
            dst.push(src[c + 0], src[c + 1], src[c + 2]);
          },
          addVertexPoint: function(a) {
            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
          },
          addVertexLine: function(a) {
            const src = this.vertices;
            const dst = this.object.geometry.vertices;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
          },
          addNormal: function(a, b, c) {
            const src = this.normals;
            const dst = this.object.geometry.normals;
            dst.push(src[a + 0], src[a + 1], src[a + 2]);
            dst.push(src[b + 0], src[b + 1], src[b + 2]);
            dst.push(src[c + 0], src[c + 1], src[c + 2]);
          },
          addFaceNormal: function(a, b, c) {
            const src = this.vertices;
            const dst = this.object.geometry.normals;
            _vA.fromArray(src, a);
            _vB.fromArray(src, b);
            _vC.fromArray(src, c);
            _cb.subVectors(_vC, _vB);
            _ab.subVectors(_vA, _vB);
            _cb.cross(_ab);
            _cb.normalize();
            dst.push(_cb.x, _cb.y, _cb.z);
            dst.push(_cb.x, _cb.y, _cb.z);
            dst.push(_cb.x, _cb.y, _cb.z);
          },
          addColor: function(a, b, c) {
            const src = this.colors;
            const dst = this.object.geometry.colors;
            if (src[a] !== void 0)
              dst.push(src[a + 0], src[a + 1], src[a + 2]);
            if (src[b] !== void 0)
              dst.push(src[b + 0], src[b + 1], src[b + 2]);
            if (src[c] !== void 0)
              dst.push(src[c + 0], src[c + 1], src[c + 2]);
          },
          addUV: function(a, b, c) {
            const src = this.uvs;
            const dst = this.object.geometry.uvs;
            dst.push(src[a + 0], src[a + 1]);
            dst.push(src[b + 0], src[b + 1]);
            dst.push(src[c + 0], src[c + 1]);
          },
          addDefaultUV: function() {
            const dst = this.object.geometry.uvs;
            dst.push(0, 0);
            dst.push(0, 0);
            dst.push(0, 0);
          },
          addUVLine: function(a) {
            const src = this.uvs;
            const dst = this.object.geometry.uvs;
            dst.push(src[a + 0], src[a + 1]);
          },
          addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {
            const vLen = this.vertices.length;
            let ia = this.parseVertexIndex(a, vLen);
            let ib = this.parseVertexIndex(b, vLen);
            let ic = this.parseVertexIndex(c, vLen);
            this.addVertex(ia, ib, ic);
            this.addColor(ia, ib, ic);
            if (na !== void 0 && na !== "") {
              const nLen = this.normals.length;
              ia = this.parseNormalIndex(na, nLen);
              ib = this.parseNormalIndex(nb, nLen);
              ic = this.parseNormalIndex(nc, nLen);
              this.addNormal(ia, ib, ic);
            } else {
              this.addFaceNormal(ia, ib, ic);
            }
            if (ua !== void 0 && ua !== "") {
              const uvLen = this.uvs.length;
              ia = this.parseUVIndex(ua, uvLen);
              ib = this.parseUVIndex(ub, uvLen);
              ic = this.parseUVIndex(uc, uvLen);
              this.addUV(ia, ib, ic);
              this.object.geometry.hasUVIndices = true;
            } else {
              this.addDefaultUV();
            }
          },
          addPointGeometry: function(vertices) {
            this.object.geometry.type = "Points";
            const vLen = this.vertices.length;
            for (let vi = 0, l = vertices.length; vi < l; vi++) {
              const index = this.parseVertexIndex(vertices[vi], vLen);
              this.addVertexPoint(index);
              this.addColor(index);
            }
          },
          addLineGeometry: function(vertices, uvs) {
            this.object.geometry.type = "Line";
            const vLen = this.vertices.length;
            const uvLen = this.uvs.length;
            for (let vi = 0, l = vertices.length; vi < l; vi++) {
              this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
            }
            for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {
              this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
            }
          }
        };
        state.startObject("", false);
        return state;
      }
      class OBJLoader extends THREE2.Loader {
        constructor(manager) {
          super(manager);
          this.materials = null;
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const loader = new THREE2.FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(text));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        setMaterials(materials) {
          this.materials = materials;
          return this;
        }
        parse(text) {
          const state = new ParserState();
          if (text.indexOf("\r\n") !== -1) {
            text = text.replace(/\r\n/g, "\n");
          }
          if (text.indexOf("\\\n") !== -1) {
            text = text.replace(/\\\n/g, "");
          }
          const lines = text.split("\n");
          let line = "", lineFirstChar = "";
          let lineLength = 0;
          let result = [];
          const trimLeft = typeof "".trimLeft === "function";
          for (let i = 0, l = lines.length; i < l; i++) {
            line = lines[i];
            line = trimLeft ? line.trimLeft() : line.trim();
            lineLength = line.length;
            if (lineLength === 0)
              continue;
            lineFirstChar = line.charAt(0);
            if (lineFirstChar === "#")
              continue;
            if (lineFirstChar === "v") {
              const data = line.split(/\s+/);
              switch (data[0]) {
                case "v":
                  state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                  if (data.length >= 7) {
                    state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
                  } else {
                    state.colors.push(void 0, void 0, void 0);
                  }
                  break;
                case "vn":
                  state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                  break;
                case "vt":
                  state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                  break;
              }
            } else if (lineFirstChar === "f") {
              const lineData = line.substr(1).trim();
              const vertexData = lineData.split(/\s+/);
              const faceVertices = [];
              for (let j = 0, jl = vertexData.length; j < jl; j++) {
                const vertex = vertexData[j];
                if (vertex.length > 0) {
                  const vertexParts = vertex.split("/");
                  faceVertices.push(vertexParts);
                }
              }
              const v1 = faceVertices[0];
              for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {
                const v2 = faceVertices[j];
                const v3 = faceVertices[j + 1];
                state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
              }
            } else if (lineFirstChar === "l") {
              const lineParts = line.substring(1).trim().split(" ");
              let lineVertices = [];
              const lineUVs = [];
              if (line.indexOf("/") === -1) {
                lineVertices = lineParts;
              } else {
                for (let li = 0, llen = lineParts.length; li < llen; li++) {
                  const parts = lineParts[li].split("/");
                  if (parts[0] !== "")
                    lineVertices.push(parts[0]);
                  if (parts[1] !== "")
                    lineUVs.push(parts[1]);
                }
              }
              state.addLineGeometry(lineVertices, lineUVs);
            } else if (lineFirstChar === "p") {
              const lineData = line.substr(1).trim();
              const pointData = lineData.split(" ");
              state.addPointGeometry(pointData);
            } else if ((result = _object_pattern.exec(line)) !== null) {
              const name = (" " + result[0].substr(1).trim()).substr(1);
              state.startObject(name);
            } else if (_material_use_pattern.test(line)) {
              state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
            } else if (_material_library_pattern.test(line)) {
              state.materialLibraries.push(line.substring(7).trim());
            } else if (_map_use_pattern.test(line)) {
              console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
            } else if (lineFirstChar === "s") {
              result = line.split(" ");
              if (result.length > 1) {
                const value = result[1].trim().toLowerCase();
                state.object.smooth = value !== "0" && value !== "off";
              } else {
                state.object.smooth = true;
              }
              const material = state.object.currentMaterial();
              if (material)
                material.smooth = state.object.smooth;
            } else {
              if (line === "\0")
                continue;
              console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
            }
          }
          state.finalize();
          const container = new THREE2.Group();
          container.materialLibraries = [].concat(state.materialLibraries);
          const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);
          if (hasPrimitives === true) {
            for (let i = 0, l = state.objects.length; i < l; i++) {
              const object = state.objects[i];
              const geometry = object.geometry;
              const materials = object.materials;
              const isLine = geometry.type === "Line";
              const isPoints = geometry.type === "Points";
              let hasVertexColors = false;
              if (geometry.vertices.length === 0)
                continue;
              const buffergeometry = new THREE2.BufferGeometry();
              buffergeometry.setAttribute("position", new THREE2.Float32BufferAttribute(geometry.vertices, 3));
              if (geometry.normals.length > 0) {
                buffergeometry.setAttribute("normal", new THREE2.Float32BufferAttribute(geometry.normals, 3));
              }
              if (geometry.colors.length > 0) {
                hasVertexColors = true;
                buffergeometry.setAttribute("color", new THREE2.Float32BufferAttribute(geometry.colors, 3));
              }
              if (geometry.hasUVIndices === true) {
                buffergeometry.setAttribute("uv", new THREE2.Float32BufferAttribute(geometry.uvs, 2));
              }
              const createdMaterials = [];
              for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
                const sourceMaterial = materials[mi];
                const materialHash = sourceMaterial.name + "_" + sourceMaterial.smooth + "_" + hasVertexColors;
                let material = state.materials[materialHash];
                if (this.materials !== null) {
                  material = this.materials.create(sourceMaterial.name);
                  if (isLine && material && !(material instanceof THREE2.LineBasicMaterial)) {
                    const materialLine = new THREE2.LineBasicMaterial();
                    THREE2.Material.prototype.copy.call(materialLine, material);
                    materialLine.color.copy(material.color);
                    material = materialLine;
                  } else if (isPoints && material && !(material instanceof THREE2.PointsMaterial)) {
                    const materialPoints = new THREE2.PointsMaterial({
                      size: 10,
                      sizeAttenuation: false
                    });
                    THREE2.Material.prototype.copy.call(materialPoints, material);
                    materialPoints.color.copy(material.color);
                    materialPoints.map = material.map;
                    material = materialPoints;
                  }
                }
                if (material === void 0) {
                  if (isLine) {
                    material = new THREE2.LineBasicMaterial();
                  } else if (isPoints) {
                    material = new THREE2.PointsMaterial({
                      size: 1,
                      sizeAttenuation: false
                    });
                  } else {
                    material = new THREE2.MeshPhongMaterial();
                  }
                  material.name = sourceMaterial.name;
                  material.flatShading = sourceMaterial.smooth ? false : true;
                  material.vertexColors = hasVertexColors;
                  state.materials[materialHash] = material;
                }
                createdMaterials.push(material);
              }
              let mesh;
              if (createdMaterials.length > 1) {
                for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {
                  const sourceMaterial = materials[mi];
                  buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
                }
                if (isLine) {
                  mesh = new THREE2.LineSegments(buffergeometry, createdMaterials);
                } else if (isPoints) {
                  mesh = new THREE2.Points(buffergeometry, createdMaterials);
                } else {
                  mesh = new THREE2.Mesh(buffergeometry, createdMaterials);
                }
              } else {
                if (isLine) {
                  mesh = new THREE2.LineSegments(buffergeometry, createdMaterials[0]);
                } else if (isPoints) {
                  mesh = new THREE2.Points(buffergeometry, createdMaterials[0]);
                } else {
                  mesh = new THREE2.Mesh(buffergeometry, createdMaterials[0]);
                }
              }
              mesh.name = object.name;
              container.add(mesh);
            }
          } else {
            if (state.vertices.length > 0) {
              const material = new THREE2.PointsMaterial({
                size: 1,
                sizeAttenuation: false
              });
              const buffergeometry = new THREE2.BufferGeometry();
              buffergeometry.setAttribute("position", new THREE2.Float32BufferAttribute(state.vertices, 3));
              if (state.colors.length > 0 && state.colors[0] !== void 0) {
                buffergeometry.setAttribute("color", new THREE2.Float32BufferAttribute(state.colors, 3));
                material.vertexColors = true;
              }
              const points = new THREE2.Points(buffergeometry, material);
              container.add(points);
            }
          }
          return container;
        }
      }
      THREE2.OBJLoader = OBJLoader;
    })();
    module.exports = exports = THREE2.OBJLoader;
  }
});

// node_modules/threebox-plugin/src/objects/loaders/MTLLoader.js
var require_MTLLoader = __commonJS({
  "node_modules/threebox-plugin/src/objects/loaders/MTLLoader.js"(exports, module) {
    var THREE2 = require_three();
    (function() {
      class MTLLoader extends THREE2.Loader {
        constructor(manager) {
          super(manager);
        }
        /**
         * Loads and parses a MTL asset from a URL.
         *
         * @param {String} url - URL to the MTL file.
         * @param {Function} [onLoad] - Callback invoked with the loaded object.
         * @param {Function} [onProgress] - Callback for download progress.
         * @param {Function} [onError] - Callback for download errors.
         *
         * @see setPath setResourcePath
         *
         * @note In order for relative texture references to resolve correctly
         * you must call setResourcePath() explicitly prior to load.
         */
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = this.path === "" ? THREE2.LoaderUtils.extractUrlBase(url || "") : this.path;
          const loader = new THREE2.FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(text, path));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        setMaterialOptions(value) {
          this.materialOptions = value;
          return this;
        }
        /**
         * Parses a MTL file.
         *
         * @param {String} text - Content of MTL file
         * @return {MaterialCreator}
         *
         * @see setPath setResourcePath
         *
         * @note In order for relative texture references to resolve correctly
         * you must call setResourcePath() explicitly prior to parse.
         */
        parse(text, path) {
          const lines = text.split("\n");
          let info = {};
          const delimiter_pattern = /\s+/;
          const materialsInfo = {};
          for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            line = line.trim();
            if (line.length === 0 || line.charAt(0) === "#") {
              continue;
            }
            const pos = line.indexOf(" ");
            let key = pos >= 0 ? line.substring(0, pos) : line;
            key = key.toLowerCase();
            let value = pos >= 0 ? line.substring(pos + 1) : "";
            value = value.trim();
            if (key === "newmtl") {
              info = {
                name: value
              };
              materialsInfo[value] = info;
            } else {
              if (key === "ka" || key === "kd" || key === "ks" || key === "ke") {
                const ss = value.split(delimiter_pattern, 3);
                info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
              } else {
                info[key] = value;
              }
            }
          }
          const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);
          materialCreator.setCrossOrigin(this.crossOrigin);
          materialCreator.setManager(this.manager);
          materialCreator.setMaterials(materialsInfo);
          return materialCreator;
        }
      }
      class MaterialCreator {
        constructor(baseUrl = "", options2 = {}) {
          this.baseUrl = baseUrl;
          this.options = options2;
          this.materialsInfo = {};
          this.materials = {};
          this.materialsArray = [];
          this.nameLookup = {};
          this.crossOrigin = "anonymous";
          this.side = this.options.side !== void 0 ? this.options.side : THREE2.FrontSide;
          this.wrap = this.options.wrap !== void 0 ? this.options.wrap : THREE2.RepeatWrapping;
        }
        setCrossOrigin(value) {
          this.crossOrigin = value;
          return this;
        }
        setManager(value) {
          this.manager = value;
        }
        setMaterials(materialsInfo) {
          this.materialsInfo = this.convert(materialsInfo);
          this.materials = {};
          this.materialsArray = [];
          this.nameLookup = {};
        }
        convert(materialsInfo) {
          if (!this.options)
            return materialsInfo;
          const converted = {};
          for (const mn in materialsInfo) {
            const mat = materialsInfo[mn];
            const covmat = {};
            converted[mn] = covmat;
            for (const prop in mat) {
              let save = true;
              let value = mat[prop];
              const lprop = prop.toLowerCase();
              switch (lprop) {
                case "kd":
                case "ka":
                case "ks":
                  if (this.options && this.options.normalizeRGB) {
                    value = [value[0] / 255, value[1] / 255, value[2] / 255];
                  }
                  if (this.options && this.options.ignoreZeroRGBs) {
                    if (value[0] === 0 && value[1] === 0 && value[2] === 0) {
                      save = false;
                    }
                  }
                  break;
                default:
                  break;
              }
              if (save) {
                covmat[lprop] = value;
              }
            }
          }
          return converted;
        }
        preload() {
          for (const mn in this.materialsInfo) {
            this.create(mn);
          }
        }
        getIndex(materialName) {
          return this.nameLookup[materialName];
        }
        getAsArray() {
          let index = 0;
          for (const mn in this.materialsInfo) {
            this.materialsArray[index] = this.create(mn);
            this.nameLookup[mn] = index;
            index++;
          }
          return this.materialsArray;
        }
        create(materialName) {
          if (this.materials[materialName] === void 0) {
            this.createMaterial_(materialName);
          }
          return this.materials[materialName];
        }
        createMaterial_(materialName) {
          const scope = this;
          const mat = this.materialsInfo[materialName];
          const params = {
            name: materialName,
            side: this.side
          };
          function resolveURL(baseUrl, url) {
            if (typeof url !== "string" || url === "")
              return "";
            if (/^https?:\/\//i.test(url))
              return url;
            return baseUrl + url;
          }
          function setMapForType(mapType, value) {
            if (params[mapType])
              return;
            const texParams = scope.getTextureParams(value, params);
            const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
            map.repeat.copy(texParams.scale);
            map.offset.copy(texParams.offset);
            map.wrapS = scope.wrap;
            map.wrapT = scope.wrap;
            params[mapType] = map;
          }
          for (const prop in mat) {
            const value = mat[prop];
            let n;
            if (value === "")
              continue;
            switch (prop.toLowerCase()) {
              case "kd":
                params.color = new THREE2.Color().fromArray(value);
                break;
              case "ks":
                params.specular = new THREE2.Color().fromArray(value);
                break;
              case "ke":
                params.emissive = new THREE2.Color().fromArray(value);
                break;
              case "map_kd":
                setMapForType("map", value);
                break;
              case "map_ks":
                setMapForType("specularMap", value);
                break;
              case "map_ke":
                setMapForType("emissiveMap", value);
                break;
              case "norm":
                setMapForType("normalMap", value);
                break;
              case "map_bump":
              case "bump":
                setMapForType("bumpMap", value);
                break;
              case "map_d":
                setMapForType("alphaMap", value);
                params.transparent = true;
                break;
              case "ns":
                params.shininess = parseFloat(value);
                break;
              case "d":
                n = parseFloat(value);
                if (n < 1) {
                  params.opacity = n;
                  params.transparent = true;
                }
                break;
              case "tr":
                n = parseFloat(value);
                if (this.options && this.options.invertTrProperty)
                  n = 1 - n;
                if (n > 0) {
                  params.opacity = 1 - n;
                  params.transparent = true;
                }
                break;
              default:
                break;
            }
          }
          this.materials[materialName] = new THREE2.MeshPhongMaterial(params);
          return this.materials[materialName];
        }
        getTextureParams(value, matParams) {
          const texParams = {
            scale: new THREE2.Vector2(1, 1),
            offset: new THREE2.Vector2(0, 0)
          };
          const items = value.split(/\s+/);
          let pos;
          pos = items.indexOf("-bm");
          if (pos >= 0) {
            matParams.bumpScale = parseFloat(items[pos + 1]);
            items.splice(pos, 2);
          }
          pos = items.indexOf("-s");
          if (pos >= 0) {
            texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
            items.splice(pos, 4);
          }
          pos = items.indexOf("-o");
          if (pos >= 0) {
            texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
            items.splice(pos, 4);
          }
          texParams.url = items.join(" ").trim();
          return texParams;
        }
        loadTexture(url, mapping, onLoad, onProgress, onError) {
          const manager = this.manager !== void 0 ? this.manager : THREE2.DefaultLoadingManager;
          let loader = manager.getHandler(url);
          if (loader === null) {
            loader = new THREE2.TextureLoader(manager);
          }
          if (loader.setCrossOrigin)
            loader.setCrossOrigin(this.crossOrigin);
          const texture = loader.load(url, onLoad, onProgress, onError);
          if (mapping !== void 0)
            texture.mapping = mapping;
          return texture;
        }
      }
      THREE2.MTLLoader = MTLLoader;
    })();
    module.exports = exports = THREE2.MTLLoader;
  }
});

// node_modules/threebox-plugin/src/objects/fflate.min.js
var require_fflate_min = __commonJS({
  "node_modules/threebox-plugin/src/objects/fflate.min.js"(exports, module) {
    !function(f) {
      typeof module != "undefined" && typeof exports == "object" ? module.exports = f() : typeof define != "undefined" && define.amd ? define(["fflate", f]) : (typeof self != "undefined" ? self : this).fflate = f();
    }(function() {
      var _e = {};
      "use strict";
      _e.__esModule = true;
      var t = (typeof module != "undefined" && typeof exports == "object" ? function(_f) {
        "use strict";
        var e2;
        var r2 = ";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global";
        try {
          e2("require('worker_threads')").Worker;
        } catch (e3) {
        }
        exports.default = e2 ? function(t2, n2, o3, s2, a2) {
          var u2 = false, i2 = new e2(t2 + r2, { eval: true }).on("error", function(e3) {
            return a2(e3, null);
          }).on("message", function(e3) {
            return a2(null, e3);
          }).on("exit", function(e3) {
            e3 && !u2 && a2(Error("exited with code " + e3), null);
          });
          return i2.postMessage(o3, s2), i2.terminate = function() {
            return u2 = true, e2.prototype.terminate.call(i2);
          }, i2;
        } : function(e3, r3, t2, n2, o3) {
          setImmediate(function() {
            return o3(Error("async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)"), null);
          });
          var s2 = function() {
          };
          return { terminate: s2, postMessage: s2 };
        };
        return _f;
      } : function(_f) {
        "use strict";
        var e2 = eval;
        _f.default = function(r2, t2, n2, o3, s2) {
          var u2 = e2[t2] || (e2[t2] = URL.createObjectURL(new Blob([r2], { type: "text/javascript" }))), a2 = new Worker(u2);
          return a2.onerror = function(e3) {
            return s2(e3.error, null);
          }, a2.onmessage = function(e3) {
            return s2(null, e3.data);
          }, a2.postMessage(n2, o3), a2;
        };
        return _f;
      })({}), n = Uint8Array, r = Uint16Array, e = Uint32Array, i = new n([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o2 = new n([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new n([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), s = function(t2, n2) {
        for (var i2 = new r(31), o3 = 0; o3 < 31; ++o3)
          i2[o3] = n2 += 1 << t2[o3 - 1];
        var a2 = new e(i2[30]);
        for (o3 = 1; o3 < 30; ++o3)
          for (var s2 = i2[o3]; s2 < i2[o3 + 1]; ++s2)
            a2[s2] = s2 - i2[o3] << 5 | o3;
        return [i2, a2];
      }, f = s(i, 2), u = f[0], h = f[1];
      u[28] = 258, h[258] = 28;
      for (var c = s(o2, 0), l = c[0], p = c[1], v = new r(32768), d = 0; d < 32768; ++d) {
        var g = (43690 & d) >>> 1 | (21845 & d) << 1;
        v[d] = ((65280 & (g = (61680 & (g = (52428 & g) >>> 2 | (13107 & g) << 2)) >>> 4 | (3855 & g) << 4)) >>> 8 | (255 & g) << 8) >>> 1;
      }
      var w = function(t2, n2, e2) {
        for (var i2 = t2.length, o3 = 0, a2 = new r(n2); o3 < i2; ++o3)
          ++a2[t2[o3] - 1];
        var s2, f2 = new r(n2);
        for (o3 = 0; o3 < n2; ++o3)
          f2[o3] = f2[o3 - 1] + a2[o3 - 1] << 1;
        if (e2) {
          s2 = new r(1 << n2);
          var u2 = 15 - n2;
          for (o3 = 0; o3 < i2; ++o3)
            if (t2[o3])
              for (var h2 = o3 << 4 | t2[o3], c2 = n2 - t2[o3], l2 = f2[t2[o3] - 1]++ << c2, p2 = l2 | (1 << c2) - 1; l2 <= p2; ++l2)
                s2[v[l2] >>> u2] = h2;
        } else
          for (s2 = new r(i2), o3 = 0; o3 < i2; ++o3)
            t2[o3] && (s2[o3] = v[f2[t2[o3] - 1]++] >>> 15 - t2[o3]);
        return s2;
      }, y = new n(288);
      for (d = 0; d < 144; ++d)
        y[d] = 8;
      for (d = 144; d < 256; ++d)
        y[d] = 9;
      for (d = 256; d < 280; ++d)
        y[d] = 7;
      for (d = 280; d < 288; ++d)
        y[d] = 8;
      var m = new n(32);
      for (d = 0; d < 32; ++d)
        m[d] = 5;
      var b = w(y, 9, 0), x = w(y, 9, 1), z = w(m, 5, 0), k = w(m, 5, 1), M = function(t2) {
        for (var n2 = t2[0], r2 = 1; r2 < t2.length; ++r2)
          t2[r2] > n2 && (n2 = t2[r2]);
        return n2;
      }, A = function(t2, n2, r2) {
        var e2 = n2 / 8 | 0;
        return (t2[e2] | t2[e2 + 1] << 8) >> (7 & n2) & r2;
      }, S = function(t2, n2) {
        var r2 = n2 / 8 | 0;
        return (t2[r2] | t2[r2 + 1] << 8 | t2[r2 + 2] << 16) >> (7 & n2);
      }, D = function(t2) {
        return (t2 / 8 | 0) + (7 & t2 && 1);
      }, C = function(t2, i2, o3) {
        (null == i2 || i2 < 0) && (i2 = 0), (null == o3 || o3 > t2.length) && (o3 = t2.length);
        var a2 = new (t2 instanceof r ? r : t2 instanceof e ? e : n)(o3 - i2);
        return a2.set(t2.subarray(i2, o3)), a2;
      }, U = function(t2, r2, e2) {
        var s2 = t2.length;
        if (!s2 || e2 && !e2.l && s2 < 5)
          return r2 || new n(0);
        var f2 = !r2 || e2, h2 = !e2 || e2.i;
        e2 || (e2 = {}), r2 || (r2 = new n(3 * s2));
        var c2 = function(t3) {
          var e3 = r2.length;
          if (t3 > e3) {
            var i2 = new n(Math.max(2 * e3, t3));
            i2.set(r2), r2 = i2;
          }
        }, p2 = e2.f || 0, v2 = e2.p || 0, d2 = e2.b || 0, g2 = e2.l, y2 = e2.d, m2 = e2.m, b2 = e2.n, z2 = 8 * s2;
        do {
          if (!g2) {
            e2.f = p2 = A(t2, v2, 1);
            var U2 = A(t2, v2 + 1, 3);
            if (v2 += 3, !U2) {
              var O2 = t2[(H2 = D(v2) + 4) - 4] | t2[H2 - 3] << 8, T2 = H2 + O2;
              if (T2 > s2) {
                if (h2)
                  throw "unexpected EOF";
                break;
              }
              f2 && c2(d2 + O2), r2.set(t2.subarray(H2, T2), d2), e2.b = d2 += O2, e2.p = v2 = 8 * T2;
              continue;
            }
            if (1 == U2)
              g2 = x, y2 = k, m2 = 9, b2 = 5;
            else {
              if (2 != U2)
                throw "invalid block type";
              var Z2 = A(t2, v2, 31) + 257, I2 = A(t2, v2 + 10, 15) + 4, F2 = Z2 + A(t2, v2 + 5, 31) + 1;
              v2 += 14;
              for (var E2 = new n(F2), G2 = new n(19), P2 = 0; P2 < I2; ++P2)
                G2[a[P2]] = A(t2, v2 + 3 * P2, 7);
              v2 += 3 * I2;
              var j2 = M(G2), _2 = (1 << j2) - 1;
              if (!h2 && v2 + F2 * (j2 + 7) > z2)
                break;
              var q2 = w(G2, j2, 1);
              for (P2 = 0; P2 < F2; ) {
                var H2, Y2 = q2[A(t2, v2, _2)];
                if (v2 += 15 & Y2, (H2 = Y2 >>> 4) < 16)
                  E2[P2++] = H2;
                else {
                  var B2 = 0, J2 = 0;
                  for (16 == H2 ? (J2 = 3 + A(t2, v2, 3), v2 += 2, B2 = E2[P2 - 1]) : 17 == H2 ? (J2 = 3 + A(t2, v2, 7), v2 += 3) : 18 == H2 && (J2 = 11 + A(t2, v2, 127), v2 += 7); J2--; )
                    E2[P2++] = B2;
                }
              }
              var K2 = E2.subarray(0, Z2), L2 = E2.subarray(Z2);
              m2 = M(K2), b2 = M(L2), g2 = w(K2, m2, 1), y2 = w(L2, b2, 1);
            }
            if (v2 > z2)
              throw "unexpected EOF";
          }
          f2 && c2(d2 + 131072);
          for (var N2 = (1 << m2) - 1, Q2 = (1 << b2) - 1, R2 = m2 + b2 + 18; h2 || v2 + R2 < z2; ) {
            var V2 = (B2 = g2[S(t2, v2) & N2]) >>> 4;
            if ((v2 += 15 & B2) > z2)
              throw "unexpected EOF";
            if (!B2)
              throw "invalid length/literal";
            if (V2 < 256)
              r2[d2++] = V2;
            else {
              if (256 == V2) {
                g2 = null;
                break;
              }
              var W2 = V2 - 254;
              V2 > 264 && (W2 = A(t2, v2, (1 << (tt2 = i[P2 = V2 - 257])) - 1) + u[P2], v2 += tt2);
              var X2 = y2[S(t2, v2) & Q2], $2 = X2 >>> 4;
              if (!X2)
                throw "invalid distance";
              if (v2 += 15 & X2, L2 = l[$2], $2 > 3) {
                var tt2 = o2[$2];
                L2 += S(t2, v2) & (1 << tt2) - 1, v2 += tt2;
              }
              if (v2 > z2)
                throw "unexpected EOF";
              f2 && c2(d2 + 131072);
              for (var nt2 = d2 + W2; d2 < nt2; d2 += 4)
                r2[d2] = r2[d2 - L2], r2[d2 + 1] = r2[d2 + 1 - L2], r2[d2 + 2] = r2[d2 + 2 - L2], r2[d2 + 3] = r2[d2 + 3 - L2];
              d2 = nt2;
            }
          }
          e2.l = g2, e2.p = v2, e2.b = d2, g2 && (p2 = 1, e2.m = m2, e2.d = y2, e2.n = b2);
        } while (!p2);
        return d2 == r2.length ? r2 : C(r2, 0, d2);
      }, O = function(t2, n2, r2) {
        var e2 = n2 / 8 | 0;
        t2[e2] |= r2 <<= 7 & n2, t2[e2 + 1] |= r2 >>> 8;
      }, T = function(t2, n2, r2) {
        var e2 = n2 / 8 | 0;
        t2[e2] |= r2 <<= 7 & n2, t2[e2 + 1] |= r2 >>> 8, t2[e2 + 2] |= r2 >>> 16;
      }, Z = function(t2, e2) {
        for (var i2 = [], o3 = 0; o3 < t2.length; ++o3)
          t2[o3] && i2.push({ s: o3, f: t2[o3] });
        var a2 = i2.length, s2 = i2.slice();
        if (!a2)
          return [_, 0];
        if (1 == a2) {
          var f2 = new n(i2[0].s + 1);
          return f2[i2[0].s] = 1, [f2, 1];
        }
        i2.sort(function(t3, n2) {
          return t3.f - n2.f;
        }), i2.push({ s: -1, f: 25001 });
        var u2 = i2[0], h2 = i2[1], c2 = 0, l2 = 1, p2 = 2;
        for (i2[0] = { s: -1, f: u2.f + h2.f, l: u2, r: h2 }; l2 != a2 - 1; )
          u2 = i2[i2[c2].f < i2[p2].f ? c2++ : p2++], h2 = i2[c2 != l2 && i2[c2].f < i2[p2].f ? c2++ : p2++], i2[l2++] = { s: -1, f: u2.f + h2.f, l: u2, r: h2 };
        var v2 = s2[0].s;
        for (o3 = 1; o3 < a2; ++o3)
          s2[o3].s > v2 && (v2 = s2[o3].s);
        var d2 = new r(v2 + 1), g2 = I(i2[l2 - 1], d2, 0);
        if (g2 > e2) {
          o3 = 0;
          var w2 = 0, y2 = g2 - e2, m2 = 1 << y2;
          for (s2.sort(function(t3, n2) {
            return d2[n2.s] - d2[t3.s] || t3.f - n2.f;
          }); o3 < a2; ++o3) {
            var b2 = s2[o3].s;
            if (!(d2[b2] > e2))
              break;
            w2 += m2 - (1 << g2 - d2[b2]), d2[b2] = e2;
          }
          for (w2 >>>= y2; w2 > 0; ) {
            var x2 = s2[o3].s;
            d2[x2] < e2 ? w2 -= 1 << e2 - d2[x2]++ - 1 : ++o3;
          }
          for (; o3 >= 0 && w2; --o3) {
            var z2 = s2[o3].s;
            d2[z2] == e2 && (--d2[z2], ++w2);
          }
          g2 = e2;
        }
        return [new n(d2), g2];
      }, I = function(t2, n2, r2) {
        return -1 == t2.s ? Math.max(I(t2.l, n2, r2 + 1), I(t2.r, n2, r2 + 1)) : n2[t2.s] = r2;
      }, F = function(t2) {
        for (var n2 = t2.length; n2 && !t2[--n2]; )
          ;
        for (var e2 = new r(++n2), i2 = 0, o3 = t2[0], a2 = 1, s2 = function(t3) {
          e2[i2++] = t3;
        }, f2 = 1; f2 <= n2; ++f2)
          if (t2[f2] == o3 && f2 != n2)
            ++a2;
          else {
            if (!o3 && a2 > 2) {
              for (; a2 > 138; a2 -= 138)
                s2(32754);
              a2 > 2 && (s2(a2 > 10 ? a2 - 11 << 5 | 28690 : a2 - 3 << 5 | 12305), a2 = 0);
            } else if (a2 > 3) {
              for (s2(o3), --a2; a2 > 6; a2 -= 6)
                s2(8304);
              a2 > 2 && (s2(a2 - 3 << 5 | 8208), a2 = 0);
            }
            for (; a2--; )
              s2(o3);
            a2 = 1, o3 = t2[f2];
          }
        return [e2.subarray(0, i2), n2];
      }, E = function(t2, n2) {
        for (var r2 = 0, e2 = 0; e2 < n2.length; ++e2)
          r2 += t2[e2] * n2[e2];
        return r2;
      }, G = function(t2, n2, r2) {
        var e2 = r2.length, i2 = D(n2 + 2);
        t2[i2] = 255 & e2, t2[i2 + 1] = e2 >>> 8, t2[i2 + 2] = 255 ^ t2[i2], t2[i2 + 3] = 255 ^ t2[i2 + 1];
        for (var o3 = 0; o3 < e2; ++o3)
          t2[i2 + o3 + 4] = r2[o3];
        return 8 * (i2 + 4 + e2);
      }, P = function(t2, n2, e2, s2, f2, u2, h2, c2, l2, p2, v2) {
        O(n2, v2++, e2), ++f2[256];
        for (var d2 = Z(f2, 15), g2 = d2[0], x2 = d2[1], k2 = Z(u2, 15), M2 = k2[0], A2 = k2[1], S2 = F(g2), D2 = S2[0], C2 = S2[1], U2 = F(M2), I2 = U2[0], P2 = U2[1], j2 = new r(19), _2 = 0; _2 < D2.length; ++_2)
          j2[31 & D2[_2]]++;
        for (_2 = 0; _2 < I2.length; ++_2)
          j2[31 & I2[_2]]++;
        for (var q2 = Z(j2, 7), H2 = q2[0], Y2 = q2[1], B2 = 19; B2 > 4 && !H2[a[B2 - 1]]; --B2)
          ;
        var J2, K2, L2, N2, Q2 = p2 + 5 << 3, R2 = E(f2, y) + E(u2, m) + h2, V2 = E(f2, g2) + E(u2, M2) + h2 + 14 + 3 * B2 + E(j2, H2) + (2 * j2[16] + 3 * j2[17] + 7 * j2[18]);
        if (Q2 <= R2 && Q2 <= V2)
          return G(n2, v2, t2.subarray(l2, l2 + p2));
        if (O(n2, v2, 1 + (V2 < R2)), v2 += 2, V2 < R2) {
          J2 = w(g2, x2, 0), K2 = g2, L2 = w(M2, A2, 0), N2 = M2;
          var W2 = w(H2, Y2, 0);
          for (O(n2, v2, C2 - 257), O(n2, v2 + 5, P2 - 1), O(n2, v2 + 10, B2 - 4), v2 += 14, _2 = 0; _2 < B2; ++_2)
            O(n2, v2 + 3 * _2, H2[a[_2]]);
          v2 += 3 * B2;
          for (var X2 = [D2, I2], $2 = 0; $2 < 2; ++$2) {
            var tt2 = X2[$2];
            for (_2 = 0; _2 < tt2.length; ++_2)
              O(n2, v2, W2[nt2 = 31 & tt2[_2]]), v2 += H2[nt2], nt2 > 15 && (O(n2, v2, tt2[_2] >>> 5 & 127), v2 += tt2[_2] >>> 12);
          }
        } else
          J2 = b, K2 = y, L2 = z, N2 = m;
        for (_2 = 0; _2 < c2; ++_2)
          if (s2[_2] > 255) {
            var nt2;
            T(n2, v2, J2[257 + (nt2 = s2[_2] >>> 18 & 31)]), v2 += K2[nt2 + 257], nt2 > 7 && (O(n2, v2, s2[_2] >>> 23 & 31), v2 += i[nt2]);
            var rt2 = 31 & s2[_2];
            T(n2, v2, L2[rt2]), v2 += N2[rt2], rt2 > 3 && (T(n2, v2, s2[_2] >>> 5 & 8191), v2 += o2[rt2]);
          } else
            T(n2, v2, J2[s2[_2]]), v2 += K2[s2[_2]];
        return T(n2, v2, J2[256]), v2 + K2[256];
      }, j = new e([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), _ = new n(0), q = function(t2, a2, s2, f2, u2, c2) {
        var l2 = t2.length, v2 = new n(f2 + l2 + 5 * (1 + Math.ceil(l2 / 7e3)) + u2), d2 = v2.subarray(f2, v2.length - u2), g2 = 0;
        if (!a2 || l2 < 8)
          for (var w2 = 0; w2 <= l2; w2 += 65535) {
            var y2 = w2 + 65535;
            y2 < l2 ? g2 = G(d2, g2, t2.subarray(w2, y2)) : (d2[w2] = c2, g2 = G(d2, g2, t2.subarray(w2, l2)));
          }
        else {
          for (var m2 = j[a2 - 1], b2 = m2 >>> 13, x2 = 8191 & m2, z2 = (1 << s2) - 1, k2 = new r(32768), M2 = new r(z2 + 1), A2 = Math.ceil(s2 / 3), S2 = 2 * A2, U2 = function(n2) {
            return (t2[n2] ^ t2[n2 + 1] << A2 ^ t2[n2 + 2] << S2) & z2;
          }, O2 = new e(25e3), T2 = new r(288), Z2 = new r(32), I2 = 0, F2 = 0, E2 = (w2 = 0, 0), q2 = 0, H2 = 0; w2 < l2; ++w2) {
            var Y2 = U2(w2), B2 = 32767 & w2, J2 = M2[Y2];
            if (k2[B2] = J2, M2[Y2] = B2, q2 <= w2) {
              var K2 = l2 - w2;
              if ((I2 > 7e3 || E2 > 24576) && K2 > 423) {
                g2 = P(t2, d2, 0, O2, T2, Z2, F2, E2, H2, w2 - H2, g2), E2 = I2 = F2 = 0, H2 = w2;
                for (var L2 = 0; L2 < 286; ++L2)
                  T2[L2] = 0;
                for (L2 = 0; L2 < 30; ++L2)
                  Z2[L2] = 0;
              }
              var N2 = 2, Q2 = 0, R2 = x2, V2 = B2 - J2 & 32767;
              if (K2 > 2 && Y2 == U2(w2 - V2))
                for (var W2 = Math.min(b2, K2) - 1, X2 = Math.min(32767, w2), $2 = Math.min(258, K2); V2 <= X2 && --R2 && B2 != J2; ) {
                  if (t2[w2 + N2] == t2[w2 + N2 - V2]) {
                    for (var tt2 = 0; tt2 < $2 && t2[w2 + tt2] == t2[w2 + tt2 - V2]; ++tt2)
                      ;
                    if (tt2 > N2) {
                      if (N2 = tt2, Q2 = V2, tt2 > W2)
                        break;
                      var nt2 = Math.min(V2, tt2 - 2), rt2 = 0;
                      for (L2 = 0; L2 < nt2; ++L2) {
                        var et2 = w2 - V2 + L2 + 32768 & 32767, it2 = et2 - k2[et2] + 32768 & 32767;
                        it2 > rt2 && (rt2 = it2, J2 = et2);
                      }
                    }
                  }
                  V2 += (B2 = J2) - (J2 = k2[B2]) + 32768 & 32767;
                }
              if (Q2) {
                O2[E2++] = 268435456 | h[N2] << 18 | p[Q2];
                var ot2 = 31 & h[N2], at2 = 31 & p[Q2];
                F2 += i[ot2] + o2[at2], ++T2[257 + ot2], ++Z2[at2], q2 = w2 + N2, ++I2;
              } else
                O2[E2++] = t2[w2], ++T2[t2[w2]];
            }
          }
          g2 = P(t2, d2, c2, O2, T2, Z2, F2, E2, H2, w2 - H2, g2), !c2 && 7 & g2 && (g2 = G(d2, g2 + 1, _));
        }
        return C(v2, 0, f2 + D(g2) + u2);
      }, H = function() {
        for (var t2 = new e(256), n2 = 0; n2 < 256; ++n2) {
          for (var r2 = n2, i2 = 9; --i2; )
            r2 = (1 & r2 && 3988292384) ^ r2 >>> 1;
          t2[n2] = r2;
        }
        return t2;
      }(), Y = function() {
        var t2 = -1;
        return { p: function(n2) {
          for (var r2 = t2, e2 = 0; e2 < n2.length; ++e2)
            r2 = H[255 & r2 ^ n2[e2]] ^ r2 >>> 8;
          t2 = r2;
        }, d: function() {
          return ~t2;
        } };
      }, B = function() {
        var t2 = 1, n2 = 0;
        return { p: function(r2) {
          for (var e2 = t2, i2 = n2, o3 = r2.length, a2 = 0; a2 != o3; ) {
            for (var s2 = Math.min(a2 + 2655, o3); a2 < s2; ++a2)
              i2 += e2 += r2[a2];
            e2 = (65535 & e2) + 15 * (e2 >> 16), i2 = (65535 & i2) + 15 * (i2 >> 16);
          }
          t2 = e2, n2 = i2;
        }, d: function() {
          return ((t2 %= 65521) >>> 8 << 16 | (255 & (n2 %= 65521)) << 8 | n2 >>> 8) + 2 * ((255 & t2) << 23);
        } };
      }, J = function(t2, n2, r2, e2, i2) {
        return q(t2, null == n2.level ? 6 : n2.level, null == n2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t2.length)))) : 12 + n2.mem, r2, e2, !i2);
      }, K = function(t2, n2) {
        var r2 = {};
        for (var e2 in t2)
          r2[e2] = t2[e2];
        for (var e2 in n2)
          r2[e2] = n2[e2];
        return r2;
      }, L = function(t2, n2, r2) {
        for (var e2 = t2(), i2 = "" + t2, o3 = i2.slice(i2.indexOf("[") + 1, i2.lastIndexOf("]")).replace(/ /g, "").split(","), a2 = 0; a2 < e2.length; ++a2) {
          var s2 = e2[a2], f2 = o3[a2];
          if ("function" == typeof s2) {
            n2 += ";" + f2 + "=";
            var u2 = "" + s2;
            if (s2.prototype)
              if (-1 != u2.indexOf("[native code]")) {
                var h2 = u2.indexOf(" ", 8) + 1;
                n2 += u2.slice(h2, u2.indexOf("(", h2));
              } else
                for (var c2 in n2 += u2, s2.prototype)
                  n2 += ";" + f2 + ".prototype." + c2 + "=" + s2.prototype[c2];
            else
              n2 += u2;
          } else
            r2[f2] = s2;
        }
        return [n2, r2];
      }, N = [], Q = function(t2) {
        var i2 = [];
        for (var o3 in t2)
          (t2[o3] instanceof n || t2[o3] instanceof r || t2[o3] instanceof e) && i2.push((t2[o3] = new t2[o3].constructor(t2[o3])).buffer);
        return i2;
      }, R = function(n2, r2, e2, i2) {
        var o3;
        if (!N[e2]) {
          for (var a2 = "", s2 = {}, f2 = n2.length - 1, u2 = 0; u2 < f2; ++u2)
            a2 = (o3 = L(n2[u2], a2, s2))[0], s2 = o3[1];
          N[e2] = L(n2[f2], a2, s2);
        }
        var h2 = K({}, N[e2][1]);
        return t.default(N[e2][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + r2 + "}", e2, h2, Q(h2), i2);
      }, V = function() {
        return [n, r, e, i, o2, a, u, l, x, k, v, w, M, A, S, D, C, U, At, rt, et];
      }, W = function() {
        return [n, r, e, i, o2, a, h, p, b, y, z, m, v, j, _, w, O, T, Z, I, F, E, G, P, D, C, q, J, xt, rt];
      }, X = function() {
        return [ct, vt, ht, Y, H];
      }, $ = function() {
        return [lt, pt];
      }, tt = function() {
        return [dt, ht, B];
      }, nt = function() {
        return [gt];
      }, rt = function(t2) {
        return postMessage(t2, [t2.buffer]);
      }, et = function(t2) {
        return t2 && t2.size && new n(t2.size);
      }, it = function(t2, n2, r2, e2, i2, o3) {
        var a2 = R(r2, e2, i2, function(t3, n3) {
          a2.terminate(), o3(t3, n3);
        });
        return a2.postMessage([t2, n2], n2.consume ? [t2.buffer] : []), function() {
          a2.terminate();
        };
      }, ot = function(t2) {
        return t2.ondata = function(t3, n2) {
          return postMessage([t3, n2], [t3.buffer]);
        }, function(n2) {
          return t2.push(n2.data[0], n2.data[1]);
        };
      }, at = function(t2, n2, r2, e2, i2) {
        var o3, a2 = R(t2, e2, i2, function(t3, r3) {
          t3 ? (a2.terminate(), n2.ondata.call(n2, t3)) : (r3[1] && a2.terminate(), n2.ondata.call(n2, t3, r3[0], r3[1]));
        });
        a2.postMessage(r2), n2.push = function(t3, r3) {
          if (o3)
            throw "stream finished";
          if (!n2.ondata)
            throw "no stream handler";
          a2.postMessage([t3, o3 = r3], [t3.buffer]);
        }, n2.terminate = function() {
          a2.terminate();
        };
      }, st = function(t2, n2) {
        return t2[n2] | t2[n2 + 1] << 8;
      }, ft = function(t2, n2) {
        return (t2[n2] | t2[n2 + 1] << 8 | t2[n2 + 2] << 16) + 2 * (t2[n2 + 3] << 23);
      }, ut = function(t2, n2) {
        return ft(t2, n2) | 4294967296 * ft(t2, n2);
      }, ht = function(t2, n2, r2) {
        for (; r2; ++n2)
          t2[n2] = r2, r2 >>>= 8;
      }, ct = function(t2, n2) {
        var r2 = n2.filename;
        if (t2[0] = 31, t2[1] = 139, t2[2] = 8, t2[8] = n2.level < 2 ? 4 : 9 == n2.level ? 2 : 0, t2[9] = 3, 0 != n2.mtime && ht(t2, 4, Math.floor(new Date(n2.mtime || Date.now()) / 1e3)), r2) {
          t2[3] = 8;
          for (var e2 = 0; e2 <= r2.length; ++e2)
            t2[e2 + 10] = r2.charCodeAt(e2);
        }
      }, lt = function(t2) {
        if (31 != t2[0] || 139 != t2[1] || 8 != t2[2])
          throw "invalid gzip data";
        var n2 = t2[3], r2 = 10;
        4 & n2 && (r2 += t2[10] | 2 + (t2[11] << 8));
        for (var e2 = (n2 >> 3 & 1) + (n2 >> 4 & 1); e2 > 0; e2 -= !t2[r2++])
          ;
        return r2 + (2 & n2);
      }, pt = function(t2) {
        var n2 = t2.length;
        return (t2[n2 - 4] | t2[n2 - 3] << 8 | t2[n2 - 2] << 16) + 2 * (t2[n2 - 1] << 23);
      }, vt = function(t2) {
        return 10 + (t2.filename && t2.filename.length + 1 || 0);
      }, dt = function(t2, n2) {
        var r2 = n2.level, e2 = 0 == r2 ? 0 : r2 < 6 ? 1 : 9 == r2 ? 3 : 2;
        t2[0] = 120, t2[1] = e2 << 6 | (e2 ? 32 - 2 * e2 : 1);
      }, gt = function(t2) {
        if (8 != (15 & t2[0]) || t2[0] >>> 4 > 7 || (t2[0] << 8 | t2[1]) % 31)
          throw "invalid zlib data";
        if (32 & t2[1])
          throw "invalid zlib data: preset dictionaries not supported";
      };
      function wt(t2, n2) {
        return n2 || "function" != typeof t2 || (n2 = t2, t2 = {}), this.ondata = n2, t2;
      }
      var yt = function() {
        function t2(t3, n2) {
          n2 || "function" != typeof t3 || (n2 = t3, t3 = {}), this.ondata = n2, this.o = t3 || {};
        }
        return t2.prototype.p = function(t3, n2) {
          this.ondata(J(t3, this.o, 0, 0, !n2), n2);
        }, t2.prototype.push = function(t3, n2) {
          if (this.d)
            throw "stream finished";
          if (!this.ondata)
            throw "no stream handler";
          this.d = n2, this.p(t3, n2 || false);
        }, t2;
      }();
      _e.Deflate = yt;
      var mt = function() {
        return function(t2, n2) {
          at([W, function() {
            return [ot, yt];
          }], this, wt.call(this, t2, n2), function(t3) {
            var n3 = new yt(t3.data);
            onmessage = ot(n3);
          }, 6);
        };
      }();
      function bt(t2, n2, r2) {
        if (r2 || (r2 = n2, n2 = {}), "function" != typeof r2)
          throw "no callback";
        return it(t2, n2, [W], function(t3) {
          return rt(xt(t3.data[0], t3.data[1]));
        }, 0, r2);
      }
      function xt(t2, n2) {
        return J(t2, n2 || {}, 0, 0);
      }
      _e.AsyncDeflate = mt, _e.deflate = bt, _e.deflateSync = xt;
      var zt = function() {
        function t2(t3) {
          this.s = {}, this.p = new n(0), this.ondata = t3;
        }
        return t2.prototype.e = function(t3) {
          if (this.d)
            throw "stream finished";
          if (!this.ondata)
            throw "no stream handler";
          var r2 = this.p.length, e2 = new n(r2 + t3.length);
          e2.set(this.p), e2.set(t3, r2), this.p = e2;
        }, t2.prototype.c = function(t3) {
          this.d = this.s.i = t3 || false;
          var n2 = this.s.b, r2 = U(this.p, this.o, this.s);
          this.ondata(C(r2, n2, this.s.b), this.d), this.o = C(r2, this.s.b - 32768), this.s.b = this.o.length, this.p = C(this.p, this.s.p / 8 | 0), this.s.p &= 7;
        }, t2.prototype.push = function(t3, n2) {
          this.e(t3), this.c(n2);
        }, t2;
      }();
      _e.Inflate = zt;
      var kt = function() {
        return function(t2) {
          this.ondata = t2, at([V, function() {
            return [ot, zt];
          }], this, 0, function() {
            var t3 = new zt();
            onmessage = ot(t3);
          }, 7);
        };
      }();
      function Mt(t2, n2, r2) {
        if (r2 || (r2 = n2, n2 = {}), "function" != typeof r2)
          throw "no callback";
        return it(t2, n2, [V], function(t3) {
          return rt(At(t3.data[0], et(t3.data[1])));
        }, 1, r2);
      }
      function At(t2, n2) {
        return U(t2, n2);
      }
      _e.AsyncInflate = kt, _e.inflate = Mt, _e.inflateSync = At;
      var St = function() {
        function t2(t3, n2) {
          this.c = Y(), this.l = 0, this.v = 1, yt.call(this, t3, n2);
        }
        return t2.prototype.push = function(t3, n2) {
          yt.prototype.push.call(this, t3, n2);
        }, t2.prototype.p = function(t3, n2) {
          this.c.p(t3), this.l += t3.length;
          var r2 = J(t3, this.o, this.v && vt(this.o), n2 && 8, !n2);
          this.v && (ct(r2, this.o), this.v = 0), n2 && (ht(r2, r2.length - 8, this.c.d()), ht(r2, r2.length - 4, this.l)), this.ondata(r2, n2);
        }, t2;
      }();
      _e.Gzip = St, _e.Compress = St;
      var Dt = function() {
        return function(t2, n2) {
          at([W, X, function() {
            return [ot, yt, St];
          }], this, wt.call(this, t2, n2), function(t3) {
            var n3 = new St(t3.data);
            onmessage = ot(n3);
          }, 8);
        };
      }();
      function Ct(t2, n2, r2) {
        if (r2 || (r2 = n2, n2 = {}), "function" != typeof r2)
          throw "no callback";
        return it(t2, n2, [W, X, function() {
          return [Ut];
        }], function(t3) {
          return rt(Ut(t3.data[0], t3.data[1]));
        }, 2, r2);
      }
      function Ut(t2, n2) {
        n2 || (n2 = {});
        var r2 = Y(), e2 = t2.length;
        r2.p(t2);
        var i2 = J(t2, n2, vt(n2), 8), o3 = i2.length;
        return ct(i2, n2), ht(i2, o3 - 8, r2.d()), ht(i2, o3 - 4, e2), i2;
      }
      _e.AsyncGzip = Dt, _e.AsyncCompress = Dt, _e.gzip = Ct, _e.compress = Ct, _e.gzipSync = Ut, _e.compressSync = Ut;
      var Ot = function() {
        function t2(t3) {
          this.v = 1, zt.call(this, t3);
        }
        return t2.prototype.push = function(t3, n2) {
          if (zt.prototype.e.call(this, t3), this.v) {
            var r2 = this.p.length > 3 ? lt(this.p) : 4;
            if (r2 >= this.p.length && !n2)
              return;
            this.p = this.p.subarray(r2), this.v = 0;
          }
          if (n2) {
            if (this.p.length < 8)
              throw "invalid gzip stream";
            this.p = this.p.subarray(0, -8);
          }
          zt.prototype.c.call(this, n2);
        }, t2;
      }();
      _e.Gunzip = Ot;
      var Tt = function() {
        return function(t2) {
          this.ondata = t2, at([V, $, function() {
            return [ot, zt, Ot];
          }], this, 0, function() {
            var t3 = new Ot();
            onmessage = ot(t3);
          }, 9);
        };
      }();
      function Zt(t2, n2, r2) {
        if (r2 || (r2 = n2, n2 = {}), "function" != typeof r2)
          throw "no callback";
        return it(t2, n2, [V, $, function() {
          return [It];
        }], function(t3) {
          return rt(It(t3.data[0]));
        }, 3, r2);
      }
      function It(t2, r2) {
        return U(t2.subarray(lt(t2), -8), r2 || new n(pt(t2)));
      }
      _e.AsyncGunzip = Tt, _e.gunzip = Zt, _e.gunzipSync = It;
      var Ft = function() {
        function t2(t3, n2) {
          this.c = B(), this.v = 1, yt.call(this, t3, n2);
        }
        return t2.prototype.push = function(t3, n2) {
          yt.prototype.push.call(this, t3, n2);
        }, t2.prototype.p = function(t3, n2) {
          this.c.p(t3);
          var r2 = J(t3, this.o, this.v && 2, n2 && 4, !n2);
          this.v && (dt(r2, this.o), this.v = 0), n2 && ht(r2, r2.length - 4, this.c.d()), this.ondata(r2, n2);
        }, t2;
      }();
      _e.Zlib = Ft;
      var Et = function() {
        return function(t2, n2) {
          at([W, tt, function() {
            return [ot, yt, Ft];
          }], this, wt.call(this, t2, n2), function(t3) {
            var n3 = new Ft(t3.data);
            onmessage = ot(n3);
          }, 10);
        };
      }();
      function Gt(t2, n2, r2) {
        if (r2 || (r2 = n2, n2 = {}), "function" != typeof r2)
          throw "no callback";
        return it(t2, n2, [W, tt, function() {
          return [Pt];
        }], function(t3) {
          return rt(Pt(t3.data[0], t3.data[1]));
        }, 4, r2);
      }
      function Pt(t2, n2) {
        n2 || (n2 = {});
        var r2 = B();
        r2.p(t2);
        var e2 = J(t2, n2, 2, 4);
        return dt(e2, n2), ht(e2, e2.length - 4, r2.d()), e2;
      }
      _e.AsyncZlib = Et, _e.zlib = Gt, _e.zlibSync = Pt;
      var jt = function() {
        function t2(t3) {
          this.v = 1, zt.call(this, t3);
        }
        return t2.prototype.push = function(t3, n2) {
          if (zt.prototype.e.call(this, t3), this.v) {
            if (this.p.length < 2 && !n2)
              return;
            this.p = this.p.subarray(2), this.v = 0;
          }
          if (n2) {
            if (this.p.length < 4)
              throw "invalid zlib stream";
            this.p = this.p.subarray(0, -4);
          }
          zt.prototype.c.call(this, n2);
        }, t2;
      }();
      _e.Unzlib = jt;
      var _t = function() {
        return function(t2) {
          this.ondata = t2, at([V, nt, function() {
            return [ot, zt, jt];
          }], this, 0, function() {
            var t3 = new jt();
            onmessage = ot(t3);
          }, 11);
        };
      }();
      function qt(t2, n2, r2) {
        if (r2 || (r2 = n2, n2 = {}), "function" != typeof r2)
          throw "no callback";
        return it(t2, n2, [V, nt, function() {
          return [Ht];
        }], function(t3) {
          return rt(Ht(t3.data[0], et(t3.data[1])));
        }, 5, r2);
      }
      function Ht(t2, n2) {
        return U((gt(t2), t2.subarray(2, -4)), n2);
      }
      _e.AsyncUnzlib = _t, _e.unzlib = qt, _e.unzlibSync = Ht;
      var Yt = function() {
        function t2(t3) {
          this.G = Ot, this.I = zt, this.Z = jt, this.ondata = t3;
        }
        return t2.prototype.push = function(t3, r2) {
          if (!this.ondata)
            throw "no stream handler";
          if (this.s)
            this.s.push(t3, r2);
          else {
            if (this.p && this.p.length) {
              var e2 = new n(this.p.length + t3.length);
              e2.set(this.p), e2.set(t3, this.p.length);
            } else
              this.p = t3;
            if (this.p.length > 2) {
              var i2 = this, o3 = function() {
                i2.ondata.apply(i2, arguments);
              };
              this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(o3) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(o3) : new this.Z(o3), this.s.push(this.p, r2), this.p = null;
            }
          }
        }, t2;
      }();
      _e.Decompress = Yt;
      var Bt = function() {
        function t2(t3) {
          this.G = Tt, this.I = kt, this.Z = _t, this.ondata = t3;
        }
        return t2.prototype.push = function(t3, n2) {
          Yt.prototype.push.call(this, t3, n2);
        }, t2;
      }();
      function Jt(t2, n2, r2) {
        if (r2 || (r2 = n2, n2 = {}), "function" != typeof r2)
          throw "no callback";
        return 31 == t2[0] && 139 == t2[1] && 8 == t2[2] ? Zt(t2, n2, r2) : 8 != (15 & t2[0]) || t2[0] >> 4 > 7 || (t2[0] << 8 | t2[1]) % 31 ? Mt(t2, n2, r2) : qt(t2, n2, r2);
      }
      function Kt(t2, n2) {
        return 31 == t2[0] && 139 == t2[1] && 8 == t2[2] ? It(t2, n2) : 8 != (15 & t2[0]) || t2[0] >> 4 > 7 || (t2[0] << 8 | t2[1]) % 31 ? At(t2, n2) : Ht(t2, n2);
      }
      _e.AsyncDecompress = Bt, _e.decompress = Jt, _e.decompressSync = Kt;
      var Lt = function(t2, r2, e2, i2) {
        for (var o3 in t2) {
          var a2 = t2[o3], s2 = r2 + o3;
          a2 instanceof n ? e2[s2] = [a2, i2] : Array.isArray(a2) ? e2[s2] = [a2[0], K(i2, a2[1])] : Lt(a2, s2 + "/", e2, i2);
        }
      }, Nt = "undefined" != typeof TextEncoder && new TextEncoder(), Qt = "undefined" != typeof TextDecoder && new TextDecoder(), Rt = 0;
      try {
        Qt.decode(_, { stream: true }), Rt = 1;
      } catch (t2) {
      }
      var Vt = function(t2) {
        for (var n2 = "", r2 = 0; ; ) {
          var e2 = t2[r2++], i2 = (e2 > 127) + (e2 > 223) + (e2 > 239);
          if (r2 + i2 > t2.length)
            return [n2, C(t2, r2 - 1)];
          i2 ? 3 == i2 ? (e2 = ((15 & e2) << 18 | (63 & t2[r2++]) << 12 | (63 & t2[r2++]) << 6 | 63 & t2[r2++]) - 65536, n2 += String.fromCharCode(55296 | e2 >> 10, 56320 | 1023 & e2)) : n2 += String.fromCharCode(1 & i2 ? (31 & e2) << 6 | 63 & t2[r2++] : (15 & e2) << 12 | (63 & t2[r2++]) << 6 | 63 & t2[r2++]) : n2 += String.fromCharCode(e2);
        }
      }, Wt = function() {
        function t2(t3) {
          this.ondata = t3, Rt ? this.t = new TextDecoder() : this.p = _;
        }
        return t2.prototype.push = function(t3, r2) {
          if (!this.ondata)
            throw "no callback";
          if (r2 || (r2 = false), this.t)
            return this.ondata(this.t.decode(t3, { stream: !r2 }), r2);
          var e2 = new n(this.p.length + t3.length);
          e2.set(this.p), e2.set(t3, this.p.length);
          var i2 = Vt(e2), o3 = i2[0], a2 = i2[1];
          if (r2 && a2.length)
            throw "invalid utf-8 data";
          this.p = a2, this.ondata(o3, r2);
        }, t2;
      }();
      _e.DecodeUTF8 = Wt;
      var Xt = function() {
        function t2(t3) {
          this.ondata = t3;
        }
        return t2.prototype.push = function(t3, n2) {
          if (!this.ondata)
            throw "no callback";
          this.ondata($t(t3), n2 || false);
        }, t2;
      }();
      function $t(t2, r2) {
        if (r2) {
          for (var e2 = new n(t2.length), i2 = 0; i2 < t2.length; ++i2)
            e2[i2] = t2.charCodeAt(i2);
          return e2;
        }
        if (Nt)
          return Nt.encode(t2);
        var o3 = t2.length, a2 = new n(t2.length + (t2.length >> 1)), s2 = 0, f2 = function(t3) {
          a2[s2++] = t3;
        };
        for (i2 = 0; i2 < o3; ++i2) {
          if (s2 + 5 > a2.length) {
            var u2 = new n(s2 + 8 + (o3 - i2 << 1));
            u2.set(a2), a2 = u2;
          }
          var h2 = t2.charCodeAt(i2);
          h2 < 128 || r2 ? f2(h2) : h2 < 2048 ? (f2(192 | h2 >>> 6), f2(128 | 63 & h2)) : h2 > 55295 && h2 < 57344 ? (f2(240 | (h2 = 65536 + (1047552 & h2) | 1023 & t2.charCodeAt(++i2)) >>> 18), f2(128 | h2 >>> 12 & 63), f2(128 | h2 >>> 6 & 63), f2(128 | 63 & h2)) : (f2(224 | h2 >>> 12), f2(128 | h2 >>> 6 & 63), f2(128 | 63 & h2));
        }
        return C(a2, 0, s2);
      }
      function tn(t2, n2) {
        if (n2) {
          for (var r2 = "", e2 = 0; e2 < t2.length; e2 += 16384)
            r2 += String.fromCharCode.apply(null, t2.subarray(e2, e2 + 16384));
          return r2;
        }
        if (Qt)
          return Qt.decode(t2);
        var i2 = Vt(t2);
        if (i2[1].length)
          throw "invalid utf-8 data";
        return i2[0];
      }
      _e.EncodeUTF8 = Xt, _e.strToU8 = $t, _e.strFromU8 = tn;
      var nn = function(t2) {
        return 1 == t2 ? 3 : t2 < 6 ? 2 : 9 == t2 ? 1 : 0;
      }, rn = function(t2, n2) {
        return n2 + 30 + st(t2, n2 + 26) + st(t2, n2 + 28);
      }, en = function(t2, n2, r2) {
        var e2 = st(t2, n2 + 28), i2 = tn(t2.subarray(n2 + 46, n2 + 46 + e2), !(2048 & st(t2, n2 + 8))), o3 = n2 + 46 + e2, a2 = ft(t2, n2 + 20), s2 = r2 && 4294967295 == a2 ? on(t2, o3) : [a2, ft(t2, n2 + 24), ft(t2, n2 + 42)], f2 = s2[0], u2 = s2[1], h2 = s2[2];
        return [st(t2, n2 + 10), f2, u2, i2, o3 + st(t2, n2 + 30) + st(t2, n2 + 32), h2];
      }, on = function(t2, n2) {
        for (; 1 != st(t2, n2); n2 += 4 + st(t2, n2 + 2))
          ;
        return [ut(t2, n2 + 12), ut(t2, n2 + 4), ut(t2, n2 + 20)];
      }, an = function(t2) {
        var n2 = 0;
        if (t2)
          for (var r2 in t2) {
            var e2 = t2[r2].length;
            if (e2 > 65535)
              throw "extra field too long";
            n2 += e2 + 4;
          }
        return n2;
      }, sn = function(t2, n2, r2, e2, i2, o3, a2, s2) {
        var f2 = e2.length, u2 = r2.extra, h2 = s2 && s2.length, c2 = an(u2);
        ht(t2, n2, null != a2 ? 33639248 : 67324752), n2 += 4, null != a2 && (t2[n2++] = 20, t2[n2++] = r2.os), t2[n2] = 20, n2 += 2, t2[n2++] = r2.flag << 1 | (null == o3 && 8), t2[n2++] = i2 && 8, t2[n2++] = 255 & r2.compression, t2[n2++] = r2.compression >> 8;
        var l2 = new Date(null == r2.mtime ? Date.now() : r2.mtime), p2 = l2.getFullYear() - 1980;
        if (p2 < 0 || p2 > 119)
          throw "date not in range 1980-2099";
        if (ht(t2, n2, 2 * (p2 << 24) | l2.getMonth() + 1 << 21 | l2.getDate() << 16 | l2.getHours() << 11 | l2.getMinutes() << 5 | l2.getSeconds() >>> 1), n2 += 4, null != o3 && (ht(t2, n2, r2.crc), ht(t2, n2 + 4, o3), ht(t2, n2 + 8, r2.size)), ht(t2, n2 + 12, f2), ht(t2, n2 + 14, c2), n2 += 16, null != a2 && (ht(t2, n2, h2), ht(t2, n2 + 6, r2.attrs), ht(t2, n2 + 10, a2), n2 += 14), t2.set(e2, n2), n2 += f2, c2)
          for (var v2 in u2) {
            var d2 = u2[v2], g2 = d2.length;
            ht(t2, n2, +v2), ht(t2, n2 + 2, g2), t2.set(d2, n2 + 4), n2 += 4 + g2;
          }
        return h2 && (t2.set(s2, n2), n2 += h2), n2;
      }, fn = function(t2, n2, r2, e2, i2) {
        ht(t2, n2, 101010256), ht(t2, n2 + 8, r2), ht(t2, n2 + 10, r2), ht(t2, n2 + 12, e2), ht(t2, n2 + 16, i2);
      }, un = function() {
        function t2(t3) {
          this.filename = t3, this.c = Y(), this.size = 0, this.compression = 0;
        }
        return t2.prototype.process = function(t3, n2) {
          this.ondata(null, t3, n2);
        }, t2.prototype.push = function(t3, n2) {
          if (!this.ondata)
            throw "no callback - add to ZIP archive before pushing";
          this.c.p(t3), this.size += t3.length, n2 && (this.crc = this.c.d()), this.process(t3, n2 || false);
        }, t2;
      }();
      _e.ZipPassThrough = un;
      var hn = function() {
        function t2(t3, n2) {
          var r2 = this;
          n2 || (n2 = {}), un.call(this, t3), this.d = new yt(n2, function(t4, n3) {
            r2.ondata(null, t4, n3);
          }), this.compression = 8, this.flag = nn(n2.level);
        }
        return t2.prototype.process = function(t3, n2) {
          try {
            this.d.push(t3, n2);
          } catch (t4) {
            this.ondata(t4, null, n2);
          }
        }, t2.prototype.push = function(t3, n2) {
          un.prototype.push.call(this, t3, n2);
        }, t2;
      }();
      _e.ZipDeflate = hn;
      var cn = function() {
        function t2(t3, n2) {
          var r2 = this;
          n2 || (n2 = {}), un.call(this, t3), this.d = new mt(n2, function(t4, n3, e2) {
            r2.ondata(t4, n3, e2);
          }), this.compression = 8, this.flag = nn(n2.level), this.terminate = this.d.terminate;
        }
        return t2.prototype.process = function(t3, n2) {
          this.d.push(t3, n2);
        }, t2.prototype.push = function(t3, n2) {
          un.prototype.push.call(this, t3, n2);
        }, t2;
      }();
      _e.AsyncZipDeflate = cn;
      var ln = function() {
        function t2(t3) {
          this.ondata = t3, this.u = [], this.d = 1;
        }
        return t2.prototype.add = function(t3) {
          var r2 = this;
          if (2 & this.d)
            throw "stream finished";
          var e2 = $t(t3.filename), i2 = e2.length, o3 = t3.comment, a2 = o3 && $t(o3), s2 = i2 != t3.filename.length || a2 && o3.length != a2.length, f2 = i2 + an(t3.extra) + 30;
          if (i2 > 65535)
            throw "filename too long";
          var u2 = new n(f2);
          sn(u2, 0, t3, e2, s2);
          var h2 = [u2], c2 = function() {
            for (var t4 = 0, n2 = h2; t4 < n2.length; t4++)
              r2.ondata(null, n2[t4], false);
            h2 = [];
          }, l2 = this.d;
          this.d = 0;
          var p2 = this.u.length, v2 = K(t3, { f: e2, u: s2, o: a2, t: function() {
            t3.terminate && t3.terminate();
          }, r: function() {
            if (c2(), l2) {
              var t4 = r2.u[p2 + 1];
              t4 ? t4.r() : r2.d = 1;
            }
            l2 = 1;
          } }), d2 = 0;
          t3.ondata = function(e3, i3, o4) {
            if (e3)
              r2.ondata(e3, i3, o4), r2.terminate();
            else if (d2 += i3.length, h2.push(i3), o4) {
              var a3 = new n(16);
              ht(a3, 0, 134695760), ht(a3, 4, t3.crc), ht(a3, 8, d2), ht(a3, 12, t3.size), h2.push(a3), v2.c = d2, v2.b = f2 + d2 + 16, v2.crc = t3.crc, v2.size = t3.size, l2 && v2.r(), l2 = 1;
            } else
              l2 && c2();
          }, this.u.push(v2);
        }, t2.prototype.end = function() {
          var t3 = this;
          if (2 & this.d) {
            if (1 & this.d)
              throw "stream finishing";
            throw "stream finished";
          }
          this.d ? this.e() : this.u.push({ r: function() {
            1 & t3.d && (t3.u.splice(-1, 1), t3.e());
          }, t: function() {
          } }), this.d = 3;
        }, t2.prototype.e = function() {
          for (var t3 = 0, r2 = 0, e2 = 0, i2 = 0, o3 = this.u; i2 < o3.length; i2++)
            e2 += 46 + (u2 = o3[i2]).f.length + an(u2.extra) + (u2.o ? u2.o.length : 0);
          for (var a2 = new n(e2 + 22), s2 = 0, f2 = this.u; s2 < f2.length; s2++) {
            var u2;
            sn(a2, t3, u2 = f2[s2], u2.f, u2.u, u2.c, r2, u2.o), t3 += 46 + u2.f.length + an(u2.extra) + (u2.o ? u2.o.length : 0), r2 += u2.b;
          }
          fn(a2, t3, this.u.length, e2, r2), this.ondata(null, a2, true), this.d = 2;
        }, t2.prototype.terminate = function() {
          for (var t3 = 0, n2 = this.u; t3 < n2.length; t3++)
            n2[t3].t();
          this.d = 2;
        }, t2;
      }();
      function pn(t2, r2, e2) {
        if (e2 || (e2 = r2, r2 = {}), "function" != typeof e2)
          throw "no callback";
        var i2 = {};
        Lt(t2, "", i2, r2);
        var o3 = Object.keys(i2), a2 = o3.length, s2 = 0, f2 = 0, u2 = a2, h2 = Array(a2), c2 = [], l2 = function() {
          for (var t3 = 0; t3 < c2.length; ++t3)
            c2[t3]();
        }, p2 = function() {
          var t3 = new n(f2 + 22), r3 = s2, i3 = f2 - s2;
          f2 = 0;
          for (var o4 = 0; o4 < u2; ++o4) {
            var a3 = h2[o4];
            try {
              var c3 = a3.c.length;
              sn(t3, f2, a3, a3.f, a3.u, c3);
              var l3 = 30 + a3.f.length + an(a3.extra), p3 = f2 + l3;
              t3.set(a3.c, p3), sn(t3, s2, a3, a3.f, a3.u, c3, f2, a3.m), s2 += 16 + l3 + (a3.m ? a3.m.length : 0), f2 = p3 + c3;
            } catch (t4) {
              return e2(t4, null);
            }
          }
          fn(t3, s2, h2.length, i3, r3), e2(null, t3);
        };
        a2 || p2();
        for (var v2 = function(t3) {
          var n2 = o3[t3], r3 = i2[n2], u3 = r3[0], v3 = r3[1], d3 = Y(), g2 = u3.length;
          d3.p(u3);
          var w2 = $t(n2), y2 = w2.length, m2 = v3.comment, b2 = m2 && $t(m2), x2 = b2 && b2.length, z2 = an(v3.extra), k2 = 0 == v3.level ? 0 : 8, M2 = function(r4, i3) {
            if (r4)
              l2(), e2(r4, null);
            else {
              var o4 = i3.length;
              h2[t3] = K(v3, { size: g2, crc: d3.d(), c: i3, f: w2, m: b2, u: y2 != n2.length || b2 && m2.length != x2, compression: k2 }), s2 += 30 + y2 + z2 + o4, f2 += 76 + 2 * (y2 + z2) + (x2 || 0) + o4, --a2 || p2();
            }
          };
          if (y2 > 65535 && M2("filename too long", null), k2)
            if (g2 < 16e4)
              try {
                M2(null, xt(u3, v3));
              } catch (t4) {
                M2(t4, null);
              }
            else
              c2.push(bt(u3, v3, M2));
          else
            M2(null, u3);
        }, d2 = 0; d2 < u2; ++d2)
          v2(d2);
        return l2;
      }
      function vn(t2, r2) {
        r2 || (r2 = {});
        var e2 = {}, i2 = [];
        Lt(t2, "", e2, r2);
        var o3 = 0, a2 = 0;
        for (var s2 in e2) {
          var f2 = e2[s2], u2 = f2[0], h2 = f2[1], c2 = 0 == h2.level ? 0 : 8, l2 = (M2 = $t(s2)).length, p2 = h2.comment, v2 = p2 && $t(p2), d2 = v2 && v2.length, g2 = an(h2.extra);
          if (l2 > 65535)
            throw "filename too long";
          var w2 = c2 ? xt(u2, h2) : u2, y2 = w2.length, m2 = Y();
          m2.p(u2), i2.push(K(h2, { size: u2.length, crc: m2.d(), c: w2, f: M2, m: v2, u: l2 != s2.length || v2 && p2.length != d2, o: o3, compression: c2 })), o3 += 30 + l2 + g2 + y2, a2 += 76 + 2 * (l2 + g2) + (d2 || 0) + y2;
        }
        for (var b2 = new n(a2 + 22), x2 = o3, z2 = a2 - o3, k2 = 0; k2 < i2.length; ++k2) {
          var M2;
          sn(b2, (M2 = i2[k2]).o, M2, M2.f, M2.u, M2.c.length);
          var A2 = 30 + M2.f.length + an(M2.extra);
          b2.set(M2.c, M2.o + A2), sn(b2, o3, M2, M2.f, M2.u, M2.c.length, M2.o, M2.m), o3 += 16 + A2 + (M2.m ? M2.m.length : 0);
        }
        return fn(b2, o3, i2.length, z2, x2), b2;
      }
      _e.Zip = ln, _e.zip = pn, _e.zipSync = vn;
      var dn = function() {
        function t2() {
        }
        return t2.prototype.push = function(t3, n2) {
          this.ondata(null, t3, n2);
        }, t2.compression = 0, t2;
      }();
      _e.UnzipPassThrough = dn;
      var gn = function() {
        function t2() {
          var t3 = this;
          this.i = new zt(function(n2, r2) {
            t3.ondata(null, n2, r2);
          });
        }
        return t2.prototype.push = function(t3, n2) {
          try {
            this.i.push(t3, n2);
          } catch (r2) {
            this.ondata(r2, t3, n2);
          }
        }, t2.compression = 8, t2;
      }();
      _e.UnzipInflate = gn;
      var wn = function() {
        function t2(t3, n2) {
          var r2 = this;
          n2 < 32e4 ? this.i = new zt(function(t4, n3) {
            r2.ondata(null, t4, n3);
          }) : (this.i = new kt(function(t4, n3, e2) {
            r2.ondata(t4, n3, e2);
          }), this.terminate = this.i.terminate);
        }
        return t2.prototype.push = function(t3, n2) {
          this.i.terminate && (t3 = C(t3, 0)), this.i.push(t3, n2);
        }, t2.compression = 8, t2;
      }();
      _e.AsyncUnzipInflate = wn;
      var yn = function() {
        function t2(t3) {
          this.onfile = t3, this.k = [], this.o = { 0: dn }, this.p = _;
        }
        return t2.prototype.push = function(t3, r2) {
          var e2 = this;
          if (!this.onfile)
            throw "no callback";
          if (this.c > 0) {
            var i2 = Math.min(this.c, t3.length), o3 = t3.subarray(0, i2);
            if (this.c -= i2, this.d ? this.d.push(o3, !this.c) : this.k[0].push(o3), (t3 = t3.subarray(i2)).length)
              return this.push(t3, r2);
          } else {
            var a2 = 0, s2 = 0, f2 = void 0, u2 = void 0;
            this.p.length ? t3.length ? ((u2 = new n(this.p.length + t3.length)).set(this.p), u2.set(t3, this.p.length)) : u2 = this.p : u2 = t3;
            for (var h2 = u2.length, c2 = this.c, l2 = c2 && this.d, p2 = function() {
              var t4, n2 = ft(u2, s2);
              if (67324752 == n2) {
                a2 = 1, f2 = s2, v2.d = null, v2.c = 0;
                var r3 = st(u2, s2 + 6), i3 = st(u2, s2 + 8), o4 = 2048 & r3, l3 = 8 & r3, p3 = st(u2, s2 + 26), d3 = st(u2, s2 + 28);
                if (h2 > s2 + 30 + p3 + d3) {
                  var g2 = [];
                  v2.k.unshift(g2), a2 = 2;
                  var w2 = ft(u2, s2 + 18), y2 = ft(u2, s2 + 22), m2 = tn(u2.subarray(s2 + 30, s2 += 30 + p3), !o4);
                  4294967295 == w2 ? (t4 = l3 ? [-2] : on(u2, s2), w2 = t4[0], y2 = t4[1]) : l3 && (w2 = -1), s2 += d3, v2.c = w2;
                  var b2 = { name: m2, compression: i3, start: function() {
                    if (!b2.ondata)
                      throw "no callback";
                    if (w2) {
                      var t5 = e2.o[i3];
                      if (!t5)
                        throw "unknown compression type " + i3;
                      var n3 = w2 < 0 ? new t5(m2) : new t5(m2, w2, y2);
                      n3.ondata = function(t6, n4, r5) {
                        b2.ondata(t6, n4, r5);
                      };
                      for (var r4 = 0, o5 = g2; r4 < o5.length; r4++)
                        n3.push(o5[r4], false);
                      e2.k[0] == g2 ? e2.d = n3 : n3.push(_, true);
                    } else
                      b2.ondata(null, _, true);
                  }, terminate: function() {
                    e2.k[0] == g2 && e2.d.terminate && e2.d.terminate();
                  } };
                  w2 >= 0 && (b2.size = w2, b2.originalSize = y2), v2.onfile(b2);
                }
                return "break";
              }
              if (c2) {
                if (134695760 == n2)
                  return f2 = s2 += 12 + (-2 == c2 && 8), a2 = 2, v2.c = 0, "break";
                if (33639248 == n2)
                  return f2 = s2 -= 4, a2 = 2, v2.c = 0, "break";
              }
            }, v2 = this; s2 < h2 - 4 && "break" !== p2(); ++s2)
              ;
            if (this.p = _, c2 < 0) {
              var d2 = u2.subarray(0, a2 ? f2 - 12 - (-2 == c2 && 8) - (134695760 == ft(u2, f2 - 16) && 4) : s2);
              l2 ? l2.push(d2, !!a2) : this.k[+(2 == a2)].push(d2);
            }
            if (2 & a2)
              return this.push(u2.subarray(s2), r2);
            this.p = u2.subarray(s2);
          }
          if (r2 && this.c)
            throw "invalid zip file";
        }, t2.prototype.register = function(t3) {
          this.o[t3.compression] = t3;
        }, t2;
      }();
      function mn(t2, r2) {
        if ("function" != typeof r2)
          throw "no callback";
        for (var e2 = [], i2 = function() {
          for (var t3 = 0; t3 < e2.length; ++t3)
            e2[t3]();
        }, o3 = {}, a2 = t2.length - 22; 101010256 != ft(t2, a2); --a2)
          if (!a2 || t2.length - a2 > 65558)
            return void r2("invalid zip file", null);
        var s2 = st(t2, a2 + 8);
        s2 || r2(null, {});
        var f2 = s2, u2 = ft(t2, a2 + 16), h2 = 4294967295 == u2;
        if (h2) {
          if (a2 = ft(t2, a2 - 12), 101075792 != ft(t2, a2))
            return void r2("invalid zip file", null);
          f2 = s2 = ft(t2, a2 + 32), u2 = ft(t2, a2 + 48);
        }
        for (var c2 = function(a3) {
          var f3 = en(t2, u2, h2), c3 = f3[0], l3 = f3[1], p2 = f3[2], v2 = f3[3], d2 = f3[4], g2 = rn(t2, f3[5]);
          u2 = d2;
          var w2 = function(t3, n2) {
            t3 ? (i2(), r2(t3, null)) : (o3[v2] = n2, --s2 || r2(null, o3));
          };
          if (c3)
            if (8 == c3) {
              var y2 = t2.subarray(g2, g2 + l3);
              if (l3 < 32e4)
                try {
                  w2(null, At(y2, new n(p2)));
                } catch (t3) {
                  w2(t3, null);
                }
              else
                e2.push(Mt(y2, { size: p2 }, w2));
            } else
              w2("unknown compression type " + c3, null);
          else
            w2(null, C(t2, g2, g2 + l3));
        }, l2 = 0; l2 < f2; ++l2)
          c2();
        return i2;
      }
      function bn(t2) {
        for (var r2 = {}, e2 = t2.length - 22; 101010256 != ft(t2, e2); --e2)
          if (!e2 || t2.length - e2 > 65558)
            throw "invalid zip file";
        var i2 = st(t2, e2 + 8);
        if (!i2)
          return {};
        var o3 = ft(t2, e2 + 16), a2 = 4294967295 == o3;
        if (a2) {
          if (e2 = ft(t2, e2 - 12), 101075792 != ft(t2, e2))
            throw "invalid zip file";
          i2 = ft(t2, e2 + 32), o3 = ft(t2, e2 + 48);
        }
        for (var s2 = 0; s2 < i2; ++s2) {
          var f2 = en(t2, o3, a2), u2 = f2[0], h2 = f2[1], c2 = f2[2], l2 = f2[3], p2 = f2[4], v2 = rn(t2, f2[5]);
          if (o3 = p2, u2) {
            if (8 != u2)
              throw "unknown compression type " + u2;
            r2[l2] = At(t2.subarray(v2, v2 + h2), new n(c2));
          } else
            r2[l2] = C(t2, v2, v2 + h2);
        }
        return r2;
      }
      _e.Unzip = yn, _e.unzip = mn, _e.unzipSync = bn;
      return _e;
    });
  }
});

// node_modules/threebox-plugin/src/objects/loaders/FBXLoader.js
var require_FBXLoader = __commonJS({
  "node_modules/threebox-plugin/src/objects/loaders/FBXLoader.js"(exports, module) {
    var THREE2 = require_three();
    var fflate = require_fflate_min();
    (function() {
      let fbxTree;
      let connections;
      let sceneGraph;
      class FBXLoader extends THREE2.Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = scope.path === "" ? THREE2.LoaderUtils.extractUrlBase(url) : scope.path;
          const loader = new THREE2.FileLoader(this.manager);
          loader.setPath(scope.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(buffer) {
            try {
              onLoad(scope.parse(buffer, path));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(FBXBuffer, path) {
          if (isFbxFormatBinary(FBXBuffer)) {
            fbxTree = new BinaryParser().parse(FBXBuffer);
          } else {
            const FBXText = convertArrayBufferToString(FBXBuffer);
            if (!isFbxFormatASCII(FBXText)) {
              throw new Error("THREE.FBXLoader: Unknown format.");
            }
            if (getFbxVersion(FBXText) < 7e3) {
              throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
            }
            fbxTree = new TextParser().parse(FBXText);
          }
          const textureLoader = new THREE2.TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
          return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
        }
      }
      class FBXTreeParser {
        constructor(textureLoader, manager) {
          this.textureLoader = textureLoader;
          this.manager = manager;
        }
        parse() {
          connections = this.parseConnections();
          const images = this.parseImages();
          const textures = this.parseTextures(images);
          const materials = this.parseMaterials(textures);
          const deformers = this.parseDeformers();
          const geometryMap = new GeometryParser().parse(deformers);
          this.parseScene(deformers, geometryMap, materials);
          return sceneGraph;
        }
        // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
        // and details the connection type
        parseConnections() {
          const connectionMap = /* @__PURE__ */ new Map();
          if ("Connections" in fbxTree) {
            const rawConnections = fbxTree.Connections.connections;
            rawConnections.forEach(function(rawConnection) {
              const fromID = rawConnection[0];
              const toID = rawConnection[1];
              const relationship = rawConnection[2];
              if (!connectionMap.has(fromID)) {
                connectionMap.set(fromID, {
                  parents: [],
                  children: []
                });
              }
              const parentRelationship = {
                ID: toID,
                relationship
              };
              connectionMap.get(fromID).parents.push(parentRelationship);
              if (!connectionMap.has(toID)) {
                connectionMap.set(toID, {
                  parents: [],
                  children: []
                });
              }
              const childRelationship = {
                ID: fromID,
                relationship
              };
              connectionMap.get(toID).children.push(childRelationship);
            });
          }
          return connectionMap;
        }
        // Parse FBXTree.Objects.Video for embedded image data
        // These images are connected to textures in FBXTree.Objects.Textures
        // via FBXTree.Connections.
        parseImages() {
          const images = {};
          const blobs = {};
          if ("Video" in fbxTree.Objects) {
            const videoNodes = fbxTree.Objects.Video;
            for (const nodeID in videoNodes) {
              const videoNode = videoNodes[nodeID];
              const id = parseInt(nodeID);
              images[id] = videoNode.RelativeFilename || videoNode.Filename;
              if ("Content" in videoNode) {
                const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
                const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
                if (arrayBufferContent || base64Content) {
                  const image = this.parseImage(videoNodes[nodeID]);
                  blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
                }
              }
            }
          }
          for (const id in images) {
            const filename = images[id];
            if (blobs[filename] !== void 0)
              images[id] = blobs[filename];
            else
              images[id] = images[id].split("\\").pop();
          }
          return images;
        }
        // Parse embedded image data in FBXTree.Video.Content
        parseImage(videoNode) {
          const content = videoNode.Content;
          const fileName = videoNode.RelativeFilename || videoNode.Filename;
          const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
          let type;
          switch (extension) {
            case "bmp":
              type = "image/bmp";
              break;
            case "jpg":
            case "jpeg":
              type = "image/jpeg";
              break;
            case "png":
              type = "image/png";
              break;
            case "tif":
              type = "image/tiff";
              break;
            case "tga":
              if (this.manager.getHandler(".tga") === null) {
                console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
              }
              type = "image/tga";
              break;
            default:
              console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
              return;
          }
          if (typeof content === "string") {
            return "data:" + type + ";base64," + content;
          } else {
            const array = new Uint8Array(content);
            return window.URL.createObjectURL(new Blob([array], {
              type
            }));
          }
        }
        // Parse nodes in FBXTree.Objects.Texture
        // These contain details such as UV scaling, cropping, rotation etc and are connected
        // to images in FBXTree.Objects.Video
        parseTextures(images) {
          const textureMap = /* @__PURE__ */ new Map();
          if ("Texture" in fbxTree.Objects) {
            const textureNodes = fbxTree.Objects.Texture;
            for (const nodeID in textureNodes) {
              const texture = this.parseTexture(textureNodes[nodeID], images);
              textureMap.set(parseInt(nodeID), texture);
            }
          }
          return textureMap;
        }
        // Parse individual node in FBXTree.Objects.Texture
        parseTexture(textureNode, images) {
          const texture = this.loadTexture(textureNode, images);
          texture.ID = textureNode.id;
          texture.name = textureNode.attrName;
          const wrapModeU = textureNode.WrapModeU;
          const wrapModeV = textureNode.WrapModeV;
          const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
          const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
          texture.wrapS = valueU === 0 ? THREE2.RepeatWrapping : THREE2.ClampToEdgeWrapping;
          texture.wrapT = valueV === 0 ? THREE2.RepeatWrapping : THREE2.ClampToEdgeWrapping;
          if ("Scaling" in textureNode) {
            const values = textureNode.Scaling.value;
            texture.repeat.x = values[0];
            texture.repeat.y = values[1];
          }
          return texture;
        }
        // load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader
        loadTexture(textureNode, images) {
          let fileName;
          const currentPath = this.textureLoader.path;
          const children = connections.get(textureNode.id).children;
          if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
            fileName = images[children[0].ID];
            if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
              this.textureLoader.setPath(void 0);
            }
          }
          let texture;
          const extension = textureNode.FileName.slice(-3).toLowerCase();
          if (extension === "tga") {
            const loader = this.manager.getHandler(".tga");
            if (loader === null) {
              console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
              texture = new THREE2.Texture();
            } else {
              loader.setPath(this.textureLoader.path);
              texture = loader.load(fileName);
            }
          } else if (extension === "psd") {
            console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
            texture = new THREE2.Texture();
          } else {
            texture = this.textureLoader.load(fileName);
          }
          this.textureLoader.setPath(currentPath);
          return texture;
        }
        // Parse nodes in FBXTree.Objects.Material
        parseMaterials(textureMap) {
          const materialMap = /* @__PURE__ */ new Map();
          if ("Material" in fbxTree.Objects) {
            const materialNodes = fbxTree.Objects.Material;
            for (const nodeID in materialNodes) {
              const material = this.parseMaterial(materialNodes[nodeID], textureMap);
              if (material !== null)
                materialMap.set(parseInt(nodeID), material);
            }
          }
          return materialMap;
        }
        // Parse single node in FBXTree.Objects.Material
        // Materials are connected to texture maps in FBXTree.Objects.Textures
        // FBX format currently only supports Lambert and Phong shading models
        parseMaterial(materialNode, textureMap) {
          const ID = materialNode.id;
          const name = materialNode.attrName;
          let type = materialNode.ShadingModel;
          if (typeof type === "object") {
            type = type.value;
          }
          if (!connections.has(ID))
            return null;
          const parameters = this.parseParameters(materialNode, textureMap, ID);
          let material;
          switch (type.toLowerCase()) {
            case "phong":
              material = new THREE2.MeshPhongMaterial();
              break;
            case "lambert":
              material = new THREE2.MeshLambertMaterial();
              break;
            default:
              console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to THREE.MeshPhongMaterial.', type);
              material = new THREE2.MeshPhongMaterial();
              break;
          }
          material.setValues(parameters);
          material.name = name;
          return material;
        }
        // Parse FBX material and return parameters suitable for a three.js material
        // Also parse the texture map and return any textures associated with the material
        parseParameters(materialNode, textureMap, ID) {
          const parameters = {};
          if (materialNode.BumpFactor) {
            parameters.bumpScale = materialNode.BumpFactor.value;
          }
          if (materialNode.Diffuse) {
            parameters.color = new THREE2.Color().fromArray(materialNode.Diffuse.value);
          } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
            parameters.color = new THREE2.Color().fromArray(materialNode.DiffuseColor.value);
          }
          if (materialNode.DisplacementFactor) {
            parameters.displacementScale = materialNode.DisplacementFactor.value;
          }
          if (materialNode.Emissive) {
            parameters.emissive = new THREE2.Color().fromArray(materialNode.Emissive.value);
          } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
            parameters.emissive = new THREE2.Color().fromArray(materialNode.EmissiveColor.value);
          }
          if (materialNode.EmissiveFactor) {
            parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
          }
          if (materialNode.Opacity) {
            parameters.opacity = parseFloat(materialNode.Opacity.value);
          }
          if (parameters.opacity < 1) {
            parameters.transparent = true;
          }
          if (materialNode.ReflectionFactor) {
            parameters.reflectivity = materialNode.ReflectionFactor.value;
          }
          if (materialNode.Shininess) {
            parameters.shininess = materialNode.Shininess.value;
          }
          if (materialNode.Specular) {
            parameters.specular = new THREE2.Color().fromArray(materialNode.Specular.value);
          } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
            parameters.specular = new THREE2.Color().fromArray(materialNode.SpecularColor.value);
          }
          const scope = this;
          connections.get(ID).children.forEach(function(child) {
            const type = child.relationship;
            switch (type) {
              case "Bump":
                parameters.bumpMap = scope.getTexture(textureMap, child.ID);
                break;
              case "Maya|TEX_ao_map":
                parameters.aoMap = scope.getTexture(textureMap, child.ID);
                break;
              case "DiffuseColor":
              case "Maya|TEX_color_map":
                parameters.map = scope.getTexture(textureMap, child.ID);
                if (parameters.map !== void 0) {
                  parameters.map.encoding = THREE2.sRGBEncoding;
                }
                break;
              case "DisplacementColor":
                parameters.displacementMap = scope.getTexture(textureMap, child.ID);
                break;
              case "EmissiveColor":
                parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
                if (parameters.emissiveMap !== void 0) {
                  parameters.emissiveMap.encoding = THREE2.sRGBEncoding;
                }
                break;
              case "NormalMap":
              case "Maya|TEX_normal_map":
                parameters.normalMap = scope.getTexture(textureMap, child.ID);
                break;
              case "ReflectionColor":
                parameters.envMap = scope.getTexture(textureMap, child.ID);
                if (parameters.envMap !== void 0) {
                  parameters.envMap.mapping = THREE2.EquirectangularReflectionMapping;
                  parameters.envMap.encoding = THREE2.sRGBEncoding;
                }
                break;
              case "SpecularColor":
                parameters.specularMap = scope.getTexture(textureMap, child.ID);
                if (parameters.specularMap !== void 0) {
                  parameters.specularMap.encoding = THREE2.sRGBEncoding;
                }
                break;
              case "TransparentColor":
              case "TransparencyFactor":
                parameters.alphaMap = scope.getTexture(textureMap, child.ID);
                parameters.transparent = true;
                break;
              case "AmbientColor":
              case "ShininessExponent":
              case "SpecularFactor":
              case "VectorDisplacementColor":
              default:
                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
                break;
            }
          });
          return parameters;
        }
        // get a texture from the textureMap for use by a material.
        getTexture(textureMap, id) {
          if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
            console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
            id = connections.get(id).children[0].ID;
          }
          return textureMap.get(id);
        }
        // Parse nodes in FBXTree.Objects.Deformer
        // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
        // Generates map of THREE.Skeleton-like objects for use later when generating and binding skeletons.
        parseDeformers() {
          const skeletons = {};
          const morphTargets = {};
          if ("Deformer" in fbxTree.Objects) {
            const DeformerNodes = fbxTree.Objects.Deformer;
            for (const nodeID in DeformerNodes) {
              const deformerNode = DeformerNodes[nodeID];
              const relationships = connections.get(parseInt(nodeID));
              if (deformerNode.attrType === "Skin") {
                const skeleton = this.parseSkeleton(relationships, DeformerNodes);
                skeleton.ID = nodeID;
                if (relationships.parents.length > 1)
                  console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
                skeleton.geometryID = relationships.parents[0].ID;
                skeletons[nodeID] = skeleton;
              } else if (deformerNode.attrType === "BlendShape") {
                const morphTarget = {
                  id: nodeID
                };
                morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
                morphTarget.id = nodeID;
                if (relationships.parents.length > 1)
                  console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
                morphTargets[nodeID] = morphTarget;
              }
            }
          }
          return {
            skeletons,
            morphTargets
          };
        }
        // Parse single nodes in FBXTree.Objects.Deformer
        // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
        // Each skin node represents a skeleton and each cluster node represents a bone
        parseSkeleton(relationships, deformerNodes) {
          const rawBones = [];
          relationships.children.forEach(function(child) {
            const boneNode = deformerNodes[child.ID];
            if (boneNode.attrType !== "Cluster")
              return;
            const rawBone = {
              ID: child.ID,
              indices: [],
              weights: [],
              transformLink: new THREE2.Matrix4().fromArray(boneNode.TransformLink.a)
              // transform: new THREE.Matrix4().fromArray( boneNode.Transform.a ),
              // linkMode: boneNode.Mode,
            };
            if ("Indexes" in boneNode) {
              rawBone.indices = boneNode.Indexes.a;
              rawBone.weights = boneNode.Weights.a;
            }
            rawBones.push(rawBone);
          });
          return {
            rawBones,
            bones: []
          };
        }
        // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
        parseMorphTargets(relationships, deformerNodes) {
          const rawMorphTargets = [];
          for (let i = 0; i < relationships.children.length; i++) {
            const child = relationships.children[i];
            const morphTargetNode = deformerNodes[child.ID];
            const rawMorphTarget = {
              name: morphTargetNode.attrName,
              initialWeight: morphTargetNode.DeformPercent,
              id: morphTargetNode.id,
              fullWeights: morphTargetNode.FullWeights.a
            };
            if (morphTargetNode.attrType !== "BlendShapeChannel")
              return;
            rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
              return child2.relationship === void 0;
            })[0].ID;
            rawMorphTargets.push(rawMorphTarget);
          }
          return rawMorphTargets;
        }
        // create the main THREE.Group() to be returned by the loader
        parseScene(deformers, geometryMap, materialMap) {
          sceneGraph = new THREE2.Group();
          const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
          const modelNodes = fbxTree.Objects.Model;
          const scope = this;
          modelMap.forEach(function(model) {
            const modelNode = modelNodes[model.ID];
            scope.setLookAtProperties(model, modelNode);
            const parentConnections = connections.get(model.ID).parents;
            parentConnections.forEach(function(connection) {
              const parent = modelMap.get(connection.ID);
              if (parent !== void 0)
                parent.add(model);
            });
            if (model.parent === null) {
              sceneGraph.add(model);
            }
          });
          this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
          this.createAmbientLight();
          sceneGraph.traverse(function(node) {
            if (node.userData.transformData) {
              if (node.parent) {
                node.userData.transformData.parentMatrix = node.parent.matrix;
                node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
              }
              const transform = generateTransform(node.userData.transformData);
              node.applyMatrix4(transform);
              node.updateWorldMatrix();
            }
          });
          const animations = new AnimationParser().parse();
          if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
            sceneGraph.children[0].animations = animations;
            sceneGraph = sceneGraph.children[0];
          }
          sceneGraph.animations = animations;
        }
        // parse nodes in FBXTree.Objects.Model
        parseModels(skeletons, geometryMap, materialMap) {
          const modelMap = /* @__PURE__ */ new Map();
          const modelNodes = fbxTree.Objects.Model;
          for (const nodeID in modelNodes) {
            const id = parseInt(nodeID);
            const node = modelNodes[nodeID];
            const relationships = connections.get(id);
            let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
            if (!model) {
              switch (node.attrType) {
                case "Camera":
                  model = this.createCamera(relationships);
                  break;
                case "Light":
                  model = this.createLight(relationships);
                  break;
                case "Mesh":
                  model = this.createMesh(relationships, geometryMap, materialMap);
                  break;
                case "NurbsCurve":
                  model = this.createCurve(relationships, geometryMap);
                  break;
                case "LimbNode":
                case "Root":
                  model = new THREE2.Bone();
                  break;
                case "Null":
                default:
                  model = new THREE2.Group();
                  break;
              }
              model.name = node.attrName ? THREE2.PropertyBinding.sanitizeNodeName(node.attrName) : "";
              model.ID = id;
            }
            this.getTransformData(model, node);
            modelMap.set(id, model);
          }
          return modelMap;
        }
        buildSkeleton(relationships, skeletons, id, name) {
          let bone = null;
          relationships.parents.forEach(function(parent) {
            for (const ID in skeletons) {
              const skeleton = skeletons[ID];
              skeleton.rawBones.forEach(function(rawBone, i) {
                if (rawBone.ID === parent.ID) {
                  const subBone = bone;
                  bone = new THREE2.Bone();
                  bone.matrixWorld.copy(rawBone.transformLink);
                  bone.name = name ? THREE2.PropertyBinding.sanitizeNodeName(name) : "";
                  bone.ID = id;
                  skeleton.bones[i] = bone;
                  if (subBone !== null) {
                    bone.add(subBone);
                  }
                }
              });
            }
          });
          return bone;
        }
        // create a THREE.PerspectiveCamera or THREE.OrthographicCamera
        createCamera(relationships) {
          let model;
          let cameraAttribute;
          relationships.children.forEach(function(child) {
            const attr = fbxTree.Objects.NodeAttribute[child.ID];
            if (attr !== void 0) {
              cameraAttribute = attr;
            }
          });
          if (cameraAttribute === void 0) {
            model = new THREE2.Object3D();
          } else {
            let type = 0;
            if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
              type = 1;
            }
            let nearClippingPlane = 1;
            if (cameraAttribute.NearPlane !== void 0) {
              nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
            }
            let farClippingPlane = 1e3;
            if (cameraAttribute.FarPlane !== void 0) {
              farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
            }
            let width = window.innerWidth;
            let height = window.innerHeight;
            if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
              width = cameraAttribute.AspectWidth.value;
              height = cameraAttribute.AspectHeight.value;
            }
            const aspect = width / height;
            let fov = 45;
            if (cameraAttribute.FieldOfView !== void 0) {
              fov = cameraAttribute.FieldOfView.value;
            }
            const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
            switch (type) {
              case 0:
                model = new THREE2.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
                if (focalLength !== null)
                  model.setFocalLength(focalLength);
                break;
              case 1:
                model = new THREE2.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
                model = new THREE2.Object3D();
                break;
            }
          }
          return model;
        }
        // Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight
        createLight(relationships) {
          let model;
          let lightAttribute;
          relationships.children.forEach(function(child) {
            const attr = fbxTree.Objects.NodeAttribute[child.ID];
            if (attr !== void 0) {
              lightAttribute = attr;
            }
          });
          if (lightAttribute === void 0) {
            model = new THREE2.Object3D();
          } else {
            let type;
            if (lightAttribute.LightType === void 0) {
              type = 0;
            } else {
              type = lightAttribute.LightType.value;
            }
            let color = 16777215;
            if (lightAttribute.Color !== void 0) {
              color = new THREE2.Color().fromArray(lightAttribute.Color.value);
            }
            let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
            if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
              intensity = 0;
            }
            let distance = 0;
            if (lightAttribute.FarAttenuationEnd !== void 0) {
              if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
                distance = 0;
              } else {
                distance = lightAttribute.FarAttenuationEnd.value;
              }
            }
            const decay = 1;
            switch (type) {
              case 0:
                model = new THREE2.PointLight(color, intensity, distance, decay);
                break;
              case 1:
                model = new THREE2.DirectionalLight(color, intensity);
                break;
              case 2:
                let angle = Math.PI / 3;
                if (lightAttribute.InnerAngle !== void 0) {
                  angle = THREE2.MathUtils.degToRad(lightAttribute.InnerAngle.value);
                }
                let penumbra = 0;
                if (lightAttribute.OuterAngle !== void 0) {
                  penumbra = THREE2.MathUtils.degToRad(lightAttribute.OuterAngle.value);
                  penumbra = Math.max(penumbra, 1);
                }
                model = new THREE2.SpotLight(color, intensity, distance, angle, penumbra, decay);
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a THREE.PointLight.");
                model = new THREE2.PointLight(color, intensity);
                break;
            }
            if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
              model.castShadow = true;
            }
          }
          return model;
        }
        createMesh(relationships, geometryMap, materialMap) {
          let model;
          let geometry = null;
          let material = null;
          const materials = [];
          relationships.children.forEach(function(child) {
            if (geometryMap.has(child.ID)) {
              geometry = geometryMap.get(child.ID);
            }
            if (materialMap.has(child.ID)) {
              materials.push(materialMap.get(child.ID));
            }
          });
          if (materials.length > 1) {
            material = materials;
          } else if (materials.length > 0) {
            material = materials[0];
          } else {
            material = new THREE2.MeshPhongMaterial({
              color: 13421772
            });
            materials.push(material);
          }
          if ("color" in geometry.attributes) {
            materials.forEach(function(material2) {
              material2.vertexColors = true;
            });
          }
          if (geometry.FBX_Deformer) {
            model = new THREE2.SkinnedMesh(geometry, material);
            model.normalizeSkinWeights();
          } else {
            model = new THREE2.Mesh(geometry, material);
          }
          return model;
        }
        createCurve(relationships, geometryMap) {
          const geometry = relationships.children.reduce(function(geo, child) {
            if (geometryMap.has(child.ID))
              geo = geometryMap.get(child.ID);
            return geo;
          }, null);
          const material = new THREE2.LineBasicMaterial({
            color: 3342591,
            linewidth: 1
          });
          return new THREE2.Line(geometry, material);
        }
        // parse the model node for transform data
        getTransformData(model, modelNode) {
          const transformData = {};
          if ("InheritType" in modelNode)
            transformData.inheritType = parseInt(modelNode.InheritType.value);
          if ("RotationOrder" in modelNode)
            transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
          else
            transformData.eulerOrder = "ZYX";
          if ("Lcl_Translation" in modelNode)
            transformData.translation = modelNode.Lcl_Translation.value;
          if ("PreRotation" in modelNode)
            transformData.preRotation = modelNode.PreRotation.value;
          if ("Lcl_Rotation" in modelNode)
            transformData.rotation = modelNode.Lcl_Rotation.value;
          if ("PostRotation" in modelNode)
            transformData.postRotation = modelNode.PostRotation.value;
          if ("Lcl_Scaling" in modelNode)
            transformData.scale = modelNode.Lcl_Scaling.value;
          if ("ScalingOffset" in modelNode)
            transformData.scalingOffset = modelNode.ScalingOffset.value;
          if ("ScalingPivot" in modelNode)
            transformData.scalingPivot = modelNode.ScalingPivot.value;
          if ("RotationOffset" in modelNode)
            transformData.rotationOffset = modelNode.RotationOffset.value;
          if ("RotationPivot" in modelNode)
            transformData.rotationPivot = modelNode.RotationPivot.value;
          model.userData.transformData = transformData;
        }
        setLookAtProperties(model, modelNode) {
          if ("LookAtProperty" in modelNode) {
            const children = connections.get(model.ID).children;
            children.forEach(function(child) {
              if (child.relationship === "LookAtProperty") {
                const lookAtTarget = fbxTree.Objects.Model[child.ID];
                if ("Lcl_Translation" in lookAtTarget) {
                  const pos = lookAtTarget.Lcl_Translation.value;
                  if (model.target !== void 0) {
                    model.target.position.fromArray(pos);
                    sceneGraph.add(model.target);
                  } else {
                    model.lookAt(new THREE2.Vector3().fromArray(pos));
                  }
                }
              }
            });
          }
        }
        bindSkeleton(skeletons, geometryMap, modelMap) {
          const bindMatrices = this.parsePoseNodes();
          for (const ID in skeletons) {
            const skeleton = skeletons[ID];
            const parents = connections.get(parseInt(skeleton.ID)).parents;
            parents.forEach(function(parent) {
              if (geometryMap.has(parent.ID)) {
                const geoID = parent.ID;
                const geoRelationships = connections.get(geoID);
                geoRelationships.parents.forEach(function(geoConnParent) {
                  if (modelMap.has(geoConnParent.ID)) {
                    const model = modelMap.get(geoConnParent.ID);
                    model.bind(new THREE2.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
                  }
                });
              }
            });
          }
        }
        parsePoseNodes() {
          const bindMatrices = {};
          if ("Pose" in fbxTree.Objects) {
            const BindPoseNode = fbxTree.Objects.Pose;
            for (const nodeID in BindPoseNode) {
              if (BindPoseNode[nodeID].attrType === "BindPose") {
                const poseNodes = BindPoseNode[nodeID].PoseNode;
                if (Array.isArray(poseNodes)) {
                  poseNodes.forEach(function(poseNode) {
                    bindMatrices[poseNode.Node] = new THREE2.Matrix4().fromArray(poseNode.Matrix.a);
                  });
                } else {
                  bindMatrices[poseNodes.Node] = new THREE2.Matrix4().fromArray(poseNodes.Matrix.a);
                }
              }
            }
          }
          return bindMatrices;
        }
        // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
        createAmbientLight() {
          if ("GlobalSettings" in fbxTree && "AmbientColor" in fbxTree.GlobalSettings) {
            const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
            const r = ambientColor[0];
            const g = ambientColor[1];
            const b = ambientColor[2];
            if (r !== 0 || g !== 0 || b !== 0) {
              const color = new THREE2.Color(r, g, b);
              sceneGraph.add(new THREE2.AmbientLight(color, 1));
            }
          }
        }
      }
      class GeometryParser {
        // Parse nodes in FBXTree.Objects.Geometry
        parse(deformers) {
          const geometryMap = /* @__PURE__ */ new Map();
          if ("Geometry" in fbxTree.Objects) {
            const geoNodes = fbxTree.Objects.Geometry;
            for (const nodeID in geoNodes) {
              const relationships = connections.get(parseInt(nodeID));
              const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
              geometryMap.set(parseInt(nodeID), geo);
            }
          }
          return geometryMap;
        }
        // Parse single node in FBXTree.Objects.Geometry
        parseGeometry(relationships, geoNode, deformers) {
          switch (geoNode.attrType) {
            case "Mesh":
              return this.parseMeshGeometry(relationships, geoNode, deformers);
              break;
            case "NurbsCurve":
              return this.parseNurbsGeometry(geoNode);
              break;
          }
        }
        // Parse single node mesh geometry in FBXTree.Objects.Geometry
        parseMeshGeometry(relationships, geoNode, deformers) {
          const skeletons = deformers.skeletons;
          const morphTargets = [];
          const modelNodes = relationships.parents.map(function(parent) {
            return fbxTree.Objects.Model[parent.ID];
          });
          if (modelNodes.length === 0)
            return;
          const skeleton = relationships.children.reduce(function(skeleton2, child) {
            if (skeletons[child.ID] !== void 0)
              skeleton2 = skeletons[child.ID];
            return skeleton2;
          }, null);
          relationships.children.forEach(function(child) {
            if (deformers.morphTargets[child.ID] !== void 0) {
              morphTargets.push(deformers.morphTargets[child.ID]);
            }
          });
          const modelNode = modelNodes[0];
          const transformData = {};
          if ("RotationOrder" in modelNode)
            transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
          if ("InheritType" in modelNode)
            transformData.inheritType = parseInt(modelNode.InheritType.value);
          if ("GeometricTranslation" in modelNode)
            transformData.translation = modelNode.GeometricTranslation.value;
          if ("GeometricRotation" in modelNode)
            transformData.rotation = modelNode.GeometricRotation.value;
          if ("GeometricScaling" in modelNode)
            transformData.scale = modelNode.GeometricScaling.value;
          const transform = generateTransform(transformData);
          return this.genGeometry(geoNode, skeleton, morphTargets, transform);
        }
        // Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry
        genGeometry(geoNode, skeleton, morphTargets, preTransform) {
          const geo = new THREE2.BufferGeometry();
          if (geoNode.attrName)
            geo.name = geoNode.attrName;
          const geoInfo = this.parseGeoNode(geoNode, skeleton);
          const buffers = this.genBuffers(geoInfo);
          const positionAttribute = new THREE2.Float32BufferAttribute(buffers.vertex, 3);
          positionAttribute.applyMatrix4(preTransform);
          geo.setAttribute("position", positionAttribute);
          if (buffers.colors.length > 0) {
            geo.setAttribute("color", new THREE2.Float32BufferAttribute(buffers.colors, 3));
          }
          if (skeleton) {
            geo.setAttribute("skinIndex", new THREE2.Uint16BufferAttribute(buffers.weightsIndices, 4));
            geo.setAttribute("skinWeight", new THREE2.Float32BufferAttribute(buffers.vertexWeights, 4));
            geo.FBX_Deformer = skeleton;
          }
          if (buffers.normal.length > 0) {
            const normalMatrix = new THREE2.Matrix3().getNormalMatrix(preTransform);
            const normalAttribute = new THREE2.Float32BufferAttribute(buffers.normal, 3);
            normalAttribute.applyNormalMatrix(normalMatrix);
            geo.setAttribute("normal", normalAttribute);
          }
          buffers.uvs.forEach(function(uvBuffer, i) {
            let name = "uv" + (i + 1).toString();
            if (i === 0) {
              name = "uv";
            }
            geo.setAttribute(name, new THREE2.Float32BufferAttribute(buffers.uvs[i], 2));
          });
          if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            let prevMaterialIndex = buffers.materialIndex[0];
            let startIndex = 0;
            buffers.materialIndex.forEach(function(currentIndex, i) {
              if (currentIndex !== prevMaterialIndex) {
                geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
                prevMaterialIndex = currentIndex;
                startIndex = i;
              }
            });
            if (geo.groups.length > 0) {
              const lastGroup = geo.groups[geo.groups.length - 1];
              const lastIndex = lastGroup.start + lastGroup.count;
              if (lastIndex !== buffers.materialIndex.length) {
                geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
              }
            }
            if (geo.groups.length === 0) {
              geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
            }
          }
          this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
          return geo;
        }
        parseGeoNode(geoNode, skeleton) {
          const geoInfo = {};
          geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
          geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
          if (geoNode.LayerElementColor) {
            geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
          }
          if (geoNode.LayerElementMaterial) {
            geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
          }
          if (geoNode.LayerElementNormal) {
            geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
          }
          if (geoNode.LayerElementUV) {
            geoInfo.uv = [];
            let i = 0;
            while (geoNode.LayerElementUV[i]) {
              if (geoNode.LayerElementUV[i].UV) {
                geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
              }
              i++;
            }
          }
          geoInfo.weightTable = {};
          if (skeleton !== null) {
            geoInfo.skeleton = skeleton;
            skeleton.rawBones.forEach(function(rawBone, i) {
              rawBone.indices.forEach(function(index, j) {
                if (geoInfo.weightTable[index] === void 0)
                  geoInfo.weightTable[index] = [];
                geoInfo.weightTable[index].push({
                  id: i,
                  weight: rawBone.weights[j]
                });
              });
            });
          }
          return geoInfo;
        }
        genBuffers(geoInfo) {
          const buffers = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
          };
          let polygonIndex = 0;
          let faceLength = 0;
          let displayedWeightsWarning = false;
          let facePositionIndexes = [];
          let faceNormals = [];
          let faceColors = [];
          let faceUVs = [];
          let faceWeights = [];
          let faceWeightIndices = [];
          const scope = this;
          geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
            let materialIndex;
            let endOfFace = false;
            if (vertexIndex < 0) {
              vertexIndex = vertexIndex ^ -1;
              endOfFace = true;
            }
            let weightIndices = [];
            let weights = [];
            facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
            if (geoInfo.color) {
              const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
              faceColors.push(data[0], data[1], data[2]);
            }
            if (geoInfo.skeleton) {
              if (geoInfo.weightTable[vertexIndex] !== void 0) {
                geoInfo.weightTable[vertexIndex].forEach(function(wt) {
                  weights.push(wt.weight);
                  weightIndices.push(wt.id);
                });
              }
              if (weights.length > 4) {
                if (!displayedWeightsWarning) {
                  console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
                  displayedWeightsWarning = true;
                }
                const wIndex = [0, 0, 0, 0];
                const Weight = [0, 0, 0, 0];
                weights.forEach(function(weight, weightIndex) {
                  let currentWeight = weight;
                  let currentIndex = weightIndices[weightIndex];
                  Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
                    if (currentWeight > comparedWeight) {
                      comparedWeightArray[comparedWeightIndex] = currentWeight;
                      currentWeight = comparedWeight;
                      const tmp = wIndex[comparedWeightIndex];
                      wIndex[comparedWeightIndex] = currentIndex;
                      currentIndex = tmp;
                    }
                  });
                });
                weightIndices = wIndex;
                weights = Weight;
              }
              while (weights.length < 4) {
                weights.push(0);
                weightIndices.push(0);
              }
              for (let i = 0; i < 4; ++i) {
                faceWeights.push(weights[i]);
                faceWeightIndices.push(weightIndices[i]);
              }
            }
            if (geoInfo.normal) {
              const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
              faceNormals.push(data[0], data[1], data[2]);
            }
            if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
              materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
            }
            if (geoInfo.uv) {
              geoInfo.uv.forEach(function(uv, i) {
                const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
                if (faceUVs[i] === void 0) {
                  faceUVs[i] = [];
                }
                faceUVs[i].push(data[0]);
                faceUVs[i].push(data[1]);
              });
            }
            faceLength++;
            if (endOfFace) {
              scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
              polygonIndex++;
              faceLength = 0;
              facePositionIndexes = [];
              faceNormals = [];
              faceColors = [];
              faceUVs = [];
              faceWeights = [];
              faceWeightIndices = [];
            }
          });
          return buffers;
        }
        // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
        genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
          for (let i = 2; i < faceLength; i++) {
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);
            buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);
            if (geoInfo.skeleton) {
              buffers.vertexWeights.push(faceWeights[0]);
              buffers.vertexWeights.push(faceWeights[1]);
              buffers.vertexWeights.push(faceWeights[2]);
              buffers.vertexWeights.push(faceWeights[3]);
              buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);
              buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);
              buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);
              buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);
              buffers.vertexWeights.push(faceWeights[i * 4]);
              buffers.vertexWeights.push(faceWeights[i * 4 + 1]);
              buffers.vertexWeights.push(faceWeights[i * 4 + 2]);
              buffers.vertexWeights.push(faceWeights[i * 4 + 3]);
              buffers.weightsIndices.push(faceWeightIndices[0]);
              buffers.weightsIndices.push(faceWeightIndices[1]);
              buffers.weightsIndices.push(faceWeightIndices[2]);
              buffers.weightsIndices.push(faceWeightIndices[3]);
              buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);
              buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);
              buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);
              buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);
              buffers.weightsIndices.push(faceWeightIndices[i * 4]);
              buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);
              buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);
              buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);
            }
            if (geoInfo.color) {
              buffers.colors.push(faceColors[0]);
              buffers.colors.push(faceColors[1]);
              buffers.colors.push(faceColors[2]);
              buffers.colors.push(faceColors[(i - 1) * 3]);
              buffers.colors.push(faceColors[(i - 1) * 3 + 1]);
              buffers.colors.push(faceColors[(i - 1) * 3 + 2]);
              buffers.colors.push(faceColors[i * 3]);
              buffers.colors.push(faceColors[i * 3 + 1]);
              buffers.colors.push(faceColors[i * 3 + 2]);
            }
            if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
              buffers.materialIndex.push(materialIndex);
              buffers.materialIndex.push(materialIndex);
              buffers.materialIndex.push(materialIndex);
            }
            if (geoInfo.normal) {
              buffers.normal.push(faceNormals[0]);
              buffers.normal.push(faceNormals[1]);
              buffers.normal.push(faceNormals[2]);
              buffers.normal.push(faceNormals[(i - 1) * 3]);
              buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);
              buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);
              buffers.normal.push(faceNormals[i * 3]);
              buffers.normal.push(faceNormals[i * 3 + 1]);
              buffers.normal.push(faceNormals[i * 3 + 2]);
            }
            if (geoInfo.uv) {
              geoInfo.uv.forEach(function(uv, j) {
                if (buffers.uvs[j] === void 0)
                  buffers.uvs[j] = [];
                buffers.uvs[j].push(faceUVs[j][0]);
                buffers.uvs[j].push(faceUVs[j][1]);
                buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);
                buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);
                buffers.uvs[j].push(faceUVs[j][i * 2]);
                buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);
              });
            }
          }
        }
        addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
          if (morphTargets.length === 0)
            return;
          parentGeo.morphTargetsRelative = true;
          parentGeo.morphAttributes.position = [];
          const scope = this;
          morphTargets.forEach(function(morphTarget) {
            morphTarget.rawTargets.forEach(function(rawTarget) {
              const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
              if (morphGeoNode !== void 0) {
                scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
              }
            });
          });
        }
        // a morph geometry node is similar to a standard  node, and the node is also contained
        // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
        // and a special attribute Index defining which vertices of the original geometry are affected
        // Normal and position attributes only have data for the vertices that are affected by the morph
        genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
          const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
          const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
          const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
          const length = parentGeo.attributes.position.count * 3;
          const morphPositions = new Float32Array(length);
          for (let i = 0; i < indices.length; i++) {
            const morphIndex = indices[i] * 3;
            morphPositions[morphIndex] = morphPositionsSparse[i * 3];
            morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
            morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
          }
          const morphGeoInfo = {
            vertexIndices,
            vertexPositions: morphPositions
          };
          const morphBuffers = this.genBuffers(morphGeoInfo);
          const positionAttribute = new THREE2.Float32BufferAttribute(morphBuffers.vertex, 3);
          positionAttribute.name = name || morphGeoNode.attrName;
          positionAttribute.applyMatrix4(preTransform);
          parentGeo.morphAttributes.position.push(positionAttribute);
        }
        // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
        parseNormals(NormalNode) {
          const mappingType = NormalNode.MappingInformationType;
          const referenceType = NormalNode.ReferenceInformationType;
          const buffer = NormalNode.Normals.a;
          let indexBuffer = [];
          if (referenceType === "IndexToDirect") {
            if ("NormalIndex" in NormalNode) {
              indexBuffer = NormalNode.NormalIndex.a;
            } else if ("NormalsIndex" in NormalNode) {
              indexBuffer = NormalNode.NormalsIndex.a;
            }
          }
          return {
            dataSize: 3,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
          };
        }
        // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
        parseUVs(UVNode) {
          const mappingType = UVNode.MappingInformationType;
          const referenceType = UVNode.ReferenceInformationType;
          const buffer = UVNode.UV.a;
          let indexBuffer = [];
          if (referenceType === "IndexToDirect") {
            indexBuffer = UVNode.UVIndex.a;
          }
          return {
            dataSize: 2,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
          };
        }
        // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
        parseVertexColors(ColorNode) {
          const mappingType = ColorNode.MappingInformationType;
          const referenceType = ColorNode.ReferenceInformationType;
          const buffer = ColorNode.Colors.a;
          let indexBuffer = [];
          if (referenceType === "IndexToDirect") {
            indexBuffer = ColorNode.ColorIndex.a;
          }
          return {
            dataSize: 4,
            buffer,
            indices: indexBuffer,
            mappingType,
            referenceType
          };
        }
        // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
        parseMaterialIndices(MaterialNode) {
          const mappingType = MaterialNode.MappingInformationType;
          const referenceType = MaterialNode.ReferenceInformationType;
          if (mappingType === "NoMappingInformation") {
            return {
              dataSize: 1,
              buffer: [0],
              indices: [0],
              mappingType: "AllSame",
              referenceType
            };
          }
          const materialIndexBuffer = MaterialNode.Materials.a;
          const materialIndices = [];
          for (let i = 0; i < materialIndexBuffer.length; ++i) {
            materialIndices.push(i);
          }
          return {
            dataSize: 1,
            buffer: materialIndexBuffer,
            indices: materialIndices,
            mappingType,
            referenceType
          };
        }
        // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
        parseNurbsGeometry(geoNode) {
          if (THREE2.NURBSCurve === void 0) {
            console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.");
            return new THREE2.BufferGeometry();
          }
          const order = parseInt(geoNode.Order);
          if (isNaN(order)) {
            console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
            return new THREE2.BufferGeometry();
          }
          const degree = order - 1;
          const knots = geoNode.KnotVector.a;
          const controlPoints = [];
          const pointsValues = geoNode.Points.a;
          for (let i = 0, l = pointsValues.length; i < l; i += 4) {
            controlPoints.push(new THREE2.Vector4().fromArray(pointsValues, i));
          }
          let startKnot, endKnot;
          if (geoNode.Form === "Closed") {
            controlPoints.push(controlPoints[0]);
          } else if (geoNode.Form === "Periodic") {
            startKnot = degree;
            endKnot = knots.length - 1 - startKnot;
            for (let i = 0; i < degree; ++i) {
              controlPoints.push(controlPoints[i]);
            }
          }
          const curve = new THREE2.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
          const points = curve.getPoints(controlPoints.length * 12);
          return new THREE2.BufferGeometry().setFromPoints(points);
        }
      }
      class AnimationParser {
        // take raw animation clips and turn them into three.js animation clips
        parse() {
          const animationClips = [];
          const rawClips = this.parseClips();
          if (rawClips !== void 0) {
            for (const key in rawClips) {
              const rawClip = rawClips[key];
              const clip = this.addClip(rawClip);
              animationClips.push(clip);
            }
          }
          return animationClips;
        }
        parseClips() {
          if (fbxTree.Objects.AnimationCurve === void 0)
            return void 0;
          const curveNodesMap = this.parseAnimationCurveNodes();
          this.parseAnimationCurves(curveNodesMap);
          const layersMap = this.parseAnimationLayers(curveNodesMap);
          const rawClips = this.parseAnimStacks(layersMap);
          return rawClips;
        }
        // parse nodes in FBXTree.Objects.AnimationCurveNode
        // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
        // and is referenced by an AnimationLayer
        parseAnimationCurveNodes() {
          const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
          const curveNodesMap = /* @__PURE__ */ new Map();
          for (const nodeID in rawCurveNodes) {
            const rawCurveNode = rawCurveNodes[nodeID];
            if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
              const curveNode = {
                id: rawCurveNode.id,
                attr: rawCurveNode.attrName,
                curves: {}
              };
              curveNodesMap.set(curveNode.id, curveNode);
            }
          }
          return curveNodesMap;
        }
        // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
        // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
        // axis ( e.g. times and values of x rotation)
        parseAnimationCurves(curveNodesMap) {
          const rawCurves = fbxTree.Objects.AnimationCurve;
          for (const nodeID in rawCurves) {
            const animationCurve = {
              id: rawCurves[nodeID].id,
              times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
              values: rawCurves[nodeID].KeyValueFloat.a
            };
            const relationships = connections.get(animationCurve.id);
            if (relationships !== void 0) {
              const animationCurveID = relationships.parents[0].ID;
              const animationCurveRelationship = relationships.parents[0].relationship;
              if (animationCurveRelationship.match(/X/)) {
                curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
              } else if (animationCurveRelationship.match(/Y/)) {
                curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
              } else if (animationCurveRelationship.match(/Z/)) {
                curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
              } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
                curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
              }
            }
          }
        }
        // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
        // to various AnimationCurveNodes and is referenced by an AnimationStack node
        // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
        parseAnimationLayers(curveNodesMap) {
          const rawLayers = fbxTree.Objects.AnimationLayer;
          const layersMap = /* @__PURE__ */ new Map();
          for (const nodeID in rawLayers) {
            const layerCurveNodes = [];
            const connection = connections.get(parseInt(nodeID));
            if (connection !== void 0) {
              const children = connection.children;
              children.forEach(function(child, i) {
                if (curveNodesMap.has(child.ID)) {
                  const curveNode = curveNodesMap.get(child.ID);
                  if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
                    if (layerCurveNodes[i] === void 0) {
                      const modelID = connections.get(child.ID).parents.filter(function(parent) {
                        return parent.relationship !== void 0;
                      })[0].ID;
                      if (modelID !== void 0) {
                        const rawModel = fbxTree.Objects.Model[modelID.toString()];
                        if (rawModel === void 0) {
                          console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                          return;
                        }
                        const node = {
                          modelName: rawModel.attrName ? THREE2.PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                          ID: rawModel.id,
                          initialPosition: [0, 0, 0],
                          initialRotation: [0, 0, 0],
                          initialScale: [1, 1, 1]
                        };
                        sceneGraph.traverse(function(child2) {
                          if (child2.ID === rawModel.id) {
                            node.transform = child2.matrix;
                            if (child2.userData.transformData)
                              node.eulerOrder = child2.userData.transformData.eulerOrder;
                          }
                        });
                        if (!node.transform)
                          node.transform = new THREE2.Matrix4();
                        if ("PreRotation" in rawModel)
                          node.preRotation = rawModel.PreRotation.value;
                        if ("PostRotation" in rawModel)
                          node.postRotation = rawModel.PostRotation.value;
                        layerCurveNodes[i] = node;
                      }
                    }
                    if (layerCurveNodes[i])
                      layerCurveNodes[i][curveNode.attr] = curveNode;
                  } else if (curveNode.curves.morph !== void 0) {
                    if (layerCurveNodes[i] === void 0) {
                      const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                        return parent.relationship !== void 0;
                      })[0].ID;
                      const morpherID = connections.get(deformerID).parents[0].ID;
                      const geoID = connections.get(morpherID).parents[0].ID;
                      const modelID = connections.get(geoID).parents[0].ID;
                      const rawModel = fbxTree.Objects.Model[modelID];
                      const node = {
                        modelName: rawModel.attrName ? THREE2.PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                        morphName: fbxTree.Objects.Deformer[deformerID].attrName
                      };
                      layerCurveNodes[i] = node;
                    }
                    layerCurveNodes[i][curveNode.attr] = curveNode;
                  }
                }
              });
              layersMap.set(parseInt(nodeID), layerCurveNodes);
            }
          }
          return layersMap;
        }
        // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
        // hierarchy. Each Stack node will be used to create a THREE.AnimationClip
        parseAnimStacks(layersMap) {
          const rawStacks = fbxTree.Objects.AnimationStack;
          const rawClips = {};
          for (const nodeID in rawStacks) {
            const children = connections.get(parseInt(nodeID)).children;
            if (children.length > 1) {
              console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            }
            const layer = layersMap.get(children[0].ID);
            rawClips[nodeID] = {
              name: rawStacks[nodeID].attrName,
              layer
            };
          }
          return rawClips;
        }
        addClip(rawClip) {
          let tracks = [];
          const scope = this;
          rawClip.layer.forEach(function(rawTracks) {
            tracks = tracks.concat(scope.generateTracks(rawTracks));
          });
          return new THREE2.AnimationClip(rawClip.name, -1, tracks);
        }
        generateTracks(rawTracks) {
          const tracks = [];
          let initialPosition = new THREE2.Vector3();
          let initialRotation = new THREE2.Quaternion();
          let initialScale = new THREE2.Vector3();
          if (rawTracks.transform)
            rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
          initialPosition = initialPosition.toArray();
          initialRotation = new THREE2.Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
          initialScale = initialScale.toArray();
          if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
            const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
            if (positionTrack !== void 0)
              tracks.push(positionTrack);
          }
          if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
            const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
            if (rotationTrack !== void 0)
              tracks.push(rotationTrack);
          }
          if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
            const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
            if (scaleTrack !== void 0)
              tracks.push(scaleTrack);
          }
          if (rawTracks.DeformPercent !== void 0) {
            const morphTrack = this.generateMorphTrack(rawTracks);
            if (morphTrack !== void 0)
              tracks.push(morphTrack);
          }
          return tracks;
        }
        generateVectorTrack(modelName, curves, initialValue, type) {
          const times = this.getTimesForAllAxes(curves);
          const values = this.getKeyframeTrackValues(times, curves, initialValue);
          return new THREE2.VectorKeyframeTrack(modelName + "." + type, times, values);
        }
        generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
          if (curves.x !== void 0) {
            this.interpolateRotations(curves.x);
            curves.x.values = curves.x.values.map(THREE2.MathUtils.degToRad);
          }
          if (curves.y !== void 0) {
            this.interpolateRotations(curves.y);
            curves.y.values = curves.y.values.map(THREE2.MathUtils.degToRad);
          }
          if (curves.z !== void 0) {
            this.interpolateRotations(curves.z);
            curves.z.values = curves.z.values.map(THREE2.MathUtils.degToRad);
          }
          const times = this.getTimesForAllAxes(curves);
          const values = this.getKeyframeTrackValues(times, curves, initialValue);
          if (preRotation !== void 0) {
            preRotation = preRotation.map(THREE2.MathUtils.degToRad);
            preRotation.push(eulerOrder);
            preRotation = new THREE2.Euler().fromArray(preRotation);
            preRotation = new THREE2.Quaternion().setFromEuler(preRotation);
          }
          if (postRotation !== void 0) {
            postRotation = postRotation.map(THREE2.MathUtils.degToRad);
            postRotation.push(eulerOrder);
            postRotation = new THREE2.Euler().fromArray(postRotation);
            postRotation = new THREE2.Quaternion().setFromEuler(postRotation).invert();
          }
          const quaternion = new THREE2.Quaternion();
          const euler = new THREE2.Euler();
          const quaternionValues = [];
          for (let i = 0; i < values.length; i += 3) {
            euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
            quaternion.setFromEuler(euler);
            if (preRotation !== void 0)
              quaternion.premultiply(preRotation);
            if (postRotation !== void 0)
              quaternion.multiply(postRotation);
            quaternion.toArray(quaternionValues, i / 3 * 4);
          }
          return new THREE2.QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
        }
        generateMorphTrack(rawTracks) {
          const curves = rawTracks.DeformPercent.curves.morph;
          const values = curves.values.map(function(val) {
            return val / 100;
          });
          const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
          return new THREE2.NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
        }
        // For all animated objects, times are defined separately for each axis
        // Here we'll combine the times into one sorted array without duplicates
        getTimesForAllAxes(curves) {
          let times = [];
          if (curves.x !== void 0)
            times = times.concat(curves.x.times);
          if (curves.y !== void 0)
            times = times.concat(curves.y.times);
          if (curves.z !== void 0)
            times = times.concat(curves.z.times);
          times = times.sort(function(a, b) {
            return a - b;
          });
          if (times.length > 1) {
            let targetIndex = 1;
            let lastValue = times[0];
            for (let i = 1; i < times.length; i++) {
              const currentValue = times[i];
              if (currentValue !== lastValue) {
                times[targetIndex] = currentValue;
                lastValue = currentValue;
                targetIndex++;
              }
            }
            times = times.slice(0, targetIndex);
          }
          return times;
        }
        getKeyframeTrackValues(times, curves, initialValue) {
          const prevValue = initialValue;
          const values = [];
          let xIndex = -1;
          let yIndex = -1;
          let zIndex = -1;
          times.forEach(function(time) {
            if (curves.x)
              xIndex = curves.x.times.indexOf(time);
            if (curves.y)
              yIndex = curves.y.times.indexOf(time);
            if (curves.z)
              zIndex = curves.z.times.indexOf(time);
            if (xIndex !== -1) {
              const xValue = curves.x.values[xIndex];
              values.push(xValue);
              prevValue[0] = xValue;
            } else {
              values.push(prevValue[0]);
            }
            if (yIndex !== -1) {
              const yValue = curves.y.values[yIndex];
              values.push(yValue);
              prevValue[1] = yValue;
            } else {
              values.push(prevValue[1]);
            }
            if (zIndex !== -1) {
              const zValue = curves.z.values[zIndex];
              values.push(zValue);
              prevValue[2] = zValue;
            } else {
              values.push(prevValue[2]);
            }
          });
          return values;
        }
        // Rotations are defined as THREE.Euler angles which can have values  of any size
        // These will be converted to quaternions which don't support values greater than
        // PI, so we'll interpolate large rotations
        interpolateRotations(curve) {
          for (let i = 1; i < curve.values.length; i++) {
            const initialValue = curve.values[i - 1];
            const valuesSpan = curve.values[i] - initialValue;
            const absoluteSpan = Math.abs(valuesSpan);
            if (absoluteSpan >= 180) {
              const numSubIntervals = absoluteSpan / 180;
              const step = valuesSpan / numSubIntervals;
              let nextValue = initialValue + step;
              const initialTime = curve.times[i - 1];
              const timeSpan = curve.times[i] - initialTime;
              const interval = timeSpan / numSubIntervals;
              let nextTime = initialTime + interval;
              const interpolatedTimes = [];
              const interpolatedValues = [];
              while (nextTime < curve.times[i]) {
                interpolatedTimes.push(nextTime);
                nextTime += interval;
                interpolatedValues.push(nextValue);
                nextValue += step;
              }
              curve.times = inject(curve.times, i, interpolatedTimes);
              curve.values = inject(curve.values, i, interpolatedValues);
            }
          }
        }
      }
      class TextParser {
        getPrevNode() {
          return this.nodeStack[this.currentIndent - 2];
        }
        getCurrentNode() {
          return this.nodeStack[this.currentIndent - 1];
        }
        getCurrentProp() {
          return this.currentProp;
        }
        pushStack(node) {
          this.nodeStack.push(node);
          this.currentIndent += 1;
        }
        popStack() {
          this.nodeStack.pop();
          this.currentIndent -= 1;
        }
        setCurrentProp(val, name) {
          this.currentProp = val;
          this.currentPropName = name;
        }
        parse(text) {
          this.currentIndent = 0;
          this.allNodes = new FBXTree();
          this.nodeStack = [];
          this.currentProp = [];
          this.currentPropName = "";
          const scope = this;
          const split = text.split(/[\r\n]+/);
          split.forEach(function(line, i) {
            const matchComment = line.match(/^[\s\t]*;/);
            const matchEmpty = line.match(/^[\s\t]*$/);
            if (matchComment || matchEmpty)
              return;
            const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
            const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
            const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
            if (matchBeginning) {
              scope.parseNodeBegin(line, matchBeginning);
            } else if (matchProperty) {
              scope.parseNodeProperty(line, matchProperty, split[++i]);
            } else if (matchEnd) {
              scope.popStack();
            } else if (line.match(/^[^\s\t}]/)) {
              scope.parseNodePropertyContinued(line);
            }
          });
          return this.allNodes;
        }
        parseNodeBegin(line, property) {
          const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
          const nodeAttrs = property[2].split(",").map(function(attr) {
            return attr.trim().replace(/^"/, "").replace(/"$/, "");
          });
          const node = {
            name: nodeName
          };
          const attrs = this.parseNodeAttr(nodeAttrs);
          const currentNode = this.getCurrentNode();
          if (this.currentIndent === 0) {
            this.allNodes.add(nodeName, node);
          } else {
            if (nodeName in currentNode) {
              if (nodeName === "PoseNode") {
                currentNode.PoseNode.push(node);
              } else if (currentNode[nodeName].id !== void 0) {
                currentNode[nodeName] = {};
                currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
              }
              if (attrs.id !== "")
                currentNode[nodeName][attrs.id] = node;
            } else if (typeof attrs.id === "number") {
              currentNode[nodeName] = {};
              currentNode[nodeName][attrs.id] = node;
            } else if (nodeName !== "Properties70") {
              if (nodeName === "PoseNode")
                currentNode[nodeName] = [node];
              else
                currentNode[nodeName] = node;
            }
          }
          if (typeof attrs.id === "number")
            node.id = attrs.id;
          if (attrs.name !== "")
            node.attrName = attrs.name;
          if (attrs.type !== "")
            node.attrType = attrs.type;
          this.pushStack(node);
        }
        parseNodeAttr(attrs) {
          let id = attrs[0];
          if (attrs[0] !== "") {
            id = parseInt(attrs[0]);
            if (isNaN(id)) {
              id = attrs[0];
            }
          }
          let name = "", type = "";
          if (attrs.length > 1) {
            name = attrs[1].replace(/^(\w+)::/, "");
            type = attrs[2];
          }
          return {
            id,
            name,
            type
          };
        }
        parseNodeProperty(line, property, contentLine) {
          let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
          let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
          if (propName === "Content" && propValue === ",") {
            propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
          }
          const currentNode = this.getCurrentNode();
          const parentName = currentNode.name;
          if (parentName === "Properties70") {
            this.parseNodeSpecialProperty(line, propName, propValue);
            return;
          }
          if (propName === "C") {
            const connProps = propValue.split(",").slice(1);
            const from = parseInt(connProps[0]);
            const to = parseInt(connProps[1]);
            let rest = propValue.split(",").slice(3);
            rest = rest.map(function(elem) {
              return elem.trim().replace(/^"/, "");
            });
            propName = "connections";
            propValue = [from, to];
            append(propValue, rest);
            if (currentNode[propName] === void 0) {
              currentNode[propName] = [];
            }
          }
          if (propName === "Node")
            currentNode.id = propValue;
          if (propName in currentNode && Array.isArray(currentNode[propName])) {
            currentNode[propName].push(propValue);
          } else {
            if (propName !== "a")
              currentNode[propName] = propValue;
            else
              currentNode.a = propValue;
          }
          this.setCurrentProp(currentNode, propName);
          if (propName === "a" && propValue.slice(-1) !== ",") {
            currentNode.a = parseNumberArray(propValue);
          }
        }
        parseNodePropertyContinued(line) {
          const currentNode = this.getCurrentNode();
          currentNode.a += line;
          if (line.slice(-1) !== ",") {
            currentNode.a = parseNumberArray(currentNode.a);
          }
        }
        // parse "Property70"
        parseNodeSpecialProperty(line, propName, propValue) {
          const props = propValue.split('",').map(function(prop) {
            return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
          });
          const innerPropName = props[0];
          const innerPropType1 = props[1];
          const innerPropType2 = props[2];
          const innerPropFlag = props[3];
          let innerPropValue = props[4];
          switch (innerPropType1) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
              innerPropValue = parseFloat(innerPropValue);
              break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
              innerPropValue = parseNumberArray(innerPropValue);
              break;
          }
          this.getPrevNode()[innerPropName] = {
            "type": innerPropType1,
            "type2": innerPropType2,
            "flag": innerPropFlag,
            "value": innerPropValue
          };
          this.setCurrentProp(this.getPrevNode(), innerPropName);
        }
      }
      class BinaryParser {
        parse(buffer) {
          const reader = new BinaryReader(buffer);
          reader.skip(23);
          const version = reader.getUint32();
          if (version < 6400) {
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
          }
          const allNodes = new FBXTree();
          while (!this.endOfContent(reader)) {
            const node = this.parseNode(reader, version);
            if (node !== null)
              allNodes.add(node.name, node);
          }
          return allNodes;
        }
        // Check if reader has reached the end of content.
        endOfContent(reader) {
          if (reader.size() % 16 === 0) {
            return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
          } else {
            return reader.getOffset() + 160 + 16 >= reader.size();
          }
        }
        // recursively parse nodes until the end of the file is reached
        parseNode(reader, version) {
          const node = {};
          const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
          const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
          version >= 7500 ? reader.getUint64() : reader.getUint32();
          const nameLen = reader.getUint8();
          const name = reader.getString(nameLen);
          if (endOffset === 0)
            return null;
          const propertyList = [];
          for (let i = 0; i < numProperties; i++) {
            propertyList.push(this.parseProperty(reader));
          }
          const id = propertyList.length > 0 ? propertyList[0] : "";
          const attrName = propertyList.length > 1 ? propertyList[1] : "";
          const attrType = propertyList.length > 2 ? propertyList[2] : "";
          node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
          while (endOffset > reader.getOffset()) {
            const subNode = this.parseNode(reader, version);
            if (subNode !== null)
              this.parseSubNode(name, node, subNode);
          }
          node.propertyList = propertyList;
          if (typeof id === "number")
            node.id = id;
          if (attrName !== "")
            node.attrName = attrName;
          if (attrType !== "")
            node.attrType = attrType;
          if (name !== "")
            node.name = name;
          return node;
        }
        parseSubNode(name, node, subNode) {
          if (subNode.singleProperty === true) {
            const value = subNode.propertyList[0];
            if (Array.isArray(value)) {
              node[subNode.name] = subNode;
              subNode.a = value;
            } else {
              node[subNode.name] = value;
            }
          } else if (name === "Connections" && subNode.name === "C") {
            const array = [];
            subNode.propertyList.forEach(function(property, i) {
              if (i !== 0)
                array.push(property);
            });
            if (node.connections === void 0) {
              node.connections = [];
            }
            node.connections.push(array);
          } else if (subNode.name === "Properties70") {
            const keys = Object.keys(subNode);
            keys.forEach(function(key) {
              node[key] = subNode[key];
            });
          } else if (name === "Properties70" && subNode.name === "P") {
            let innerPropName = subNode.propertyList[0];
            let innerPropType1 = subNode.propertyList[1];
            const innerPropType2 = subNode.propertyList[2];
            const innerPropFlag = subNode.propertyList[3];
            let innerPropValue;
            if (innerPropName.indexOf("Lcl ") === 0)
              innerPropName = innerPropName.replace("Lcl ", "Lcl_");
            if (innerPropType1.indexOf("Lcl ") === 0)
              innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
            if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
              innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];
            } else {
              innerPropValue = subNode.propertyList[4];
            }
            node[innerPropName] = {
              "type": innerPropType1,
              "type2": innerPropType2,
              "flag": innerPropFlag,
              "value": innerPropValue
            };
          } else if (node[subNode.name] === void 0) {
            if (typeof subNode.id === "number") {
              node[subNode.name] = {};
              node[subNode.name][subNode.id] = subNode;
            } else {
              node[subNode.name] = subNode;
            }
          } else {
            if (subNode.name === "PoseNode") {
              if (!Array.isArray(node[subNode.name])) {
                node[subNode.name] = [node[subNode.name]];
              }
              node[subNode.name].push(subNode);
            } else if (node[subNode.name][subNode.id] === void 0) {
              node[subNode.name][subNode.id] = subNode;
            }
          }
        }
        parseProperty(reader) {
          const type = reader.getString(1);
          let length;
          switch (type) {
            case "C":
              return reader.getBoolean();
            case "D":
              return reader.getFloat64();
            case "F":
              return reader.getFloat32();
            case "I":
              return reader.getInt32();
            case "L":
              return reader.getInt64();
            case "R":
              length = reader.getUint32();
              return reader.getArrayBuffer(length);
            case "S":
              length = reader.getUint32();
              return reader.getString(length);
            case "Y":
              return reader.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
              const arrayLength = reader.getUint32();
              const encoding = reader.getUint32();
              const compressedLength = reader.getUint32();
              if (encoding === 0) {
                switch (type) {
                  case "b":
                  case "c":
                    return reader.getBooleanArray(arrayLength);
                  case "d":
                    return reader.getFloat64Array(arrayLength);
                  case "f":
                    return reader.getFloat32Array(arrayLength);
                  case "i":
                    return reader.getInt32Array(arrayLength);
                  case "l":
                    return reader.getInt64Array(arrayLength);
                }
              }
              if (typeof fflate === "undefined") {
                console.error("THREE.FBXLoader: External library fflate.min.js required.");
              }
              const data = fflate.unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
              const reader2 = new BinaryReader(data.buffer);
              switch (type) {
                case "b":
                case "c":
                  return reader2.getBooleanArray(arrayLength);
                case "d":
                  return reader2.getFloat64Array(arrayLength);
                case "f":
                  return reader2.getFloat32Array(arrayLength);
                case "i":
                  return reader2.getInt32Array(arrayLength);
                case "l":
                  return reader2.getInt64Array(arrayLength);
              }
            default:
              throw new Error("THREE.FBXLoader: Unknown property type " + type);
          }
        }
      }
      class BinaryReader {
        constructor(buffer, littleEndian) {
          this.dv = new DataView(buffer);
          this.offset = 0;
          this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
        }
        getOffset() {
          return this.offset;
        }
        size() {
          return this.dv.buffer.byteLength;
        }
        skip(length) {
          this.offset += length;
        }
        // seems like true/false representation depends on exporter.
        // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
        // then sees LSB.
        getBoolean() {
          return (this.getUint8() & 1) === 1;
        }
        getBooleanArray(size) {
          const a = [];
          for (let i = 0; i < size; i++) {
            a.push(this.getBoolean());
          }
          return a;
        }
        getUint8() {
          const value = this.dv.getUint8(this.offset);
          this.offset += 1;
          return value;
        }
        getInt16() {
          const value = this.dv.getInt16(this.offset, this.littleEndian);
          this.offset += 2;
          return value;
        }
        getInt32() {
          const value = this.dv.getInt32(this.offset, this.littleEndian);
          this.offset += 4;
          return value;
        }
        getInt32Array(size) {
          const a = [];
          for (let i = 0; i < size; i++) {
            a.push(this.getInt32());
          }
          return a;
        }
        getUint32() {
          const value = this.dv.getUint32(this.offset, this.littleEndian);
          this.offset += 4;
          return value;
        }
        // JavaScript doesn't support 64-bit integer so calculate this here
        // 1 << 32 will return 1 so using multiply operation instead here.
        // There's a possibility that this method returns wrong value if the value
        // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
        // TODO: safely handle 64-bit integer
        getInt64() {
          let low, high;
          if (this.littleEndian) {
            low = this.getUint32();
            high = this.getUint32();
          } else {
            high = this.getUint32();
            low = this.getUint32();
          }
          if (high & 2147483648) {
            high = ~high & 4294967295;
            low = ~low & 4294967295;
            if (low === 4294967295)
              high = high + 1 & 4294967295;
            low = low + 1 & 4294967295;
            return -(high * 4294967296 + low);
          }
          return high * 4294967296 + low;
        }
        getInt64Array(size) {
          const a = [];
          for (let i = 0; i < size; i++) {
            a.push(this.getInt64());
          }
          return a;
        }
        // Note: see getInt64() comment
        getUint64() {
          let low, high;
          if (this.littleEndian) {
            low = this.getUint32();
            high = this.getUint32();
          } else {
            high = this.getUint32();
            low = this.getUint32();
          }
          return high * 4294967296 + low;
        }
        getFloat32() {
          const value = this.dv.getFloat32(this.offset, this.littleEndian);
          this.offset += 4;
          return value;
        }
        getFloat32Array(size) {
          const a = [];
          for (let i = 0; i < size; i++) {
            a.push(this.getFloat32());
          }
          return a;
        }
        getFloat64() {
          const value = this.dv.getFloat64(this.offset, this.littleEndian);
          this.offset += 8;
          return value;
        }
        getFloat64Array(size) {
          const a = [];
          for (let i = 0; i < size; i++) {
            a.push(this.getFloat64());
          }
          return a;
        }
        getArrayBuffer(size) {
          const value = this.dv.buffer.slice(this.offset, this.offset + size);
          this.offset += size;
          return value;
        }
        getString(size) {
          let a = [];
          for (let i = 0; i < size; i++) {
            a[i] = this.getUint8();
          }
          const nullByte = a.indexOf(0);
          if (nullByte >= 0)
            a = a.slice(0, nullByte);
          return THREE2.LoaderUtils.decodeText(new Uint8Array(a));
        }
      }
      class FBXTree {
        add(key, val) {
          this[key] = val;
        }
      }
      function isFbxFormatBinary(buffer) {
        const CORRECT = "Kaydara FBX Binary  \0";
        return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
      }
      function isFbxFormatASCII(text) {
        const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
        let cursor = 0;
        function read(offset) {
          const result = text[offset - 1];
          text = text.slice(cursor + offset);
          cursor++;
          return result;
        }
        for (let i = 0; i < CORRECT.length; ++i) {
          const num = read(1);
          if (num === CORRECT[i]) {
            return false;
          }
        }
        return true;
      }
      function getFbxVersion(text) {
        const versionRegExp = /FBXVersion: (\d+)/;
        const match = text.match(versionRegExp);
        if (match) {
          const version = parseInt(match[1]);
          return version;
        }
        throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
      }
      function convertFBXTimeToSeconds(time) {
        return time / 46186158e3;
      }
      const dataArray = [];
      function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
        let index;
        switch (infoObject.mappingType) {
          case "ByPolygonVertex":
            index = polygonVertexIndex;
            break;
          case "ByPolygon":
            index = polygonIndex;
            break;
          case "ByVertice":
            index = vertexIndex;
            break;
          case "AllSame":
            index = infoObject.indices[0];
            break;
          default:
            console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
        }
        if (infoObject.referenceType === "IndexToDirect")
          index = infoObject.indices[index];
        const from = index * infoObject.dataSize;
        const to = from + infoObject.dataSize;
        return slice(dataArray, infoObject.buffer, from, to);
      }
      const tempEuler = new THREE2.Euler();
      const tempVec = new THREE2.Vector3();
      function generateTransform(transformData) {
        const lTranslationM = new THREE2.Matrix4();
        const lPreRotationM = new THREE2.Matrix4();
        const lRotationM = new THREE2.Matrix4();
        const lPostRotationM = new THREE2.Matrix4();
        const lScalingM = new THREE2.Matrix4();
        const lScalingPivotM = new THREE2.Matrix4();
        const lScalingOffsetM = new THREE2.Matrix4();
        const lRotationOffsetM = new THREE2.Matrix4();
        const lRotationPivotM = new THREE2.Matrix4();
        const lParentGX = new THREE2.Matrix4();
        const lParentLX = new THREE2.Matrix4();
        const lGlobalT = new THREE2.Matrix4();
        const inheritType = transformData.inheritType ? transformData.inheritType : 0;
        if (transformData.translation)
          lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
        if (transformData.preRotation) {
          const array = transformData.preRotation.map(THREE2.MathUtils.degToRad);
          array.push(transformData.eulerOrder);
          lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
        }
        if (transformData.rotation) {
          const array = transformData.rotation.map(THREE2.MathUtils.degToRad);
          array.push(transformData.eulerOrder);
          lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
        }
        if (transformData.postRotation) {
          const array = transformData.postRotation.map(THREE2.MathUtils.degToRad);
          array.push(transformData.eulerOrder);
          lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
          lPostRotationM.invert();
        }
        if (transformData.scale)
          lScalingM.scale(tempVec.fromArray(transformData.scale));
        if (transformData.scalingOffset)
          lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
        if (transformData.scalingPivot)
          lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
        if (transformData.rotationOffset)
          lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
        if (transformData.rotationPivot)
          lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
        if (transformData.parentMatrixWorld) {
          lParentLX.copy(transformData.parentMatrix);
          lParentGX.copy(transformData.parentMatrixWorld);
        }
        const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
        const lParentGRM = new THREE2.Matrix4();
        lParentGRM.extractRotation(lParentGX);
        const lParentTM = new THREE2.Matrix4();
        lParentTM.copyPosition(lParentGX);
        const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
        const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
        const lLSM = lScalingM;
        const lGlobalRS = new THREE2.Matrix4();
        if (inheritType === 0) {
          lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
        } else if (inheritType === 1) {
          lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
        } else {
          const lParentLSM = new THREE2.Matrix4().scale(new THREE2.Vector3().setFromMatrixScale(lParentLX));
          const lParentLSM_inv = lParentLSM.clone().invert();
          const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
          lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
        }
        const lRotationPivotM_inv = lRotationPivotM.clone().invert();
        const lScalingPivotM_inv = lScalingPivotM.clone().invert();
        let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
        const lLocalTWithAllPivotAndOffsetInfo = new THREE2.Matrix4().copyPosition(lTransform);
        const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
        lGlobalT.copyPosition(lGlobalTranslation);
        lTransform = lGlobalT.clone().multiply(lGlobalRS);
        lTransform.premultiply(lParentGX.invert());
        return lTransform;
      }
      function getEulerOrder(order) {
        order = order || 0;
        const enums = [
          "ZYX",
          // -> XYZ extrinsic
          "YZX",
          // -> XZY extrinsic
          "XZY",
          // -> YZX extrinsic
          "ZXY",
          // -> YXZ extrinsic
          "YXZ",
          // -> ZXY extrinsic
          "XYZ"
          // -> ZYX extrinsic
          //'SphericXYZ', // not possible to support
        ];
        if (order === 6) {
          console.warn("THREE.FBXLoader: unsupported THREE.Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
          return enums[0];
        }
        return enums[order];
      }
      function parseNumberArray(value) {
        const array = value.split(",").map(function(val) {
          return parseFloat(val);
        });
        return array;
      }
      function convertArrayBufferToString(buffer, from, to) {
        if (from === void 0)
          from = 0;
        if (to === void 0)
          to = buffer.byteLength;
        return THREE2.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));
      }
      function append(a, b) {
        for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {
          a[j] = b[i];
        }
      }
      function slice(a, b, from, to) {
        for (let i = from, j = 0; i < to; i++, j++) {
          a[j] = b[i];
        }
        return a;
      }
      function inject(a1, index, a2) {
        return a1.slice(0, index).concat(a2).concat(a1.slice(index));
      }
      THREE2.FBXLoader = FBXLoader;
    })();
    module.exports = exports = THREE2.FBXLoader;
  }
});

// node_modules/threebox-plugin/src/objects/loaders/GLTFLoader.js
var require_GLTFLoader = __commonJS({
  "node_modules/threebox-plugin/src/objects/loaders/GLTFLoader.js"(exports, module) {
    var THREE2 = require_three();
    (function() {
      class GLTFLoader extends THREE2.Loader {
        constructor(manager) {
          super(manager);
          this.dracoLoader = null;
          this.ktx2Loader = null;
          this.meshoptDecoder = null;
          this.pluginCallbacks = [];
          this.register(function(parser) {
            return new GLTFMaterialsClearcoatExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFTextureBasisUExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFTextureWebPExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsTransmissionExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsVolumeExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsIorExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMaterialsSpecularExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFLightsExtension(parser);
          });
          this.register(function(parser) {
            return new GLTFMeshoptCompression(parser);
          });
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          let resourcePath;
          if (this.resourcePath !== "") {
            resourcePath = this.resourcePath;
          } else if (this.path !== "") {
            resourcePath = this.path;
          } else {
            resourcePath = THREE2.LoaderUtils.extractUrlBase(url);
          }
          this.manager.itemStart(url);
          const _onError = function(e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          };
          const loader = new THREE2.FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setResponseType("arraybuffer");
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          loader.load(url, function(data) {
            try {
              scope.parse(data, resourcePath, function(gltf) {
                onLoad(gltf);
                scope.manager.itemEnd(url);
              }, _onError);
            } catch (e) {
              _onError(e);
            }
          }, onProgress, _onError);
        }
        setDRACOLoader(dracoLoader) {
          this.dracoLoader = dracoLoader;
          return this;
        }
        setDDSLoader() {
          throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
        }
        setKTX2Loader(ktx2Loader) {
          this.ktx2Loader = ktx2Loader;
          return this;
        }
        setMeshoptDecoder(meshoptDecoder) {
          this.meshoptDecoder = meshoptDecoder;
          return this;
        }
        register(callback) {
          if (this.pluginCallbacks.indexOf(callback) === -1) {
            this.pluginCallbacks.push(callback);
          }
          return this;
        }
        unregister(callback) {
          if (this.pluginCallbacks.indexOf(callback) !== -1) {
            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
          }
          return this;
        }
        parse(data, path, onLoad, onError) {
          let content;
          const extensions = {};
          const plugins = {};
          if (typeof data === "string") {
            content = data;
          } else {
            const magic = THREE2.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
              try {
                extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
              } catch (error) {
                if (onError)
                  onError(error);
                return;
              }
              content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
            } else {
              content = THREE2.LoaderUtils.decodeText(new Uint8Array(data));
            }
          }
          const json = JSON.parse(content);
          if (json.asset === void 0 || json.asset.version[0] < 2) {
            if (onError)
              onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
          }
          const parser = new GLTFParser(json, {
            path: path || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
          });
          parser.fileLoader.setRequestHeader(this.requestHeader);
          for (let i = 0; i < this.pluginCallbacks.length; i++) {
            const plugin = this.pluginCallbacks[i](parser);
            plugins[plugin.name] = plugin;
            extensions[plugin.name] = true;
          }
          if (json.extensionsUsed) {
            for (let i = 0; i < json.extensionsUsed.length; ++i) {
              const extensionName = json.extensionsUsed[i];
              const extensionsRequired = json.extensionsRequired || [];
              switch (extensionName) {
                case EXTENSIONS.KHR_MATERIALS_UNLIT:
                  extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                  break;
                case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                  break;
                case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                  extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                  break;
                case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                  extensions[extensionName] = new GLTFTextureTransformExtension();
                  break;
                case EXTENSIONS.KHR_MESH_QUANTIZATION:
                  extensions[extensionName] = new GLTFMeshQuantizationExtension();
                  break;
                default:
                  if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                    console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
                  }
              }
            }
          }
          parser.setExtensions(extensions);
          parser.setPlugins(plugins);
          parser.parse(onLoad, onError);
        }
      }
      function GLTFRegistry() {
        let objects = {};
        return {
          get: function(key) {
            return objects[key];
          },
          add: function(key, object) {
            objects[key] = object;
          },
          remove: function(key) {
            delete objects[key];
          },
          removeAll: function() {
            objects = {};
          }
        };
      }
      const EXTENSIONS = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
      };
      class GLTFLightsExtension {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
          this.cache = {
            refs: {},
            uses: {}
          };
        }
        _markDefs() {
          const parser = this.parser;
          const nodeDefs = this.parser.json.nodes || [];
          for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
            const nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
              parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
            }
          }
        }
        _loadLight(lightIndex) {
          const parser = this.parser;
          const cacheKey = "light:" + lightIndex;
          let dependency = parser.cache.get(cacheKey);
          if (dependency)
            return dependency;
          const json = parser.json;
          const extensions = json.extensions && json.extensions[this.name] || {};
          const lightDefs = extensions.lights || [];
          const lightDef = lightDefs[lightIndex];
          let lightNode;
          const color = new THREE2.Color(16777215);
          if (lightDef.color !== void 0)
            color.fromArray(lightDef.color);
          const range = lightDef.range !== void 0 ? lightDef.range : 0;
          switch (lightDef.type) {
            case "directional":
              lightNode = new THREE2.DirectionalLight(color);
              lightNode.target.position.set(0, 0, -1);
              lightNode.add(lightNode.target);
              break;
            case "point":
              lightNode = new THREE2.PointLight(color);
              lightNode.distance = range;
              break;
            case "spot":
              lightNode = new THREE2.SpotLight(color);
              lightNode.distance = range;
              lightDef.spot = lightDef.spot || {};
              lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
              lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
              lightNode.angle = lightDef.spot.outerConeAngle;
              lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
              lightNode.target.position.set(0, 0, -1);
              lightNode.add(lightNode.target);
              break;
            default:
              throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
          }
          lightNode.position.set(0, 0, 0);
          lightNode.decay = 2;
          if (lightDef.intensity !== void 0)
            lightNode.intensity = lightDef.intensity;
          lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
          dependency = Promise.resolve(lightNode);
          parser.cache.add(cacheKey, dependency);
          return dependency;
        }
        createNodeAttachment(nodeIndex) {
          const self2 = this;
          const parser = this.parser;
          const json = parser.json;
          const nodeDef = json.nodes[nodeIndex];
          const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
          const lightIndex = lightDef.light;
          if (lightIndex === void 0)
            return null;
          return this._loadLight(lightIndex).then(function(light) {
            return parser._getNodeRef(self2.cache, lightIndex, light);
          });
        }
      }
      class GLTFMaterialsUnlitExtension {
        constructor() {
          this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return THREE2.MeshBasicMaterial;
        }
        extendParams(materialParams, materialDef, parser) {
          const pending = [];
          materialParams.color = new THREE2.Color(1, 1, 1);
          materialParams.opacity = 1;
          const metallicRoughness = materialDef.pbrMetallicRoughness;
          if (metallicRoughness) {
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
              const array = metallicRoughness.baseColorFactor;
              materialParams.color.fromArray(array);
              materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
            }
          }
          return Promise.all(pending);
        }
      }
      class GLTFMaterialsClearcoatExtension {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return THREE2.MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          if (extension.clearcoatFactor !== void 0) {
            materialParams.clearcoat = extension.clearcoatFactor;
          }
          if (extension.clearcoatTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
          }
          if (extension.clearcoatRoughnessFactor !== void 0) {
            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
          }
          if (extension.clearcoatRoughnessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
          }
          if (extension.clearcoatNormalTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
            if (extension.clearcoatNormalTexture.scale !== void 0) {
              const scale = extension.clearcoatNormalTexture.scale;
              materialParams.clearcoatNormalScale = new THREE2.Vector2(scale, -scale);
            }
          }
          return Promise.all(pending);
        }
      }
      class GLTFMaterialsTransmissionExtension {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return THREE2.MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          if (extension.transmissionFactor !== void 0) {
            materialParams.transmission = extension.transmissionFactor;
          }
          if (extension.transmissionTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
          }
          return Promise.all(pending);
        }
      }
      class GLTFMaterialsVolumeExtension {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return THREE2.MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
          if (extension.thicknessTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
          }
          materialParams.attenuationDistance = extension.attenuationDistance || 0;
          const colorArray = extension.attenuationColor || [1, 1, 1];
          materialParams.attenuationTint = new THREE2.Color(colorArray[0], colorArray[1], colorArray[2]);
          return Promise.all(pending);
        }
      }
      class GLTFMaterialsIorExtension {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_IOR;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return THREE2.MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const extension = materialDef.extensions[this.name];
          materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
          return Promise.resolve();
        }
      }
      class GLTFMaterialsSpecularExtension {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(materialIndex) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name])
            return null;
          return THREE2.MeshPhysicalMaterial;
        }
        extendMaterialParams(materialIndex, materialParams) {
          const parser = this.parser;
          const materialDef = parser.json.materials[materialIndex];
          if (!materialDef.extensions || !materialDef.extensions[this.name]) {
            return Promise.resolve();
          }
          const pending = [];
          const extension = materialDef.extensions[this.name];
          materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
          if (extension.specularTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
          }
          const colorArray = extension.specularColorFactor || [1, 1, 1];
          materialParams.specularTint = new THREE2.Color(colorArray[0], colorArray[1], colorArray[2]);
          if (extension.specularColorTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "specularTintMap", extension.specularColorTexture).then(function(texture) {
              texture.encoding = THREE2.sRGBEncoding;
            }));
          }
          return Promise.all(pending);
        }
      }
      class GLTFTextureBasisUExtension {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
        }
        loadTexture(textureIndex) {
          const parser = this.parser;
          const json = parser.json;
          const textureDef = json.textures[textureIndex];
          if (!textureDef.extensions || !textureDef.extensions[this.name]) {
            return null;
          }
          const extension = textureDef.extensions[this.name];
          const source = json.images[extension.source];
          const loader = parser.options.ktx2Loader;
          if (!loader) {
            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
              throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            } else {
              return null;
            }
          }
          return parser.loadTextureImage(textureIndex, source, loader);
        }
      }
      class GLTFTextureWebPExtension {
        constructor(parser) {
          this.parser = parser;
          this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
          this.isSupported = null;
        }
        loadTexture(textureIndex) {
          const name = this.name;
          const parser = this.parser;
          const json = parser.json;
          const textureDef = json.textures[textureIndex];
          if (!textureDef.extensions || !textureDef.extensions[name]) {
            return null;
          }
          const extension = textureDef.extensions[name];
          const source = json.images[extension.source];
          let loader = parser.textureLoader;
          if (source.uri) {
            const handler = parser.options.manager.getHandler(source.uri);
            if (handler !== null)
              loader = handler;
          }
          return this.detectSupport().then(function(isSupported) {
            if (isSupported)
              return parser.loadTextureImage(textureIndex, source, loader);
            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
              throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            }
            return parser.loadTexture(textureIndex);
          });
        }
        detectSupport() {
          if (!this.isSupported) {
            this.isSupported = new Promise(function(resolve) {
              const image = new Image();
              image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
              image.onload = image.onerror = function() {
                resolve(image.height === 1);
              };
            });
          }
          return this.isSupported;
        }
      }
      class GLTFMeshoptCompression {
        constructor(parser) {
          this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
          this.parser = parser;
        }
        loadBufferView(index) {
          const json = this.parser.json;
          const bufferView = json.bufferViews[index];
          if (bufferView.extensions && bufferView.extensions[this.name]) {
            const extensionDef = bufferView.extensions[this.name];
            const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
            const decoder = this.parser.options.meshoptDecoder;
            if (!decoder || !decoder.supported) {
              if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
              } else {
                return null;
              }
            }
            return Promise.all([buffer, decoder.ready]).then(function(res) {
              const byteOffset = extensionDef.byteOffset || 0;
              const byteLength = extensionDef.byteLength || 0;
              const count = extensionDef.count;
              const stride = extensionDef.byteStride;
              const result = new ArrayBuffer(count * stride);
              const source = new Uint8Array(res[0], byteOffset, byteLength);
              decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
              return result;
            });
          } else {
            return null;
          }
        }
      }
      const BINARY_EXTENSION_HEADER_MAGIC = "glTF";
      const BINARY_EXTENSION_HEADER_LENGTH = 12;
      const BINARY_EXTENSION_CHUNK_TYPES = {
        JSON: 1313821514,
        BIN: 5130562
      };
      class GLTFBinaryExtension {
        constructor(data) {
          this.name = EXTENSIONS.KHR_BINARY_GLTF;
          this.content = null;
          this.body = null;
          const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
          this.header = {
            magic: THREE2.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
            version: headerView.getUint32(4, true),
            length: headerView.getUint32(8, true)
          };
          if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
          } else if (this.header.version < 2) {
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          }
          const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
          const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
          let chunkIndex = 0;
          while (chunkIndex < chunkContentsLength) {
            const chunkLength = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            const chunkType = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;
            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
              const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
              this.content = THREE2.LoaderUtils.decodeText(contentArray);
            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
              const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
              this.body = data.slice(byteOffset, byteOffset + chunkLength);
            }
            chunkIndex += chunkLength;
          }
          if (this.content === null) {
            throw new Error("THREE.GLTFLoader: JSON content not found.");
          }
        }
      }
      class GLTFDracoMeshCompressionExtension {
        constructor(json, dracoLoader) {
          if (!dracoLoader) {
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          }
          this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
          this.json = json;
          this.dracoLoader = dracoLoader;
          this.dracoLoader.preload();
        }
        decodePrimitive(primitive, parser) {
          const json = this.json;
          const dracoLoader = this.dracoLoader;
          const bufferViewIndex = primitive.extensions[this.name].bufferView;
          const gltfAttributeMap = primitive.extensions[this.name].attributes;
          const threeAttributeMap = {};
          const attributeNormalizedMap = {};
          const attributeTypeMap = {};
          for (const attributeName in gltfAttributeMap) {
            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
          }
          for (const attributeName in primitive.attributes) {
            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
            if (gltfAttributeMap[attributeName] !== void 0) {
              const accessorDef = json.accessors[primitive.attributes[attributeName]];
              const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
              attributeTypeMap[threeAttributeName] = componentType;
              attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
            }
          }
          return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
            return new Promise(function(resolve) {
              dracoLoader.decodeDracoFile(bufferView, function(geometry) {
                for (const attributeName in geometry.attributes) {
                  const attribute = geometry.attributes[attributeName];
                  const normalized = attributeNormalizedMap[attributeName];
                  if (normalized !== void 0)
                    attribute.normalized = normalized;
                }
                resolve(geometry);
              }, threeAttributeMap, attributeTypeMap);
            });
          });
        }
      }
      class GLTFTextureTransformExtension {
        constructor() {
          this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(texture, transform) {
          if (transform.texCoord !== void 0) {
            console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
          }
          if (transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
            return texture;
          }
          texture = texture.clone();
          if (transform.offset !== void 0) {
            texture.offset.fromArray(transform.offset);
          }
          if (transform.rotation !== void 0) {
            texture.rotation = transform.rotation;
          }
          if (transform.scale !== void 0) {
            texture.repeat.fromArray(transform.scale);
          }
          texture.needsUpdate = true;
          return texture;
        }
      }
      class GLTFMeshStandardSGMaterial extends THREE2.MeshStandardMaterial {
        constructor(params) {
          super();
          this.isGLTFSpecularGlossinessMaterial = true;
          const specularMapParsFragmentChunk = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n");
          const glossinessMapParsFragmentChunk = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n");
          const specularMapFragmentChunk = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	texelSpecular = sRGBToLinear( texelSpecular );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n");
          const glossinessMapFragmentChunk = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n");
          const lightPhysicalFragmentChunk = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n");
          const uniforms = {
            specular: {
              value: new THREE2.Color().setHex(16777215)
            },
            glossiness: {
              value: 1
            },
            specularMap: {
              value: null
            },
            glossinessMap: {
              value: null
            }
          };
          this._extraUniforms = uniforms;
          this.onBeforeCompile = function(shader) {
            for (const uniformName in uniforms) {
              shader.uniforms[uniformName] = uniforms[uniformName];
            }
            shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
          };
          Object.defineProperties(this, {
            specular: {
              get: function() {
                return uniforms.specular.value;
              },
              set: function(v) {
                uniforms.specular.value = v;
              }
            },
            specularMap: {
              get: function() {
                return uniforms.specularMap.value;
              },
              set: function(v) {
                uniforms.specularMap.value = v;
                if (v) {
                  this.defines.USE_SPECULARMAP = "";
                } else {
                  delete this.defines.USE_SPECULARMAP;
                }
              }
            },
            glossiness: {
              get: function() {
                return uniforms.glossiness.value;
              },
              set: function(v) {
                uniforms.glossiness.value = v;
              }
            },
            glossinessMap: {
              get: function() {
                return uniforms.glossinessMap.value;
              },
              set: function(v) {
                uniforms.glossinessMap.value = v;
                if (v) {
                  this.defines.USE_GLOSSINESSMAP = "";
                  this.defines.USE_UV = "";
                } else {
                  delete this.defines.USE_GLOSSINESSMAP;
                  delete this.defines.USE_UV;
                }
              }
            }
          });
          delete this.metalness;
          delete this.roughness;
          delete this.metalnessMap;
          delete this.roughnessMap;
          this.setValues(params);
        }
        copy(source) {
          super.copy(source);
          this.specularMap = source.specularMap;
          this.specular.copy(source.specular);
          this.glossinessMap = source.glossinessMap;
          this.glossiness = source.glossiness;
          delete this.metalness;
          delete this.roughness;
          delete this.metalnessMap;
          delete this.roughnessMap;
          return this;
        }
      }
      class GLTFMaterialsPbrSpecularGlossinessExtension {
        constructor() {
          this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
          this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"];
        }
        getMaterialType() {
          return GLTFMeshStandardSGMaterial;
        }
        extendParams(materialParams, materialDef, parser) {
          const pbrSpecularGlossiness = materialDef.extensions[this.name];
          materialParams.color = new THREE2.Color(1, 1, 1);
          materialParams.opacity = 1;
          const pending = [];
          if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
            const array = pbrSpecularGlossiness.diffuseFactor;
            materialParams.color.fromArray(array);
            materialParams.opacity = array[3];
          }
          if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
            pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
          }
          materialParams.emissive = new THREE2.Color(0, 0, 0);
          materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
          materialParams.specular = new THREE2.Color(1, 1, 1);
          if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
            materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
          }
          if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
            const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
            pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
            pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
          }
          return Promise.all(pending);
        }
        createMaterial(materialParams) {
          const material = new GLTFMeshStandardSGMaterial(materialParams);
          material.fog = true;
          material.color = materialParams.color;
          material.map = materialParams.map === void 0 ? null : materialParams.map;
          material.lightMap = null;
          material.lightMapIntensity = 1;
          material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
          material.aoMapIntensity = 1;
          material.emissive = materialParams.emissive;
          material.emissiveIntensity = 1;
          material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
          material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
          material.bumpScale = 1;
          material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
          material.normalMapType = THREE2.TangentSpaceNormalMap;
          if (materialParams.normalScale)
            material.normalScale = materialParams.normalScale;
          material.displacementMap = null;
          material.displacementScale = 1;
          material.displacementBias = 0;
          material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
          material.specular = materialParams.specular;
          material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
          material.glossiness = materialParams.glossiness;
          material.alphaMap = null;
          material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
          material.envMapIntensity = 1;
          material.refractionRatio = 0.98;
          return material;
        }
      }
      class GLTFMeshQuantizationExtension {
        constructor() {
          this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
        }
      }
      class GLTFCubicSplineInterpolant extends THREE2.Interpolant {
        constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
          super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        }
        copySampleValue_(index) {
          const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
          for (let i = 0; i !== valueSize; i++) {
            result[i] = values[offset + i];
          }
          return result;
        }
      }
      GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
      GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
      GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
        const result = this.resultBuffer;
        const values = this.sampleValues;
        const stride = this.valueSize;
        const stride2 = stride * 2;
        const stride3 = stride * 3;
        const td = t1 - t0;
        const p = (t - t0) / td;
        const pp = p * p;
        const ppp = pp * p;
        const offset1 = i1 * stride3;
        const offset0 = offset1 - stride3;
        const s2 = -2 * ppp + 3 * pp;
        const s3 = ppp - pp;
        const s0 = 1 - s2;
        const s1 = s3 - pp + p;
        for (let i = 0; i !== stride; i++) {
          const p0 = values[offset0 + i + stride];
          const m0 = values[offset0 + i + stride2] * td;
          const p1 = values[offset1 + i + stride];
          const m1 = values[offset1 + i] * td;
          result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
        }
        return result;
      };
      const _q = new THREE2.Quaternion();
      class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
        interpolate_(i1, t0, t, t1) {
          const result = super.interpolate_(i1, t0, t, t1);
          _q.fromArray(result).normalize().toArray(result);
          return result;
        }
      }
      const WEBGL_CONSTANTS = {
        FLOAT: 5126,
        //FLOAT_MAT2: 35674,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
      };
      const WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
      };
      const WEBGL_FILTERS = {
        9728: THREE2.NearestFilter,
        9729: THREE2.LinearFilter,
        9984: THREE2.NearestMipmapNearestFilter,
        9985: THREE2.LinearMipmapNearestFilter,
        9986: THREE2.NearestMipmapLinearFilter,
        9987: THREE2.LinearMipmapLinearFilter
      };
      const WEBGL_WRAPPINGS = {
        33071: THREE2.ClampToEdgeWrapping,
        33648: THREE2.MirroredRepeatWrapping,
        10497: THREE2.RepeatWrapping
      };
      const WEBGL_TYPE_SIZES = {
        "SCALAR": 1,
        "VEC2": 2,
        "VEC3": 3,
        "VEC4": 4,
        "MAT2": 4,
        "MAT3": 9,
        "MAT4": 16
      };
      const ATTRIBUTES = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
      };
      const PATH_PROPERTIES = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
      };
      const INTERPOLATION = {
        CUBICSPLINE: void 0,
        // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
        // keyframe track will be initialized with a default interpolation type, then modified.
        LINEAR: THREE2.InterpolateLinear,
        STEP: THREE2.InterpolateDiscrete
      };
      const ALPHA_MODES = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
      };
      function resolveURL(url, path) {
        if (typeof url !== "string" || url === "")
          return "";
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
          path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
        }
        if (/^(https?:)?\/\//i.test(url))
          return url;
        if (/^data:.*,.*$/i.test(url))
          return url;
        if (/^blob:.*$/i.test(url))
          return url;
        return path + url;
      }
      function createDefaultMaterial(cache) {
        if (cache["DefaultMaterial"] === void 0) {
          cache["DefaultMaterial"] = new THREE2.MeshStandardMaterial({
            color: 16777215,
            emissive: 0,
            metalness: 1,
            roughness: 1,
            transparent: false,
            depthTest: true,
            side: THREE2.FrontSide
          });
        }
        return cache["DefaultMaterial"];
      }
      function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
        for (const name in objectDef.extensions) {
          if (knownExtensions[name] === void 0) {
            object.userData.gltfExtensions = object.userData.gltfExtensions || {};
            object.userData.gltfExtensions[name] = objectDef.extensions[name];
          }
        }
      }
      function assignExtrasToUserData(object, gltfDef) {
        if (gltfDef.extras !== void 0) {
          if (typeof gltfDef.extras === "object") {
            Object.assign(object.userData, gltfDef.extras);
          } else {
            console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
          }
        }
      }
      function addMorphTargets(geometry, targets, parser) {
        let hasMorphPosition = false;
        let hasMorphNormal = false;
        for (let i = 0, il = targets.length; i < il; i++) {
          const target = targets[i];
          if (target.POSITION !== void 0)
            hasMorphPosition = true;
          if (target.NORMAL !== void 0)
            hasMorphNormal = true;
          if (hasMorphPosition && hasMorphNormal)
            break;
        }
        if (!hasMorphPosition && !hasMorphNormal)
          return Promise.resolve(geometry);
        const pendingPositionAccessors = [];
        const pendingNormalAccessors = [];
        for (let i = 0, il = targets.length; i < il; i++) {
          const target = targets[i];
          if (hasMorphPosition) {
            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
            pendingPositionAccessors.push(pendingAccessor);
          }
          if (hasMorphNormal) {
            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
            pendingNormalAccessors.push(pendingAccessor);
          }
        }
        return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function(accessors) {
          const morphPositions = accessors[0];
          const morphNormals = accessors[1];
          if (hasMorphPosition)
            geometry.morphAttributes.position = morphPositions;
          if (hasMorphNormal)
            geometry.morphAttributes.normal = morphNormals;
          geometry.morphTargetsRelative = true;
          return geometry;
        });
      }
      function updateMorphTargets(mesh, meshDef) {
        mesh.updateMorphTargets();
        if (meshDef.weights !== void 0) {
          for (let i = 0, il = meshDef.weights.length; i < il; i++) {
            mesh.morphTargetInfluences[i] = meshDef.weights[i];
          }
        }
        if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
          const targetNames = meshDef.extras.targetNames;
          if (mesh.morphTargetInfluences.length === targetNames.length) {
            mesh.morphTargetDictionary = {};
            for (let i = 0, il = targetNames.length; i < il; i++) {
              mesh.morphTargetDictionary[targetNames[i]] = i;
            }
          } else {
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
          }
        }
      }
      function createPrimitiveKey(primitiveDef) {
        const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
        let geometryKey;
        if (dracoExtension) {
          geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
        } else {
          geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
        }
        return geometryKey;
      }
      function createAttributesKey(attributes) {
        let attributesKey = "";
        const keys = Object.keys(attributes).sort();
        for (let i = 0, il = keys.length; i < il; i++) {
          attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
        }
        return attributesKey;
      }
      function getNormalizedComponentScale(constructor) {
        switch (constructor) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
      }
      class GLTFParser {
        constructor(json = {}, options2 = {}) {
          this.json = json;
          this.extensions = {};
          this.plugins = {};
          this.options = options2;
          this.cache = new GLTFRegistry();
          this.associations = /* @__PURE__ */ new Map();
          this.primitiveCache = {};
          this.meshCache = {
            refs: {},
            uses: {}
          };
          this.cameraCache = {
            refs: {},
            uses: {}
          };
          this.lightCache = {
            refs: {},
            uses: {}
          };
          this.textureCache = {};
          this.nodeNamesUsed = {};
          if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
            this.textureLoader = new THREE2.ImageBitmapLoader(this.options.manager);
          } else {
            this.textureLoader = new THREE2.TextureLoader(this.options.manager);
          }
          this.textureLoader.setCrossOrigin(this.options.crossOrigin);
          this.textureLoader.setRequestHeader(this.options.requestHeader);
          this.fileLoader = new THREE2.FileLoader(this.options.manager);
          this.fileLoader.setResponseType("arraybuffer");
          if (this.options.crossOrigin === "use-credentials") {
            this.fileLoader.setWithCredentials(true);
          }
        }
        setExtensions(extensions) {
          this.extensions = extensions;
        }
        setPlugins(plugins) {
          this.plugins = plugins;
        }
        parse(onLoad, onError) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          this.cache.removeAll();
          this._invokeAll(function(ext) {
            return ext._markDefs && ext._markDefs();
          });
          Promise.all(this._invokeAll(function(ext) {
            return ext.beforeRoot && ext.beforeRoot();
          })).then(function() {
            return Promise.all([parser.getDependencies("scene"), parser.getDependencies("animation"), parser.getDependencies("camera")]);
          }).then(function(dependencies) {
            const result = {
              scene: dependencies[0][json.scene || 0],
              scenes: dependencies[0],
              animations: dependencies[1],
              cameras: dependencies[2],
              asset: json.asset,
              parser,
              userData: {}
            };
            addUnknownExtensionsToUserData(extensions, result, json);
            assignExtrasToUserData(result, json);
            Promise.all(parser._invokeAll(function(ext) {
              return ext.afterRoot && ext.afterRoot(result);
            })).then(function() {
              onLoad(result);
            });
          }).catch(onError);
        }
        /**
         * Marks the special nodes/meshes in json for efficient parse.
         */
        _markDefs() {
          const nodeDefs = this.json.nodes || [];
          const skinDefs = this.json.skins || [];
          const meshDefs = this.json.meshes || [];
          for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
            const joints = skinDefs[skinIndex].joints;
            for (let i = 0, il = joints.length; i < il; i++) {
              nodeDefs[joints[i]].isBone = true;
            }
          }
          for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
            const nodeDef = nodeDefs[nodeIndex];
            if (nodeDef.mesh !== void 0) {
              this._addNodeRef(this.meshCache, nodeDef.mesh);
              if (nodeDef.skin !== void 0) {
                meshDefs[nodeDef.mesh].isSkinnedMesh = true;
              }
            }
            if (nodeDef.camera !== void 0) {
              this._addNodeRef(this.cameraCache, nodeDef.camera);
            }
          }
        }
        /**
         * Counts references to shared node / THREE.Object3D resources. These resources
         * can be reused, or "instantiated", at multiple nodes in the scene
         * hierarchy. THREE.Mesh, Camera, and Light instances are instantiated and must
         * be marked. Non-scenegraph resources (like Materials, Geometries, and
         * Textures) can be reused directly and are not marked here.
         *
         * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
         */
        _addNodeRef(cache, index) {
          if (index === void 0)
            return;
          if (cache.refs[index] === void 0) {
            cache.refs[index] = cache.uses[index] = 0;
          }
          cache.refs[index]++;
        }
        /** Returns a reference to a shared resource, cloning it if necessary. */
        _getNodeRef(cache, index, object) {
          if (cache.refs[index] <= 1)
            return object;
          const ref = object.clone();
          ref.name += "_instance_" + cache.uses[index]++;
          return ref;
        }
        _invokeOne(func) {
          const extensions = Object.values(this.plugins);
          extensions.push(this);
          for (let i = 0; i < extensions.length; i++) {
            const result = func(extensions[i]);
            if (result)
              return result;
          }
          return null;
        }
        _invokeAll(func) {
          const extensions = Object.values(this.plugins);
          extensions.unshift(this);
          const pending = [];
          for (let i = 0; i < extensions.length; i++) {
            const result = func(extensions[i]);
            if (result)
              pending.push(result);
          }
          return pending;
        }
        /**
         * Requests the specified dependency asynchronously, with caching.
         * @param {string} type
         * @param {number} index
         * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
         */
        getDependency(type, index) {
          const cacheKey = type + ":" + index;
          let dependency = this.cache.get(cacheKey);
          if (!dependency) {
            switch (type) {
              case "scene":
                dependency = this.loadScene(index);
                break;
              case "node":
                dependency = this.loadNode(index);
                break;
              case "mesh":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadMesh && ext.loadMesh(index);
                });
                break;
              case "accessor":
                dependency = this.loadAccessor(index);
                break;
              case "bufferView":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadBufferView && ext.loadBufferView(index);
                });
                break;
              case "buffer":
                dependency = this.loadBuffer(index);
                break;
              case "material":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadMaterial && ext.loadMaterial(index);
                });
                break;
              case "texture":
                dependency = this._invokeOne(function(ext) {
                  return ext.loadTexture && ext.loadTexture(index);
                });
                break;
              case "skin":
                dependency = this.loadSkin(index);
                break;
              case "animation":
                dependency = this.loadAnimation(index);
                break;
              case "camera":
                dependency = this.loadCamera(index);
                break;
              default:
                throw new Error("Unknown type: " + type);
            }
            this.cache.add(cacheKey, dependency);
          }
          return dependency;
        }
        /**
         * Requests all dependencies of the specified type asynchronously, with caching.
         * @param {string} type
         * @return {Promise<Array<Object>>}
         */
        getDependencies(type) {
          let dependencies = this.cache.get(type);
          if (!dependencies) {
            const parser = this;
            const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
            dependencies = Promise.all(defs.map(function(def, index) {
              return parser.getDependency(type, index);
            }));
            this.cache.add(type, dependencies);
          }
          return dependencies;
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
         * @param {number} bufferIndex
         * @return {Promise<ArrayBuffer>}
         */
        loadBuffer(bufferIndex) {
          const bufferDef = this.json.buffers[bufferIndex];
          const loader = this.fileLoader;
          if (bufferDef.type && bufferDef.type !== "arraybuffer") {
            throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
          }
          if (bufferDef.uri === void 0 && bufferIndex === 0) {
            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
          }
          const options2 = this.options;
          return new Promise(function(resolve, reject) {
            loader.load(resolveURL(bufferDef.uri, options2.path), resolve, void 0, function() {
              reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
            });
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
         * @param {number} bufferViewIndex
         * @return {Promise<ArrayBuffer>}
         */
        loadBufferView(bufferViewIndex) {
          const bufferViewDef = this.json.bufferViews[bufferViewIndex];
          return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
            const byteLength = bufferViewDef.byteLength || 0;
            const byteOffset = bufferViewDef.byteOffset || 0;
            return buffer.slice(byteOffset, byteOffset + byteLength);
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
         * @param {number} accessorIndex
         * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
         */
        loadAccessor(accessorIndex) {
          const parser = this;
          const json = this.json;
          const accessorDef = this.json.accessors[accessorIndex];
          if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
            return Promise.resolve(null);
          }
          const pendingBufferViews = [];
          if (accessorDef.bufferView !== void 0) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
          } else {
            pendingBufferViews.push(null);
          }
          if (accessorDef.sparse !== void 0) {
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
            pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
          }
          return Promise.all(pendingBufferViews).then(function(bufferViews) {
            const bufferView = bufferViews[0];
            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
            const elementBytes = TypedArray.BYTES_PER_ELEMENT;
            const itemBytes = elementBytes * itemSize;
            const byteOffset = accessorDef.byteOffset || 0;
            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
            const normalized = accessorDef.normalized === true;
            let array, bufferAttribute;
            if (byteStride && byteStride !== itemBytes) {
              const ibSlice = Math.floor(byteOffset / byteStride);
              const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
              let ib = parser.cache.get(ibCacheKey);
              if (!ib) {
                array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
                ib = new THREE2.InterleavedBuffer(array, byteStride / elementBytes);
                parser.cache.add(ibCacheKey, ib);
              }
              bufferAttribute = new THREE2.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
            } else {
              if (bufferView === null) {
                array = new TypedArray(accessorDef.count * itemSize);
              } else {
                array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
              }
              bufferAttribute = new THREE2.BufferAttribute(array, itemSize, normalized);
            }
            if (accessorDef.sparse !== void 0) {
              const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
              const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
              const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
              const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
              const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
              const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
              if (bufferView !== null) {
                bufferAttribute = new THREE2.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
              }
              for (let i = 0, il = sparseIndices.length; i < il; i++) {
                const index = sparseIndices[i];
                bufferAttribute.setX(index, sparseValues[i * itemSize]);
                if (itemSize >= 2)
                  bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
                if (itemSize >= 3)
                  bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
                if (itemSize >= 4)
                  bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
                if (itemSize >= 5)
                  throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.");
              }
            }
            return bufferAttribute;
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
         * @param {number} textureIndex
         * @return {Promise<THREE.Texture>}
         */
        loadTexture(textureIndex) {
          const json = this.json;
          const options2 = this.options;
          const textureDef = json.textures[textureIndex];
          const source = json.images[textureDef.source];
          let loader = this.textureLoader;
          if (source.uri) {
            const handler = options2.manager.getHandler(source.uri);
            if (handler !== null)
              loader = handler;
          }
          return this.loadTextureImage(textureIndex, source, loader);
        }
        loadTextureImage(textureIndex, source, loader) {
          const parser = this;
          const json = this.json;
          const options2 = this.options;
          const textureDef = json.textures[textureIndex];
          const cacheKey = (source.uri || source.bufferView) + ":" + textureDef.sampler;
          if (this.textureCache[cacheKey]) {
            return this.textureCache[cacheKey];
          }
          const URL2 = self.URL || self.webkitURL;
          let sourceURI = source.uri || "";
          let isObjectURL = false;
          let hasAlpha = true;
          const isJPEG = sourceURI.search(/\.jpe?g($|\?)/i) > 0 || sourceURI.search(/^data\:image\/jpeg/) === 0;
          if (source.mimeType === "image/jpeg" || isJPEG)
            hasAlpha = false;
          if (source.bufferView !== void 0) {
            sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
              if (source.mimeType === "image/png") {
                const colorType = new DataView(bufferView, 25, 1).getUint8(0, false);
                hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;
              }
              isObjectURL = true;
              const blob = new Blob([bufferView], {
                type: source.mimeType
              });
              sourceURI = URL2.createObjectURL(blob);
              return sourceURI;
            });
          } else if (source.uri === void 0) {
            throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
          }
          const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
            return new Promise(function(resolve, reject) {
              let onLoad = resolve;
              if (loader.isImageBitmapLoader === true) {
                onLoad = function(imageBitmap) {
                  const texture = new THREE2.Texture(imageBitmap);
                  texture.needsUpdate = true;
                  resolve(texture);
                };
              }
              loader.load(resolveURL(sourceURI2, options2.path), onLoad, void 0, reject);
            });
          }).then(function(texture) {
            if (isObjectURL === true) {
              URL2.revokeObjectURL(sourceURI);
            }
            texture.flipY = false;
            if (textureDef.name)
              texture.name = textureDef.name;
            if (!hasAlpha)
              texture.format = THREE2.RGBFormat;
            const samplers = json.samplers || {};
            const sampler = samplers[textureDef.sampler] || {};
            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE2.LinearFilter;
            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE2.LinearMipmapLinearFilter;
            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE2.RepeatWrapping;
            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE2.RepeatWrapping;
            parser.associations.set(texture, {
              type: "textures",
              index: textureIndex
            });
            return texture;
          }).catch(function() {
            console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
            return null;
          });
          this.textureCache[cacheKey] = promise;
          return promise;
        }
        /**
         * Asynchronously assigns a texture to the given material parameters.
         * @param {Object} materialParams
         * @param {string} mapName
         * @param {Object} mapDef
         * @return {Promise<Texture>}
         */
        assignTexture(materialParams, mapName, mapDef) {
          const parser = this;
          return this.getDependency("texture", mapDef.index).then(function(texture) {
            if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
              console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
            }
            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
              const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
              if (transform) {
                const gltfReference = parser.associations.get(texture);
                texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                parser.associations.set(texture, gltfReference);
              }
            }
            materialParams[mapName] = texture;
            return texture;
          });
        }
        /**
         * Assigns final material to a THREE.Mesh, THREE.Line, or THREE.Points instance. The instance
         * already has a material (generated from the glTF material options alone)
         * but reuse of the same glTF material may require multiple threejs materials
         * to accommodate different primitive types, defines, etc. New materials will
         * be created if necessary, and reused from a cache.
         * @param  {Object3D} mesh THREE.Mesh, THREE.Line, or THREE.Points instance.
         */
        assignFinalMaterial(mesh) {
          const geometry = mesh.geometry;
          let material = mesh.material;
          const useVertexTangents = geometry.attributes.tangent !== void 0;
          const useVertexColors = geometry.attributes.color !== void 0;
          const useFlatShading = geometry.attributes.normal === void 0;
          if (mesh.isPoints) {
            const cacheKey = "PointsMaterial:" + material.uuid;
            let pointsMaterial = this.cache.get(cacheKey);
            if (!pointsMaterial) {
              pointsMaterial = new THREE2.PointsMaterial();
              THREE2.Material.prototype.copy.call(pointsMaterial, material);
              pointsMaterial.color.copy(material.color);
              pointsMaterial.map = material.map;
              pointsMaterial.sizeAttenuation = false;
              this.cache.add(cacheKey, pointsMaterial);
            }
            material = pointsMaterial;
          } else if (mesh.isLine) {
            const cacheKey = "LineBasicMaterial:" + material.uuid;
            let lineMaterial = this.cache.get(cacheKey);
            if (!lineMaterial) {
              lineMaterial = new THREE2.LineBasicMaterial();
              THREE2.Material.prototype.copy.call(lineMaterial, material);
              lineMaterial.color.copy(material.color);
              this.cache.add(cacheKey, lineMaterial);
            }
            material = lineMaterial;
          }
          if (useVertexTangents || useVertexColors || useFlatShading) {
            let cacheKey = "ClonedMaterial:" + material.uuid + ":";
            if (material.isGLTFSpecularGlossinessMaterial)
              cacheKey += "specular-glossiness:";
            if (useVertexTangents)
              cacheKey += "vertex-tangents:";
            if (useVertexColors)
              cacheKey += "vertex-colors:";
            if (useFlatShading)
              cacheKey += "flat-shading:";
            let cachedMaterial = this.cache.get(cacheKey);
            if (!cachedMaterial) {
              cachedMaterial = material.clone();
              if (useVertexColors)
                cachedMaterial.vertexColors = true;
              if (useFlatShading)
                cachedMaterial.flatShading = true;
              if (useVertexTangents) {
                if (cachedMaterial.normalScale)
                  cachedMaterial.normalScale.y *= -1;
                if (cachedMaterial.clearcoatNormalScale)
                  cachedMaterial.clearcoatNormalScale.y *= -1;
              }
              this.cache.add(cacheKey, cachedMaterial);
              this.associations.set(cachedMaterial, this.associations.get(material));
            }
            material = cachedMaterial;
          }
          if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
            geometry.setAttribute("uv2", geometry.attributes.uv);
          }
          mesh.material = material;
        }
        getMaterialType() {
          return THREE2.MeshStandardMaterial;
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
         * @param {number} materialIndex
         * @return {Promise<Material>}
         */
        loadMaterial(materialIndex) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          const materialDef = json.materials[materialIndex];
          let materialType;
          const materialParams = {};
          const materialExtensions = materialDef.extensions || {};
          const pending = [];
          if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            materialType = sgExtension.getMaterialType();
            pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
          } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
            materialType = kmuExtension.getMaterialType();
            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
          } else {
            const metallicRoughness = materialDef.pbrMetallicRoughness || {};
            materialParams.color = new THREE2.Color(1, 1, 1);
            materialParams.opacity = 1;
            if (Array.isArray(metallicRoughness.baseColorFactor)) {
              const array = metallicRoughness.baseColorFactor;
              materialParams.color.fromArray(array);
              materialParams.opacity = array[3];
            }
            if (metallicRoughness.baseColorTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
            }
            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
            if (metallicRoughness.metallicRoughnessTexture !== void 0) {
              pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
              pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
            }
            materialType = this._invokeOne(function(ext) {
              return ext.getMaterialType && ext.getMaterialType(materialIndex);
            });
            pending.push(Promise.all(this._invokeAll(function(ext) {
              return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
            })));
          }
          if (materialDef.doubleSided === true) {
            materialParams.side = THREE2.DoubleSide;
          }
          const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
          if (alphaMode === ALPHA_MODES.BLEND) {
            materialParams.transparent = true;
            materialParams.depthWrite = false;
          } else {
            materialParams.format = THREE2.RGBFormat;
            materialParams.transparent = false;
            if (alphaMode === ALPHA_MODES.MASK) {
              materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
            }
          }
          if (materialDef.normalTexture !== void 0 && materialType !== THREE2.MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
            materialParams.normalScale = new THREE2.Vector2(1, -1);
            if (materialDef.normalTexture.scale !== void 0) {
              materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);
            }
          }
          if (materialDef.occlusionTexture !== void 0 && materialType !== THREE2.MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
            if (materialDef.occlusionTexture.strength !== void 0) {
              materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
            }
          }
          if (materialDef.emissiveFactor !== void 0 && materialType !== THREE2.MeshBasicMaterial) {
            materialParams.emissive = new THREE2.Color().fromArray(materialDef.emissiveFactor);
          }
          if (materialDef.emissiveTexture !== void 0 && materialType !== THREE2.MeshBasicMaterial) {
            pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
          }
          return Promise.all(pending).then(function() {
            let material;
            if (materialType === GLTFMeshStandardSGMaterial) {
              material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
            } else {
              material = new materialType(materialParams);
            }
            if (materialDef.name)
              material.name = materialDef.name;
            if (material.map)
              material.map.encoding = THREE2.sRGBEncoding;
            if (material.emissiveMap)
              material.emissiveMap.encoding = THREE2.sRGBEncoding;
            assignExtrasToUserData(material, materialDef);
            parser.associations.set(material, {
              type: "materials",
              index: materialIndex
            });
            if (materialDef.extensions)
              addUnknownExtensionsToUserData(extensions, material, materialDef);
            return material;
          });
        }
        /** When THREE.Object3D instances are targeted by animation, they need unique names. */
        createUniqueName(originalName) {
          const sanitizedName = THREE2.PropertyBinding.sanitizeNodeName(originalName || "");
          let name = sanitizedName;
          for (let i = 1; this.nodeNamesUsed[name]; ++i) {
            name = sanitizedName + "_" + i;
          }
          this.nodeNamesUsed[name] = true;
          return name;
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
         *
         * Creates BufferGeometries from primitives.
         *
         * @param {Array<GLTF.Primitive>} primitives
         * @return {Promise<Array<BufferGeometry>>}
         */
        loadGeometries(primitives) {
          const parser = this;
          const extensions = this.extensions;
          const cache = this.primitiveCache;
          function createDracoPrimitive(primitive) {
            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
              return addPrimitiveAttributes(geometry, primitive, parser);
            });
          }
          const pending = [];
          for (let i = 0, il = primitives.length; i < il; i++) {
            const primitive = primitives[i];
            const cacheKey = createPrimitiveKey(primitive);
            const cached = cache[cacheKey];
            if (cached) {
              pending.push(cached.promise);
            } else {
              let geometryPromise;
              if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
                geometryPromise = createDracoPrimitive(primitive);
              } else {
                geometryPromise = addPrimitiveAttributes(new THREE2.BufferGeometry(), primitive, parser);
              }
              cache[cacheKey] = {
                primitive,
                promise: geometryPromise
              };
              pending.push(geometryPromise);
            }
          }
          return Promise.all(pending);
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
         * @param {number} meshIndex
         * @return {Promise<Group|Mesh|SkinnedMesh>}
         */
        loadMesh(meshIndex) {
          const parser = this;
          const json = this.json;
          const extensions = this.extensions;
          const meshDef = json.meshes[meshIndex];
          const primitives = meshDef.primitives;
          const pending = [];
          for (let i = 0, il = primitives.length; i < il; i++) {
            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
            pending.push(material);
          }
          pending.push(parser.loadGeometries(primitives));
          return Promise.all(pending).then(function(results) {
            const materials = results.slice(0, results.length - 1);
            const geometries = results[results.length - 1];
            const meshes = [];
            for (let i = 0, il = geometries.length; i < il; i++) {
              const geometry = geometries[i];
              const primitive = primitives[i];
              let mesh;
              const material = materials[i];
              if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
                mesh = meshDef.isSkinnedMesh === true ? new THREE2.SkinnedMesh(geometry, material) : new THREE2.Mesh(geometry, material);
                if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
                  mesh.normalizeSkinWeights();
                }
                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
                  mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE2.TriangleStripDrawMode);
                } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
                  mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE2.TriangleFanDrawMode);
                }
              } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
                mesh = new THREE2.LineSegments(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
                mesh = new THREE2.Line(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
                mesh = new THREE2.LineLoop(geometry, material);
              } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
                mesh = new THREE2.Points(geometry, material);
              } else {
                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
              }
              if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
                updateMorphTargets(mesh, meshDef);
              }
              mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
              assignExtrasToUserData(mesh, meshDef);
              if (primitive.extensions)
                addUnknownExtensionsToUserData(extensions, mesh, primitive);
              parser.assignFinalMaterial(mesh);
              meshes.push(mesh);
            }
            if (meshes.length === 1) {
              return meshes[0];
            }
            const group = new THREE2.Group();
            for (let i = 0, il = meshes.length; i < il; i++) {
              group.add(meshes[i]);
            }
            return group;
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
         * @param {number} cameraIndex
         * @return {Promise<THREE.Camera>}
         */
        loadCamera(cameraIndex) {
          let camera;
          const cameraDef = this.json.cameras[cameraIndex];
          const params = cameraDef[cameraDef.type];
          if (!params) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          if (cameraDef.type === "perspective") {
            camera = new THREE2.PerspectiveCamera(THREE2.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
          } else if (cameraDef.type === "orthographic") {
            camera = new THREE2.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
          }
          if (cameraDef.name)
            camera.name = this.createUniqueName(cameraDef.name);
          assignExtrasToUserData(camera, cameraDef);
          return Promise.resolve(camera);
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
         * @param {number} skinIndex
         * @return {Promise<Object>}
         */
        loadSkin(skinIndex) {
          const skinDef = this.json.skins[skinIndex];
          const skinEntry = {
            joints: skinDef.joints
          };
          if (skinDef.inverseBindMatrices === void 0) {
            return Promise.resolve(skinEntry);
          }
          return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
            skinEntry.inverseBindMatrices = accessor;
            return skinEntry;
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
         * @param {number} animationIndex
         * @return {Promise<AnimationClip>}
         */
        loadAnimation(animationIndex) {
          const json = this.json;
          const animationDef = json.animations[animationIndex];
          const pendingNodes = [];
          const pendingInputAccessors = [];
          const pendingOutputAccessors = [];
          const pendingSamplers = [];
          const pendingTargets = [];
          for (let i = 0, il = animationDef.channels.length; i < il; i++) {
            const channel = animationDef.channels[i];
            const sampler = animationDef.samplers[channel.sampler];
            const target = channel.target;
            const name = target.node !== void 0 ? target.node : target.id;
            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
            pendingNodes.push(this.getDependency("node", name));
            pendingInputAccessors.push(this.getDependency("accessor", input));
            pendingOutputAccessors.push(this.getDependency("accessor", output));
            pendingSamplers.push(sampler);
            pendingTargets.push(target);
          }
          return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function(dependencies) {
            const nodes = dependencies[0];
            const inputAccessors = dependencies[1];
            const outputAccessors = dependencies[2];
            const samplers = dependencies[3];
            const targets = dependencies[4];
            const tracks = [];
            for (let i = 0, il = nodes.length; i < il; i++) {
              const node = nodes[i];
              const inputAccessor = inputAccessors[i];
              const outputAccessor = outputAccessors[i];
              const sampler = samplers[i];
              const target = targets[i];
              if (node === void 0)
                continue;
              node.updateMatrix();
              node.matrixAutoUpdate = true;
              let TypedKeyframeTrack;
              switch (PATH_PROPERTIES[target.path]) {
                case PATH_PROPERTIES.weights:
                  TypedKeyframeTrack = THREE2.NumberKeyframeTrack;
                  break;
                case PATH_PROPERTIES.rotation:
                  TypedKeyframeTrack = THREE2.QuaternionKeyframeTrack;
                  break;
                case PATH_PROPERTIES.position:
                case PATH_PROPERTIES.scale:
                default:
                  TypedKeyframeTrack = THREE2.VectorKeyframeTrack;
                  break;
              }
              const targetName = node.name ? node.name : node.uuid;
              const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : THREE2.InterpolateLinear;
              const targetNames = [];
              if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
                node.traverse(function(object) {
                  if (object.isMesh === true && object.morphTargetInfluences) {
                    targetNames.push(object.name ? object.name : object.uuid);
                  }
                });
              } else {
                targetNames.push(targetName);
              }
              let outputArray = outputAccessor.array;
              if (outputAccessor.normalized) {
                const scale = getNormalizedComponentScale(outputArray.constructor);
                const scaled = new Float32Array(outputArray.length);
                for (let j = 0, jl = outputArray.length; j < jl; j++) {
                  scaled[j] = outputArray[j] * scale;
                }
                outputArray = scaled;
              }
              for (let j = 0, jl = targetNames.length; j < jl; j++) {
                const track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
                if (sampler.interpolation === "CUBICSPLINE") {
                  track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                    const interpolantType = this instanceof THREE2.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                    return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
                  };
                  track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
                }
                tracks.push(track);
              }
            }
            const name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
            return new THREE2.AnimationClip(name, void 0, tracks);
          });
        }
        createNodeMesh(nodeIndex) {
          const json = this.json;
          const parser = this;
          const nodeDef = json.nodes[nodeIndex];
          if (nodeDef.mesh === void 0)
            return null;
          return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
            if (nodeDef.weights !== void 0) {
              node.traverse(function(o2) {
                if (!o2.isMesh)
                  return;
                for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
                  o2.morphTargetInfluences[i] = nodeDef.weights[i];
                }
              });
            }
            return node;
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
         * @param {number} nodeIndex
         * @return {Promise<Object3D>}
         */
        loadNode(nodeIndex) {
          const json = this.json;
          const extensions = this.extensions;
          const parser = this;
          const nodeDef = json.nodes[nodeIndex];
          const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
          return function() {
            const pending = [];
            const meshPromise = parser._invokeOne(function(ext) {
              return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
            });
            if (meshPromise) {
              pending.push(meshPromise);
            }
            if (nodeDef.camera !== void 0) {
              pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
              }));
            }
            parser._invokeAll(function(ext) {
              return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
            }).forEach(function(promise) {
              pending.push(promise);
            });
            return Promise.all(pending);
          }().then(function(objects) {
            let node;
            if (nodeDef.isBone === true) {
              node = new THREE2.Bone();
            } else if (objects.length > 1) {
              node = new THREE2.Group();
            } else if (objects.length === 1) {
              node = objects[0];
            } else {
              node = new THREE2.Object3D();
            }
            if (node !== objects[0]) {
              for (let i = 0, il = objects.length; i < il; i++) {
                node.add(objects[i]);
              }
            }
            if (nodeDef.name) {
              node.userData.name = nodeDef.name;
              node.name = nodeName;
            }
            assignExtrasToUserData(node, nodeDef);
            if (nodeDef.extensions)
              addUnknownExtensionsToUserData(extensions, node, nodeDef);
            if (nodeDef.matrix !== void 0) {
              const matrix = new THREE2.Matrix4();
              matrix.fromArray(nodeDef.matrix);
              node.applyMatrix4(matrix);
            } else {
              if (nodeDef.translation !== void 0) {
                node.position.fromArray(nodeDef.translation);
              }
              if (nodeDef.rotation !== void 0) {
                node.quaternion.fromArray(nodeDef.rotation);
              }
              if (nodeDef.scale !== void 0) {
                node.scale.fromArray(nodeDef.scale);
              }
            }
            parser.associations.set(node, {
              type: "nodes",
              index: nodeIndex
            });
            return node;
          });
        }
        /**
         * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
         * @param {number} sceneIndex
         * @return {Promise<Group>}
         */
        loadScene(sceneIndex) {
          const json = this.json;
          const extensions = this.extensions;
          const sceneDef = this.json.scenes[sceneIndex];
          const parser = this;
          const scene = new THREE2.Group();
          if (sceneDef.name)
            scene.name = parser.createUniqueName(sceneDef.name);
          assignExtrasToUserData(scene, sceneDef);
          if (sceneDef.extensions)
            addUnknownExtensionsToUserData(extensions, scene, sceneDef);
          const nodeIds = sceneDef.nodes || [];
          const pending = [];
          for (let i = 0, il = nodeIds.length; i < il; i++) {
            pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
          }
          return Promise.all(pending).then(function() {
            return scene;
          });
        }
      }
      function buildNodeHierachy(nodeId, parentObject, json, parser) {
        const nodeDef = json.nodes[nodeId];
        return parser.getDependency("node", nodeId).then(function(node) {
          if (nodeDef.skin === void 0)
            return node;
          let skinEntry;
          return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
            skinEntry = skin;
            const pendingJoints = [];
            for (let i = 0, il = skinEntry.joints.length; i < il; i++) {
              pendingJoints.push(parser.getDependency("node", skinEntry.joints[i]));
            }
            return Promise.all(pendingJoints);
          }).then(function(jointNodes) {
            node.traverse(function(mesh) {
              if (!mesh.isMesh)
                return;
              const bones = [];
              const boneInverses = [];
              for (let j = 0, jl = jointNodes.length; j < jl; j++) {
                const jointNode = jointNodes[j];
                if (jointNode) {
                  bones.push(jointNode);
                  const mat = new THREE2.Matrix4();
                  if (skinEntry.inverseBindMatrices !== void 0) {
                    mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                  }
                  boneInverses.push(mat);
                } else {
                  console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
                }
              }
              mesh.bind(new THREE2.Skeleton(bones, boneInverses), mesh.matrixWorld);
            });
            return node;
          });
        }).then(function(node) {
          parentObject.add(node);
          const pending = [];
          if (nodeDef.children) {
            const children = nodeDef.children;
            for (let i = 0, il = children.length; i < il; i++) {
              const child = children[i];
              pending.push(buildNodeHierachy(child, node, json, parser));
            }
          }
          return Promise.all(pending);
        });
      }
      function computeBounds(geometry, primitiveDef, parser) {
        const attributes = primitiveDef.attributes;
        const box = new THREE2.Box3();
        if (attributes.POSITION !== void 0) {
          const accessor = parser.json.accessors[attributes.POSITION];
          const min = accessor.min;
          const max = accessor.max;
          if (min !== void 0 && max !== void 0) {
            box.set(new THREE2.Vector3(min[0], min[1], min[2]), new THREE2.Vector3(max[0], max[1], max[2]));
            if (accessor.normalized) {
              const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
              box.min.multiplyScalar(boxScale);
              box.max.multiplyScalar(boxScale);
            }
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return;
          }
        } else {
          return;
        }
        const targets = primitiveDef.targets;
        if (targets !== void 0) {
          const maxDisplacement = new THREE2.Vector3();
          const vector = new THREE2.Vector3();
          for (let i = 0, il = targets.length; i < il; i++) {
            const target = targets[i];
            if (target.POSITION !== void 0) {
              const accessor = parser.json.accessors[target.POSITION];
              const min = accessor.min;
              const max = accessor.max;
              if (min !== void 0 && max !== void 0) {
                vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
                vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
                vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
                if (accessor.normalized) {
                  const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                  vector.multiplyScalar(boxScale);
                }
                maxDisplacement.max(vector);
              } else {
                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
              }
            }
          }
          box.expandByVector(maxDisplacement);
        }
        geometry.boundingBox = box;
        const sphere = new THREE2.Sphere();
        box.getCenter(sphere.center);
        sphere.radius = box.min.distanceTo(box.max) / 2;
        geometry.boundingSphere = sphere;
      }
      function addPrimitiveAttributes(geometry, primitiveDef, parser) {
        const attributes = primitiveDef.attributes;
        const pending = [];
        function assignAttributeAccessor(accessorIndex, attributeName) {
          return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
            geometry.setAttribute(attributeName, accessor);
          });
        }
        for (const gltfAttributeName in attributes) {
          const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
          if (threeAttributeName in geometry.attributes)
            continue;
          pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
        }
        if (primitiveDef.indices !== void 0 && !geometry.index) {
          const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
            geometry.setIndex(accessor2);
          });
          pending.push(accessor);
        }
        assignExtrasToUserData(geometry, primitiveDef);
        computeBounds(geometry, primitiveDef, parser);
        return Promise.all(pending).then(function() {
          return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
        });
      }
      function toTrianglesDrawMode(geometry, drawMode) {
        let index = geometry.getIndex();
        if (index === null) {
          const indices = [];
          const position = geometry.getAttribute("position");
          if (position !== void 0) {
            for (let i = 0; i < position.count; i++) {
              indices.push(i);
            }
            geometry.setIndex(indices);
            index = geometry.getIndex();
          } else {
            console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
            return geometry;
          }
        }
        const numberOfTriangles = index.count - 2;
        const newIndices = [];
        if (drawMode === THREE2.TriangleFanDrawMode) {
          for (let i = 1; i <= numberOfTriangles; i++) {
            newIndices.push(index.getX(0));
            newIndices.push(index.getX(i));
            newIndices.push(index.getX(i + 1));
          }
        } else {
          for (let i = 0; i < numberOfTriangles; i++) {
            if (i % 2 === 0) {
              newIndices.push(index.getX(i));
              newIndices.push(index.getX(i + 1));
              newIndices.push(index.getX(i + 2));
            } else {
              newIndices.push(index.getX(i + 2));
              newIndices.push(index.getX(i + 1));
              newIndices.push(index.getX(i));
            }
          }
        }
        if (newIndices.length / 3 !== numberOfTriangles) {
          console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        }
        const newGeometry = geometry.clone();
        newGeometry.setIndex(newIndices);
        return newGeometry;
      }
      THREE2.GLTFLoader = GLTFLoader;
    })();
    module.exports = exports = THREE2.GLTFLoader;
  }
});

// node_modules/threebox-plugin/src/objects/loaders/ColladaLoader.js
var require_ColladaLoader = __commonJS({
  "node_modules/threebox-plugin/src/objects/loaders/ColladaLoader.js"(exports, module) {
    var THREE2 = require_three();
    (function() {
      class ColladaLoader extends THREE2.Loader {
        constructor(manager) {
          super(manager);
        }
        load(url, onLoad, onProgress, onError) {
          const scope = this;
          const path = scope.path === "" ? THREE2.LoaderUtils.extractUrlBase(url) : scope.path;
          const loader = new THREE2.FileLoader(scope.manager);
          loader.setPath(scope.path);
          loader.setRequestHeader(scope.requestHeader);
          loader.setWithCredentials(scope.withCredentials);
          loader.load(url, function(text) {
            try {
              onLoad(scope.parse(text, path));
            } catch (e) {
              if (onError) {
                onError(e);
              } else {
                console.error(e);
              }
              scope.manager.itemError(url);
            }
          }, onProgress, onError);
        }
        parse(text, path) {
          function getElementsByTagName(xml2, name) {
            const array = [];
            const childNodes = xml2.childNodes;
            for (let i = 0, l = childNodes.length; i < l; i++) {
              const child = childNodes[i];
              if (child.nodeName === name) {
                array.push(child);
              }
            }
            return array;
          }
          function parseStrings(text2) {
            if (text2.length === 0)
              return [];
            const parts = text2.trim().split(/\s+/);
            const array = new Array(parts.length);
            for (let i = 0, l = parts.length; i < l; i++) {
              array[i] = parts[i];
            }
            return array;
          }
          function parseFloats(text2) {
            if (text2.length === 0)
              return [];
            const parts = text2.trim().split(/\s+/);
            const array = new Array(parts.length);
            for (let i = 0, l = parts.length; i < l; i++) {
              array[i] = parseFloat(parts[i]);
            }
            return array;
          }
          function parseInts(text2) {
            if (text2.length === 0)
              return [];
            const parts = text2.trim().split(/\s+/);
            const array = new Array(parts.length);
            for (let i = 0, l = parts.length; i < l; i++) {
              array[i] = parseInt(parts[i]);
            }
            return array;
          }
          function parseId(text2) {
            return text2.substring(1);
          }
          function generateId() {
            return "three_default_" + count++;
          }
          function isEmpty(object) {
            return Object.keys(object).length === 0;
          }
          function parseAsset(xml2) {
            return {
              unit: parseAssetUnit(getElementsByTagName(xml2, "unit")[0]),
              upAxis: parseAssetUpAxis(getElementsByTagName(xml2, "up_axis")[0])
            };
          }
          function parseAssetUnit(xml2) {
            if (xml2 !== void 0 && xml2.hasAttribute("meter") === true) {
              return parseFloat(xml2.getAttribute("meter"));
            } else {
              return 1;
            }
          }
          function parseAssetUpAxis(xml2) {
            return xml2 !== void 0 ? xml2.textContent : "Y_UP";
          }
          function parseLibrary(xml2, libraryName, nodeName, parser) {
            const library2 = getElementsByTagName(xml2, libraryName)[0];
            if (library2 !== void 0) {
              const elements = getElementsByTagName(library2, nodeName);
              for (let i = 0; i < elements.length; i++) {
                parser(elements[i]);
              }
            }
          }
          function buildLibrary(data, builder) {
            for (const name in data) {
              const object = data[name];
              object.build = builder(data[name]);
            }
          }
          function getBuild(data, builder) {
            if (data.build !== void 0)
              return data.build;
            data.build = builder(data);
            return data.build;
          }
          function parseAnimation(xml2) {
            const data = {
              sources: {},
              samplers: {},
              channels: {}
            };
            let hasChildren = false;
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              let id;
              switch (child.nodeName) {
                case "source":
                  id = child.getAttribute("id");
                  data.sources[id] = parseSource(child);
                  break;
                case "sampler":
                  id = child.getAttribute("id");
                  data.samplers[id] = parseAnimationSampler(child);
                  break;
                case "channel":
                  id = child.getAttribute("target");
                  data.channels[id] = parseAnimationChannel(child);
                  break;
                case "animation":
                  parseAnimation(child);
                  hasChildren = true;
                  break;
                default:
                  console.log(child);
              }
            }
            if (hasChildren === false) {
              library.animations[xml2.getAttribute("id") || THREE2.MathUtils.generateUUID()] = data;
            }
          }
          function parseAnimationSampler(xml2) {
            const data = {
              inputs: {}
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "input":
                  const id = parseId(child.getAttribute("source"));
                  const semantic = child.getAttribute("semantic");
                  data.inputs[semantic] = id;
                  break;
              }
            }
            return data;
          }
          function parseAnimationChannel(xml2) {
            const data = {};
            const target = xml2.getAttribute("target");
            let parts = target.split("/");
            const id = parts.shift();
            let sid = parts.shift();
            const arraySyntax = sid.indexOf("(") !== -1;
            const memberSyntax = sid.indexOf(".") !== -1;
            if (memberSyntax) {
              parts = sid.split(".");
              sid = parts.shift();
              data.member = parts.shift();
            } else if (arraySyntax) {
              const indices = sid.split("(");
              sid = indices.shift();
              for (let i = 0; i < indices.length; i++) {
                indices[i] = parseInt(indices[i].replace(/\)/, ""));
              }
              data.indices = indices;
            }
            data.id = id;
            data.sid = sid;
            data.arraySyntax = arraySyntax;
            data.memberSyntax = memberSyntax;
            data.sampler = parseId(xml2.getAttribute("source"));
            return data;
          }
          function buildAnimation(data) {
            const tracks = [];
            const channels = data.channels;
            const samplers = data.samplers;
            const sources = data.sources;
            for (const target in channels) {
              if (channels.hasOwnProperty(target)) {
                const channel = channels[target];
                const sampler = samplers[channel.sampler];
                const inputId = sampler.inputs.INPUT;
                const outputId = sampler.inputs.OUTPUT;
                const inputSource = sources[inputId];
                const outputSource = sources[outputId];
                const animation = buildAnimationChannel(channel, inputSource, outputSource);
                createKeyframeTracks(animation, tracks);
              }
            }
            return tracks;
          }
          function getAnimation(id) {
            return getBuild(library.animations[id], buildAnimation);
          }
          function buildAnimationChannel(channel, inputSource, outputSource) {
            const node = library.nodes[channel.id];
            const object3D = getNode(node.id);
            const transform = node.transforms[channel.sid];
            const defaultMatrix = node.matrix.clone().transpose();
            let time, stride;
            let i, il, j, jl;
            const data = {};
            switch (transform) {
              case "matrix":
                for (i = 0, il = inputSource.array.length; i < il; i++) {
                  time = inputSource.array[i];
                  stride = i * outputSource.stride;
                  if (data[time] === void 0)
                    data[time] = {};
                  if (channel.arraySyntax === true) {
                    const value = outputSource.array[stride];
                    const index = channel.indices[0] + 4 * channel.indices[1];
                    data[time][index] = value;
                  } else {
                    for (j = 0, jl = outputSource.stride; j < jl; j++) {
                      data[time][j] = outputSource.array[stride + j];
                    }
                  }
                }
                break;
              case "translate":
                console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                break;
              case "rotate":
                console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                break;
              case "scale":
                console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
                break;
            }
            const keyframes = prepareAnimationData(data, defaultMatrix);
            const animation = {
              name: object3D.uuid,
              keyframes
            };
            return animation;
          }
          function prepareAnimationData(data, defaultMatrix) {
            const keyframes = [];
            for (const time in data) {
              keyframes.push({
                time: parseFloat(time),
                value: data[time]
              });
            }
            keyframes.sort(ascending);
            for (let i = 0; i < 16; i++) {
              transformAnimationData(keyframes, i, defaultMatrix.elements[i]);
            }
            return keyframes;
            function ascending(a, b) {
              return a.time - b.time;
            }
          }
          const position = new THREE2.Vector3();
          const scale = new THREE2.Vector3();
          const quaternion = new THREE2.Quaternion();
          function createKeyframeTracks(animation, tracks) {
            const keyframes = animation.keyframes;
            const name = animation.name;
            const times = [];
            const positionData = [];
            const quaternionData = [];
            const scaleData = [];
            for (let i = 0, l = keyframes.length; i < l; i++) {
              const keyframe = keyframes[i];
              const time = keyframe.time;
              const value = keyframe.value;
              matrix.fromArray(value).transpose();
              matrix.decompose(position, quaternion, scale);
              times.push(time);
              positionData.push(position.x, position.y, position.z);
              quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
              scaleData.push(scale.x, scale.y, scale.z);
            }
            if (positionData.length > 0)
              tracks.push(new THREE2.VectorKeyframeTrack(name + ".position", times, positionData));
            if (quaternionData.length > 0)
              tracks.push(new THREE2.QuaternionKeyframeTrack(name + ".quaternion", times, quaternionData));
            if (scaleData.length > 0)
              tracks.push(new THREE2.VectorKeyframeTrack(name + ".scale", times, scaleData));
            return tracks;
          }
          function transformAnimationData(keyframes, property, defaultValue) {
            let keyframe;
            let empty = true;
            let i, l;
            for (i = 0, l = keyframes.length; i < l; i++) {
              keyframe = keyframes[i];
              if (keyframe.value[property] === void 0) {
                keyframe.value[property] = null;
              } else {
                empty = false;
              }
            }
            if (empty === true) {
              for (i = 0, l = keyframes.length; i < l; i++) {
                keyframe = keyframes[i];
                keyframe.value[property] = defaultValue;
              }
            } else {
              createMissingKeyframes(keyframes, property);
            }
          }
          function createMissingKeyframes(keyframes, property) {
            let prev, next;
            for (let i = 0, l = keyframes.length; i < l; i++) {
              const keyframe = keyframes[i];
              if (keyframe.value[property] === null) {
                prev = getPrev(keyframes, i, property);
                next = getNext(keyframes, i, property);
                if (prev === null) {
                  keyframe.value[property] = next.value[property];
                  continue;
                }
                if (next === null) {
                  keyframe.value[property] = prev.value[property];
                  continue;
                }
                interpolate(keyframe, prev, next, property);
              }
            }
          }
          function getPrev(keyframes, i, property) {
            while (i >= 0) {
              const keyframe = keyframes[i];
              if (keyframe.value[property] !== null)
                return keyframe;
              i--;
            }
            return null;
          }
          function getNext(keyframes, i, property) {
            while (i < keyframes.length) {
              const keyframe = keyframes[i];
              if (keyframe.value[property] !== null)
                return keyframe;
              i++;
            }
            return null;
          }
          function interpolate(key, prev, next, property) {
            if (next.time - prev.time === 0) {
              key.value[property] = prev.value[property];
              return;
            }
            key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];
          }
          function parseAnimationClip(xml2) {
            const data = {
              name: xml2.getAttribute("id") || "default",
              start: parseFloat(xml2.getAttribute("start") || 0),
              end: parseFloat(xml2.getAttribute("end") || 0),
              animations: []
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "instance_animation":
                  data.animations.push(parseId(child.getAttribute("url")));
                  break;
              }
            }
            library.clips[xml2.getAttribute("id")] = data;
          }
          function buildAnimationClip(data) {
            const tracks = [];
            const name = data.name;
            const duration = data.end - data.start || -1;
            const animations2 = data.animations;
            for (let i = 0, il = animations2.length; i < il; i++) {
              const animationTracks = getAnimation(animations2[i]);
              for (let j = 0, jl = animationTracks.length; j < jl; j++) {
                tracks.push(animationTracks[j]);
              }
            }
            return new THREE2.AnimationClip(name, duration, tracks);
          }
          function getAnimationClip(id) {
            return getBuild(library.clips[id], buildAnimationClip);
          }
          function parseController(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "skin":
                  data.id = parseId(child.getAttribute("source"));
                  data.skin = parseSkin(child);
                  break;
                case "morph":
                  data.id = parseId(child.getAttribute("source"));
                  console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
                  break;
              }
            }
            library.controllers[xml2.getAttribute("id")] = data;
          }
          function parseSkin(xml2) {
            const data = {
              sources: {}
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "bind_shape_matrix":
                  data.bindShapeMatrix = parseFloats(child.textContent);
                  break;
                case "source":
                  const id = child.getAttribute("id");
                  data.sources[id] = parseSource(child);
                  break;
                case "joints":
                  data.joints = parseJoints(child);
                  break;
                case "vertex_weights":
                  data.vertexWeights = parseVertexWeights(child);
                  break;
              }
            }
            return data;
          }
          function parseJoints(xml2) {
            const data = {
              inputs: {}
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "input":
                  const semantic = child.getAttribute("semantic");
                  const id = parseId(child.getAttribute("source"));
                  data.inputs[semantic] = id;
                  break;
              }
            }
            return data;
          }
          function parseVertexWeights(xml2) {
            const data = {
              inputs: {}
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "input":
                  const semantic = child.getAttribute("semantic");
                  const id = parseId(child.getAttribute("source"));
                  const offset = parseInt(child.getAttribute("offset"));
                  data.inputs[semantic] = {
                    id,
                    offset
                  };
                  break;
                case "vcount":
                  data.vcount = parseInts(child.textContent);
                  break;
                case "v":
                  data.v = parseInts(child.textContent);
                  break;
              }
            }
            return data;
          }
          function buildController(data) {
            const build = {
              id: data.id
            };
            const geometry = library.geometries[build.id];
            if (data.skin !== void 0) {
              build.skin = buildSkin(data.skin);
              geometry.sources.skinIndices = build.skin.indices;
              geometry.sources.skinWeights = build.skin.weights;
            }
            return build;
          }
          function buildSkin(data) {
            const BONE_LIMIT = 4;
            const build = {
              joints: [],
              // this must be an array to preserve the joint order
              indices: {
                array: [],
                stride: BONE_LIMIT
              },
              weights: {
                array: [],
                stride: BONE_LIMIT
              }
            };
            const sources = data.sources;
            const vertexWeights = data.vertexWeights;
            const vcount = vertexWeights.vcount;
            const v = vertexWeights.v;
            const jointOffset = vertexWeights.inputs.JOINT.offset;
            const weightOffset = vertexWeights.inputs.WEIGHT.offset;
            const jointSource = data.sources[data.joints.inputs.JOINT];
            const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];
            const weights = sources[vertexWeights.inputs.WEIGHT.id].array;
            let stride = 0;
            let i, j, l;
            for (i = 0, l = vcount.length; i < l; i++) {
              const jointCount = vcount[i];
              const vertexSkinData = [];
              for (j = 0; j < jointCount; j++) {
                const skinIndex = v[stride + jointOffset];
                const weightId = v[stride + weightOffset];
                const skinWeight = weights[weightId];
                vertexSkinData.push({
                  index: skinIndex,
                  weight: skinWeight
                });
                stride += 2;
              }
              vertexSkinData.sort(descending);
              for (j = 0; j < BONE_LIMIT; j++) {
                const d = vertexSkinData[j];
                if (d !== void 0) {
                  build.indices.array.push(d.index);
                  build.weights.array.push(d.weight);
                } else {
                  build.indices.array.push(0);
                  build.weights.array.push(0);
                }
              }
            }
            if (data.bindShapeMatrix) {
              build.bindMatrix = new THREE2.Matrix4().fromArray(data.bindShapeMatrix).transpose();
            } else {
              build.bindMatrix = new THREE2.Matrix4().identity();
            }
            for (i = 0, l = jointSource.array.length; i < l; i++) {
              const name = jointSource.array[i];
              const boneInverse = new THREE2.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();
              build.joints.push({
                name,
                boneInverse
              });
            }
            return build;
            function descending(a, b) {
              return b.weight - a.weight;
            }
          }
          function getController(id) {
            return getBuild(library.controllers[id], buildController);
          }
          function parseImage(xml2) {
            const data = {
              init_from: getElementsByTagName(xml2, "init_from")[0].textContent
            };
            library.images[xml2.getAttribute("id")] = data;
          }
          function buildImage(data) {
            if (data.build !== void 0)
              return data.build;
            return data.init_from;
          }
          function getImage(id) {
            const data = library.images[id];
            if (data !== void 0) {
              return getBuild(data, buildImage);
            }
            console.warn("THREE.ColladaLoader: Couldn't find image with ID:", id);
            return null;
          }
          function parseEffect(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "profile_COMMON":
                  data.profile = parseEffectProfileCOMMON(child);
                  break;
              }
            }
            library.effects[xml2.getAttribute("id")] = data;
          }
          function parseEffectProfileCOMMON(xml2) {
            const data = {
              surfaces: {},
              samplers: {}
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "newparam":
                  parseEffectNewparam(child, data);
                  break;
                case "technique":
                  data.technique = parseEffectTechnique(child);
                  break;
                case "extra":
                  data.extra = parseEffectExtra(child);
                  break;
              }
            }
            return data;
          }
          function parseEffectNewparam(xml2, data) {
            const sid = xml2.getAttribute("sid");
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "surface":
                  data.surfaces[sid] = parseEffectSurface(child);
                  break;
                case "sampler2D":
                  data.samplers[sid] = parseEffectSampler(child);
                  break;
              }
            }
          }
          function parseEffectSurface(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "init_from":
                  data.init_from = child.textContent;
                  break;
              }
            }
            return data;
          }
          function parseEffectSampler(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "source":
                  data.source = child.textContent;
                  break;
              }
            }
            return data;
          }
          function parseEffectTechnique(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "constant":
                case "lambert":
                case "blinn":
                case "phong":
                  data.type = child.nodeName;
                  data.parameters = parseEffectParameters(child);
                  break;
              }
            }
            return data;
          }
          function parseEffectParameters(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "emission":
                case "diffuse":
                case "specular":
                case "bump":
                case "ambient":
                case "shininess":
                case "transparency":
                  data[child.nodeName] = parseEffectParameter(child);
                  break;
                case "transparent":
                  data[child.nodeName] = {
                    opaque: child.getAttribute("opaque"),
                    data: parseEffectParameter(child)
                  };
                  break;
              }
            }
            return data;
          }
          function parseEffectParameter(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "color":
                  data[child.nodeName] = parseFloats(child.textContent);
                  break;
                case "float":
                  data[child.nodeName] = parseFloat(child.textContent);
                  break;
                case "texture":
                  data[child.nodeName] = {
                    id: child.getAttribute("texture"),
                    extra: parseEffectParameterTexture(child)
                  };
                  break;
              }
            }
            return data;
          }
          function parseEffectParameterTexture(xml2) {
            const data = {
              technique: {}
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "extra":
                  parseEffectParameterTextureExtra(child, data);
                  break;
              }
            }
            return data;
          }
          function parseEffectParameterTextureExtra(xml2, data) {
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "technique":
                  parseEffectParameterTextureExtraTechnique(child, data);
                  break;
              }
            }
          }
          function parseEffectParameterTextureExtraTechnique(xml2, data) {
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "repeatU":
                case "repeatV":
                case "offsetU":
                case "offsetV":
                  data.technique[child.nodeName] = parseFloat(child.textContent);
                  break;
                case "wrapU":
                case "wrapV":
                  if (child.textContent.toUpperCase() === "TRUE") {
                    data.technique[child.nodeName] = 1;
                  } else if (child.textContent.toUpperCase() === "FALSE") {
                    data.technique[child.nodeName] = 0;
                  } else {
                    data.technique[child.nodeName] = parseInt(child.textContent);
                  }
                  break;
              }
            }
          }
          function parseEffectExtra(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "technique":
                  data.technique = parseEffectExtraTechnique(child);
                  break;
              }
            }
            return data;
          }
          function parseEffectExtraTechnique(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "double_sided":
                  data[child.nodeName] = parseInt(child.textContent);
                  break;
              }
            }
            return data;
          }
          function buildEffect(data) {
            return data;
          }
          function getEffect(id) {
            return getBuild(library.effects[id], buildEffect);
          }
          function parseMaterial(xml2) {
            const data = {
              name: xml2.getAttribute("name")
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "instance_effect":
                  data.url = parseId(child.getAttribute("url"));
                  break;
              }
            }
            library.materials[xml2.getAttribute("id")] = data;
          }
          function getTextureLoader(image) {
            let loader;
            let extension = image.slice((image.lastIndexOf(".") - 1 >>> 0) + 2);
            extension = extension.toLowerCase();
            switch (extension) {
              case "tga":
                loader = tgaLoader;
                break;
              default:
                loader = textureLoader;
            }
            return loader;
          }
          function buildMaterial(data) {
            const effect = getEffect(data.url);
            const technique = effect.profile.technique;
            const extra = effect.profile.extra;
            let material;
            switch (technique.type) {
              case "phong":
              case "blinn":
                material = new THREE2.MeshPhongMaterial();
                break;
              case "lambert":
                material = new THREE2.MeshLambertMaterial();
                break;
              default:
                material = new THREE2.MeshBasicMaterial();
                break;
            }
            material.name = data.name || "";
            function getTexture(textureObject) {
              const sampler = effect.profile.samplers[textureObject.id];
              let image = null;
              if (sampler !== void 0) {
                const surface = effect.profile.surfaces[sampler.source];
                image = getImage(surface.init_from);
              } else {
                console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).");
                image = getImage(textureObject.id);
              }
              if (image !== null) {
                const loader = getTextureLoader(image);
                if (loader !== void 0) {
                  const texture = loader.load(image);
                  const extra2 = textureObject.extra;
                  if (extra2 !== void 0 && extra2.technique !== void 0 && isEmpty(extra2.technique) === false) {
                    const technique2 = extra2.technique;
                    texture.wrapS = technique2.wrapU ? THREE2.RepeatWrapping : THREE2.ClampToEdgeWrapping;
                    texture.wrapT = technique2.wrapV ? THREE2.RepeatWrapping : THREE2.ClampToEdgeWrapping;
                    texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);
                    texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);
                  } else {
                    texture.wrapS = THREE2.RepeatWrapping;
                    texture.wrapT = THREE2.RepeatWrapping;
                  }
                  return texture;
                } else {
                  console.warn("THREE.ColladaLoader: THREE.Loader for texture %s not found.", image);
                  return null;
                }
              } else {
                console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", textureObject.id);
                return null;
              }
            }
            const parameters = technique.parameters;
            for (const key in parameters) {
              const parameter = parameters[key];
              switch (key) {
                case "diffuse":
                  if (parameter.color)
                    material.color.fromArray(parameter.color);
                  if (parameter.texture)
                    material.map = getTexture(parameter.texture);
                  break;
                case "specular":
                  if (parameter.color && material.specular)
                    material.specular.fromArray(parameter.color);
                  if (parameter.texture)
                    material.specularMap = getTexture(parameter.texture);
                  break;
                case "bump":
                  if (parameter.texture)
                    material.normalMap = getTexture(parameter.texture);
                  break;
                case "ambient":
                  if (parameter.texture)
                    material.lightMap = getTexture(parameter.texture);
                  break;
                case "shininess":
                  if (parameter.float && material.shininess)
                    material.shininess = parameter.float;
                  break;
                case "emission":
                  if (parameter.color && material.emissive)
                    material.emissive.fromArray(parameter.color);
                  if (parameter.texture)
                    material.emissiveMap = getTexture(parameter.texture);
                  break;
              }
            }
            let transparent = parameters["transparent"];
            let transparency = parameters["transparency"];
            if (transparency === void 0 && transparent) {
              transparency = {
                float: 1
              };
            }
            if (transparent === void 0 && transparency) {
              transparent = {
                opaque: "A_ONE",
                data: {
                  color: [1, 1, 1, 1]
                }
              };
            }
            if (transparent && transparency) {
              if (transparent.data.texture) {
                material.transparent = true;
              } else {
                const color = transparent.data.color;
                switch (transparent.opaque) {
                  case "A_ONE":
                    material.opacity = color[3] * transparency.float;
                    break;
                  case "RGB_ZERO":
                    material.opacity = 1 - color[0] * transparency.float;
                    break;
                  case "A_ZERO":
                    material.opacity = 1 - color[3] * transparency.float;
                    break;
                  case "RGB_ONE":
                    material.opacity = color[0] * transparency.float;
                    break;
                  default:
                    console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque);
                }
                if (material.opacity < 1)
                  material.transparent = true;
              }
            }
            if (extra !== void 0 && extra.technique !== void 0 && extra.technique.double_sided === 1) {
              material.side = THREE2.DoubleSide;
            }
            return material;
          }
          function getMaterial(id) {
            return getBuild(library.materials[id], buildMaterial);
          }
          function parseCamera(xml2) {
            const data = {
              name: xml2.getAttribute("name")
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "optics":
                  data.optics = parseCameraOptics(child);
                  break;
              }
            }
            library.cameras[xml2.getAttribute("id")] = data;
          }
          function parseCameraOptics(xml2) {
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              switch (child.nodeName) {
                case "technique_common":
                  return parseCameraTechnique(child);
              }
            }
            return {};
          }
          function parseCameraTechnique(xml2) {
            const data = {};
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              switch (child.nodeName) {
                case "perspective":
                case "orthographic":
                  data.technique = child.nodeName;
                  data.parameters = parseCameraParameters(child);
                  break;
              }
            }
            return data;
          }
          function parseCameraParameters(xml2) {
            const data = {};
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              switch (child.nodeName) {
                case "xfov":
                case "yfov":
                case "xmag":
                case "ymag":
                case "znear":
                case "zfar":
                case "aspect_ratio":
                  data[child.nodeName] = parseFloat(child.textContent);
                  break;
              }
            }
            return data;
          }
          function buildCamera(data) {
            let camera;
            switch (data.optics.technique) {
              case "perspective":
                camera = new THREE2.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);
                break;
              case "orthographic":
                let ymag = data.optics.parameters.ymag;
                let xmag = data.optics.parameters.xmag;
                const aspectRatio = data.optics.parameters.aspect_ratio;
                xmag = xmag === void 0 ? ymag * aspectRatio : xmag;
                ymag = ymag === void 0 ? xmag / aspectRatio : ymag;
                xmag *= 0.5;
                ymag *= 0.5;
                camera = new THREE2.OrthographicCamera(
                  -xmag,
                  xmag,
                  ymag,
                  -ymag,
                  // left, right, top, bottom
                  data.optics.parameters.znear,
                  data.optics.parameters.zfar
                );
                break;
              default:
                camera = new THREE2.PerspectiveCamera();
                break;
            }
            camera.name = data.name || "";
            return camera;
          }
          function getCamera(id) {
            const data = library.cameras[id];
            if (data !== void 0) {
              return getBuild(data, buildCamera);
            }
            console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", id);
            return null;
          }
          function parseLight(xml2) {
            let data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "technique_common":
                  data = parseLightTechnique(child);
                  break;
              }
            }
            library.lights[xml2.getAttribute("id")] = data;
          }
          function parseLightTechnique(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "directional":
                case "point":
                case "spot":
                case "ambient":
                  data.technique = child.nodeName;
                  data.parameters = parseLightParameters(child);
              }
            }
            return data;
          }
          function parseLightParameters(xml2) {
            const data = {};
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "color":
                  const array = parseFloats(child.textContent);
                  data.color = new THREE2.Color().fromArray(array);
                  break;
                case "falloff_angle":
                  data.falloffAngle = parseFloat(child.textContent);
                  break;
                case "quadratic_attenuation":
                  const f = parseFloat(child.textContent);
                  data.distance = f ? Math.sqrt(1 / f) : 0;
                  break;
              }
            }
            return data;
          }
          function buildLight(data) {
            let light;
            switch (data.technique) {
              case "directional":
                light = new THREE2.DirectionalLight();
                break;
              case "point":
                light = new THREE2.PointLight();
                break;
              case "spot":
                light = new THREE2.SpotLight();
                break;
              case "ambient":
                light = new THREE2.AmbientLight();
                break;
            }
            if (data.parameters.color)
              light.color.copy(data.parameters.color);
            if (data.parameters.distance)
              light.distance = data.parameters.distance;
            return light;
          }
          function getLight(id) {
            const data = library.lights[id];
            if (data !== void 0) {
              return getBuild(data, buildLight);
            }
            console.warn("THREE.ColladaLoader: Couldn't find light with ID:", id);
            return null;
          }
          function parseGeometry(xml2) {
            const data = {
              name: xml2.getAttribute("name"),
              sources: {},
              vertices: {},
              primitives: []
            };
            const mesh = getElementsByTagName(xml2, "mesh")[0];
            if (mesh === void 0)
              return;
            for (let i = 0; i < mesh.childNodes.length; i++) {
              const child = mesh.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              const id = child.getAttribute("id");
              switch (child.nodeName) {
                case "source":
                  data.sources[id] = parseSource(child);
                  break;
                case "vertices":
                  data.vertices = parseGeometryVertices(child);
                  break;
                case "polygons":
                  console.warn("THREE.ColladaLoader: Unsupported primitive type: ", child.nodeName);
                  break;
                case "lines":
                case "linestrips":
                case "polylist":
                case "triangles":
                  data.primitives.push(parseGeometryPrimitive(child));
                  break;
                default:
                  console.log(child);
              }
            }
            library.geometries[xml2.getAttribute("id")] = data;
          }
          function parseSource(xml2) {
            const data = {
              array: [],
              stride: 3
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "float_array":
                  data.array = parseFloats(child.textContent);
                  break;
                case "Name_array":
                  data.array = parseStrings(child.textContent);
                  break;
                case "technique_common":
                  const accessor = getElementsByTagName(child, "accessor")[0];
                  if (accessor !== void 0) {
                    data.stride = parseInt(accessor.getAttribute("stride"));
                  }
                  break;
              }
            }
            return data;
          }
          function parseGeometryVertices(xml2) {
            const data = {};
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              data[child.getAttribute("semantic")] = parseId(child.getAttribute("source"));
            }
            return data;
          }
          function parseGeometryPrimitive(xml2) {
            const primitive = {
              type: xml2.nodeName,
              material: xml2.getAttribute("material"),
              count: parseInt(xml2.getAttribute("count")),
              inputs: {},
              stride: 0,
              hasUV: false
            };
            for (let i = 0, l = xml2.childNodes.length; i < l; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "input":
                  const id = parseId(child.getAttribute("source"));
                  const semantic = child.getAttribute("semantic");
                  const offset = parseInt(child.getAttribute("offset"));
                  const set = parseInt(child.getAttribute("set"));
                  const inputname = set > 0 ? semantic + set : semantic;
                  primitive.inputs[inputname] = {
                    id,
                    offset
                  };
                  primitive.stride = Math.max(primitive.stride, offset + 1);
                  if (semantic === "TEXCOORD")
                    primitive.hasUV = true;
                  break;
                case "vcount":
                  primitive.vcount = parseInts(child.textContent);
                  break;
                case "p":
                  primitive.p = parseInts(child.textContent);
                  break;
              }
            }
            return primitive;
          }
          function groupPrimitives(primitives) {
            const build = {};
            for (let i = 0; i < primitives.length; i++) {
              const primitive = primitives[i];
              if (build[primitive.type] === void 0)
                build[primitive.type] = [];
              build[primitive.type].push(primitive);
            }
            return build;
          }
          function checkUVCoordinates(primitives) {
            let count2 = 0;
            for (let i = 0, l = primitives.length; i < l; i++) {
              const primitive = primitives[i];
              if (primitive.hasUV === true) {
                count2++;
              }
            }
            if (count2 > 0 && count2 < primitives.length) {
              primitives.uvsNeedsFix = true;
            }
          }
          function buildGeometry(data) {
            const build = {};
            const sources = data.sources;
            const vertices = data.vertices;
            const primitives = data.primitives;
            if (primitives.length === 0)
              return {};
            const groupedPrimitives = groupPrimitives(primitives);
            for (const type in groupedPrimitives) {
              const primitiveType = groupedPrimitives[type];
              checkUVCoordinates(primitiveType);
              build[type] = buildGeometryType(primitiveType, sources, vertices);
            }
            return build;
          }
          function buildGeometryType(primitives, sources, vertices) {
            const build = {};
            const position2 = {
              array: [],
              stride: 0
            };
            const normal = {
              array: [],
              stride: 0
            };
            const uv = {
              array: [],
              stride: 0
            };
            const uv2 = {
              array: [],
              stride: 0
            };
            const color = {
              array: [],
              stride: 0
            };
            const skinIndex = {
              array: [],
              stride: 4
            };
            const skinWeight = {
              array: [],
              stride: 4
            };
            const geometry = new THREE2.BufferGeometry();
            const materialKeys = [];
            let start = 0;
            for (let p = 0; p < primitives.length; p++) {
              const primitive = primitives[p];
              const inputs = primitive.inputs;
              let count2 = 0;
              switch (primitive.type) {
                case "lines":
                case "linestrips":
                  count2 = primitive.count * 2;
                  break;
                case "triangles":
                  count2 = primitive.count * 3;
                  break;
                case "polylist":
                  for (let g = 0; g < primitive.count; g++) {
                    const vc = primitive.vcount[g];
                    switch (vc) {
                      case 3:
                        count2 += 3;
                        break;
                      case 4:
                        count2 += 6;
                        break;
                      default:
                        count2 += (vc - 2) * 3;
                        break;
                    }
                  }
                  break;
                default:
                  console.warn("THREE.ColladaLoader: Unknow primitive type:", primitive.type);
              }
              geometry.addGroup(start, count2, p);
              start += count2;
              if (primitive.material) {
                materialKeys.push(primitive.material);
              }
              for (const name in inputs) {
                const input = inputs[name];
                switch (name) {
                  case "VERTEX":
                    for (const key in vertices) {
                      const id = vertices[key];
                      switch (key) {
                        case "POSITION":
                          const prevLength = position2.array.length;
                          buildGeometryData(primitive, sources[id], input.offset, position2.array);
                          position2.stride = sources[id].stride;
                          if (sources.skinWeights && sources.skinIndices) {
                            buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);
                            buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);
                          }
                          if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {
                            const count3 = (position2.array.length - prevLength) / position2.stride;
                            for (let i = 0; i < count3; i++) {
                              uv.array.push(0, 0);
                            }
                          }
                          break;
                        case "NORMAL":
                          buildGeometryData(primitive, sources[id], input.offset, normal.array);
                          normal.stride = sources[id].stride;
                          break;
                        case "COLOR":
                          buildGeometryData(primitive, sources[id], input.offset, color.array);
                          color.stride = sources[id].stride;
                          break;
                        case "TEXCOORD":
                          buildGeometryData(primitive, sources[id], input.offset, uv.array);
                          uv.stride = sources[id].stride;
                          break;
                        case "TEXCOORD1":
                          buildGeometryData(primitive, sources[id], input.offset, uv2.array);
                          uv.stride = sources[id].stride;
                          break;
                        default:
                          console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key);
                      }
                    }
                    break;
                  case "NORMAL":
                    buildGeometryData(primitive, sources[input.id], input.offset, normal.array);
                    normal.stride = sources[input.id].stride;
                    break;
                  case "COLOR":
                    buildGeometryData(primitive, sources[input.id], input.offset, color.array);
                    color.stride = sources[input.id].stride;
                    break;
                  case "TEXCOORD":
                    buildGeometryData(primitive, sources[input.id], input.offset, uv.array);
                    uv.stride = sources[input.id].stride;
                    break;
                  case "TEXCOORD1":
                    buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);
                    uv2.stride = sources[input.id].stride;
                    break;
                }
              }
            }
            if (position2.array.length > 0)
              geometry.setAttribute("position", new THREE2.Float32BufferAttribute(position2.array, position2.stride));
            if (normal.array.length > 0)
              geometry.setAttribute("normal", new THREE2.Float32BufferAttribute(normal.array, normal.stride));
            if (color.array.length > 0)
              geometry.setAttribute("color", new THREE2.Float32BufferAttribute(color.array, color.stride));
            if (uv.array.length > 0)
              geometry.setAttribute("uv", new THREE2.Float32BufferAttribute(uv.array, uv.stride));
            if (uv2.array.length > 0)
              geometry.setAttribute("uv2", new THREE2.Float32BufferAttribute(uv2.array, uv2.stride));
            if (skinIndex.array.length > 0)
              geometry.setAttribute("skinIndex", new THREE2.Float32BufferAttribute(skinIndex.array, skinIndex.stride));
            if (skinWeight.array.length > 0)
              geometry.setAttribute("skinWeight", new THREE2.Float32BufferAttribute(skinWeight.array, skinWeight.stride));
            build.data = geometry;
            build.type = primitives[0].type;
            build.materialKeys = materialKeys;
            return build;
          }
          function buildGeometryData(primitive, source, offset, array) {
            const indices = primitive.p;
            const stride = primitive.stride;
            const vcount = primitive.vcount;
            function pushVector(i) {
              let index = indices[i + offset] * sourceStride;
              const length = index + sourceStride;
              for (; index < length; index++) {
                array.push(sourceArray[index]);
              }
            }
            const sourceArray = source.array;
            const sourceStride = source.stride;
            if (primitive.vcount !== void 0) {
              let index = 0;
              for (let i = 0, l = vcount.length; i < l; i++) {
                const count2 = vcount[i];
                if (count2 === 4) {
                  const a = index + stride * 0;
                  const b = index + stride * 1;
                  const c = index + stride * 2;
                  const d = index + stride * 3;
                  pushVector(a);
                  pushVector(b);
                  pushVector(d);
                  pushVector(b);
                  pushVector(c);
                  pushVector(d);
                } else if (count2 === 3) {
                  const a = index + stride * 0;
                  const b = index + stride * 1;
                  const c = index + stride * 2;
                  pushVector(a);
                  pushVector(b);
                  pushVector(c);
                } else if (count2 > 4) {
                  for (let k = 1, kl = count2 - 2; k <= kl; k++) {
                    const a = index + stride * 0;
                    const b = index + stride * k;
                    const c = index + stride * (k + 1);
                    pushVector(a);
                    pushVector(b);
                    pushVector(c);
                  }
                }
                index += stride * count2;
              }
            } else {
              for (let i = 0, l = indices.length; i < l; i += stride) {
                pushVector(i);
              }
            }
          }
          function getGeometry(id) {
            return getBuild(library.geometries[id], buildGeometry);
          }
          function parseKinematicsModel(xml2) {
            const data = {
              name: xml2.getAttribute("name") || "",
              joints: {},
              links: []
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "technique_common":
                  parseKinematicsTechniqueCommon(child, data);
                  break;
              }
            }
            library.kinematicsModels[xml2.getAttribute("id")] = data;
          }
          function buildKinematicsModel(data) {
            if (data.build !== void 0)
              return data.build;
            return data;
          }
          function getKinematicsModel(id) {
            return getBuild(library.kinematicsModels[id], buildKinematicsModel);
          }
          function parseKinematicsTechniqueCommon(xml2, data) {
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "joint":
                  data.joints[child.getAttribute("sid")] = parseKinematicsJoint(child);
                  break;
                case "link":
                  data.links.push(parseKinematicsLink(child));
                  break;
              }
            }
          }
          function parseKinematicsJoint(xml2) {
            let data;
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "prismatic":
                case "revolute":
                  data = parseKinematicsJointParameter(child);
                  break;
              }
            }
            return data;
          }
          function parseKinematicsJointParameter(xml2) {
            const data = {
              sid: xml2.getAttribute("sid"),
              name: xml2.getAttribute("name") || "",
              axis: new THREE2.Vector3(),
              limits: {
                min: 0,
                max: 0
              },
              type: xml2.nodeName,
              static: false,
              zeroPosition: 0,
              middlePosition: 0
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "axis":
                  const array = parseFloats(child.textContent);
                  data.axis.fromArray(array);
                  break;
                case "limits":
                  const max = child.getElementsByTagName("max")[0];
                  const min = child.getElementsByTagName("min")[0];
                  data.limits.max = parseFloat(max.textContent);
                  data.limits.min = parseFloat(min.textContent);
                  break;
              }
            }
            if (data.limits.min >= data.limits.max) {
              data.static = true;
            }
            data.middlePosition = (data.limits.min + data.limits.max) / 2;
            return data;
          }
          function parseKinematicsLink(xml2) {
            const data = {
              sid: xml2.getAttribute("sid"),
              name: xml2.getAttribute("name") || "",
              attachments: [],
              transforms: []
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "attachment_full":
                  data.attachments.push(parseKinematicsAttachment(child));
                  break;
                case "matrix":
                case "translate":
                case "rotate":
                  data.transforms.push(parseKinematicsTransform(child));
                  break;
              }
            }
            return data;
          }
          function parseKinematicsAttachment(xml2) {
            const data = {
              joint: xml2.getAttribute("joint").split("/").pop(),
              transforms: [],
              links: []
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "link":
                  data.links.push(parseKinematicsLink(child));
                  break;
                case "matrix":
                case "translate":
                case "rotate":
                  data.transforms.push(parseKinematicsTransform(child));
                  break;
              }
            }
            return data;
          }
          function parseKinematicsTransform(xml2) {
            const data = {
              type: xml2.nodeName
            };
            const array = parseFloats(xml2.textContent);
            switch (data.type) {
              case "matrix":
                data.obj = new THREE2.Matrix4();
                data.obj.fromArray(array).transpose();
                break;
              case "translate":
                data.obj = new THREE2.Vector3();
                data.obj.fromArray(array);
                break;
              case "rotate":
                data.obj = new THREE2.Vector3();
                data.obj.fromArray(array);
                data.angle = THREE2.MathUtils.degToRad(array[3]);
                break;
            }
            return data;
          }
          function parsePhysicsModel(xml2) {
            const data = {
              name: xml2.getAttribute("name") || "",
              rigidBodies: {}
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "rigid_body":
                  data.rigidBodies[child.getAttribute("name")] = {};
                  parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute("name")]);
                  break;
              }
            }
            library.physicsModels[xml2.getAttribute("id")] = data;
          }
          function parsePhysicsRigidBody(xml2, data) {
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "technique_common":
                  parsePhysicsTechniqueCommon(child, data);
                  break;
              }
            }
          }
          function parsePhysicsTechniqueCommon(xml2, data) {
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "inertia":
                  data.inertia = parseFloats(child.textContent);
                  break;
                case "mass":
                  data.mass = parseFloats(child.textContent)[0];
                  break;
              }
            }
          }
          function parseKinematicsScene(xml2) {
            const data = {
              bindJointAxis: []
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "bind_joint_axis":
                  data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
                  break;
              }
            }
            library.kinematicsScenes[parseId(xml2.getAttribute("url"))] = data;
          }
          function parseKinematicsBindJointAxis(xml2) {
            const data = {
              target: xml2.getAttribute("target").split("/").pop()
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              switch (child.nodeName) {
                case "axis":
                  const param = child.getElementsByTagName("param")[0];
                  data.axis = param.textContent;
                  const tmpJointIndex = data.axis.split("inst_").pop().split("axis")[0];
                  data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);
                  break;
              }
            }
            return data;
          }
          function buildKinematicsScene(data) {
            if (data.build !== void 0)
              return data.build;
            return data;
          }
          function getKinematicsScene(id) {
            return getBuild(library.kinematicsScenes[id], buildKinematicsScene);
          }
          function setupKinematics() {
            const kinematicsModelId = Object.keys(library.kinematicsModels)[0];
            const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];
            const visualSceneId = Object.keys(library.visualScenes)[0];
            if (kinematicsModelId === void 0 || kinematicsSceneId === void 0)
              return;
            const kinematicsModel = getKinematicsModel(kinematicsModelId);
            const kinematicsScene = getKinematicsScene(kinematicsSceneId);
            const visualScene = getVisualScene(visualSceneId);
            const bindJointAxis = kinematicsScene.bindJointAxis;
            const jointMap = {};
            for (let i = 0, l = bindJointAxis.length; i < l; i++) {
              const axis = bindJointAxis[i];
              const targetElement = collada.querySelector('[sid="' + axis.target + '"]');
              if (targetElement) {
                const parentVisualElement = targetElement.parentElement;
                connect(axis.jointIndex, parentVisualElement);
              }
            }
            function connect(jointIndex, visualElement) {
              const visualElementName = visualElement.getAttribute("name");
              const joint = kinematicsModel.joints[jointIndex];
              visualScene.traverse(function(object) {
                if (object.name === visualElementName) {
                  jointMap[jointIndex] = {
                    object,
                    transforms: buildTransformList(visualElement),
                    joint,
                    position: joint.zeroPosition
                  };
                }
              });
            }
            const m0 = new THREE2.Matrix4();
            kinematics = {
              joints: kinematicsModel && kinematicsModel.joints,
              getJointValue: function(jointIndex) {
                const jointData = jointMap[jointIndex];
                if (jointData) {
                  return jointData.position;
                } else {
                  console.warn("THREE.ColladaLoader: Joint " + jointIndex + " doesn't exist.");
                }
              },
              setJointValue: function(jointIndex, value) {
                const jointData = jointMap[jointIndex];
                if (jointData) {
                  const joint = jointData.joint;
                  if (value > joint.limits.max || value < joint.limits.min) {
                    console.warn("THREE.ColladaLoader: Joint " + jointIndex + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ").");
                  } else if (joint.static) {
                    console.warn("THREE.ColladaLoader: Joint " + jointIndex + " is static.");
                  } else {
                    const object = jointData.object;
                    const axis = joint.axis;
                    const transforms = jointData.transforms;
                    matrix.identity();
                    for (let i = 0; i < transforms.length; i++) {
                      const transform = transforms[i];
                      if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {
                        switch (joint.type) {
                          case "revolute":
                            matrix.multiply(m0.makeRotationAxis(axis, THREE2.MathUtils.degToRad(value)));
                            break;
                          case "prismatic":
                            matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));
                            break;
                          default:
                            console.warn("THREE.ColladaLoader: Unknown joint type: " + joint.type);
                            break;
                        }
                      } else {
                        switch (transform.type) {
                          case "matrix":
                            matrix.multiply(transform.obj);
                            break;
                          case "translate":
                            matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                            break;
                          case "scale":
                            matrix.scale(transform.obj);
                            break;
                          case "rotate":
                            matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));
                            break;
                        }
                      }
                    }
                    object.matrix.copy(matrix);
                    object.matrix.decompose(object.position, object.quaternion, object.scale);
                    jointMap[jointIndex].position = value;
                  }
                } else {
                  console.log("THREE.ColladaLoader: " + jointIndex + " does not exist.");
                }
              }
            };
          }
          function buildTransformList(node) {
            const transforms = [];
            const xml2 = collada.querySelector('[id="' + node.id + '"]');
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              let array, vector2;
              switch (child.nodeName) {
                case "matrix":
                  array = parseFloats(child.textContent);
                  const matrix2 = new THREE2.Matrix4().fromArray(array).transpose();
                  transforms.push({
                    sid: child.getAttribute("sid"),
                    type: child.nodeName,
                    obj: matrix2
                  });
                  break;
                case "translate":
                case "scale":
                  array = parseFloats(child.textContent);
                  vector2 = new THREE2.Vector3().fromArray(array);
                  transforms.push({
                    sid: child.getAttribute("sid"),
                    type: child.nodeName,
                    obj: vector2
                  });
                  break;
                case "rotate":
                  array = parseFloats(child.textContent);
                  vector2 = new THREE2.Vector3().fromArray(array);
                  const angle = THREE2.MathUtils.degToRad(array[3]);
                  transforms.push({
                    sid: child.getAttribute("sid"),
                    type: child.nodeName,
                    obj: vector2,
                    angle
                  });
                  break;
              }
            }
            return transforms;
          }
          function prepareNodes(xml2) {
            const elements = xml2.getElementsByTagName("node");
            for (let i = 0; i < elements.length; i++) {
              const element = elements[i];
              if (element.hasAttribute("id") === false) {
                element.setAttribute("id", generateId());
              }
            }
          }
          const matrix = new THREE2.Matrix4();
          const vector = new THREE2.Vector3();
          function parseNode(xml2) {
            const data = {
              name: xml2.getAttribute("name") || "",
              type: xml2.getAttribute("type"),
              id: xml2.getAttribute("id"),
              sid: xml2.getAttribute("sid"),
              matrix: new THREE2.Matrix4(),
              nodes: [],
              instanceCameras: [],
              instanceControllers: [],
              instanceLights: [],
              instanceGeometries: [],
              instanceNodes: [],
              transforms: {}
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              if (child.nodeType !== 1)
                continue;
              let array;
              switch (child.nodeName) {
                case "node":
                  data.nodes.push(child.getAttribute("id"));
                  parseNode(child);
                  break;
                case "instance_camera":
                  data.instanceCameras.push(parseId(child.getAttribute("url")));
                  break;
                case "instance_controller":
                  data.instanceControllers.push(parseNodeInstance(child));
                  break;
                case "instance_light":
                  data.instanceLights.push(parseId(child.getAttribute("url")));
                  break;
                case "instance_geometry":
                  data.instanceGeometries.push(parseNodeInstance(child));
                  break;
                case "instance_node":
                  data.instanceNodes.push(parseId(child.getAttribute("url")));
                  break;
                case "matrix":
                  array = parseFloats(child.textContent);
                  data.matrix.multiply(matrix.fromArray(array).transpose());
                  data.transforms[child.getAttribute("sid")] = child.nodeName;
                  break;
                case "translate":
                  array = parseFloats(child.textContent);
                  vector.fromArray(array);
                  data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));
                  data.transforms[child.getAttribute("sid")] = child.nodeName;
                  break;
                case "rotate":
                  array = parseFloats(child.textContent);
                  const angle = THREE2.MathUtils.degToRad(array[3]);
                  data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));
                  data.transforms[child.getAttribute("sid")] = child.nodeName;
                  break;
                case "scale":
                  array = parseFloats(child.textContent);
                  data.matrix.scale(vector.fromArray(array));
                  data.transforms[child.getAttribute("sid")] = child.nodeName;
                  break;
                case "extra":
                  break;
                default:
                  console.log(child);
              }
            }
            if (hasNode(data.id)) {
              console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", data.id);
            } else {
              library.nodes[data.id] = data;
            }
            return data;
          }
          function parseNodeInstance(xml2) {
            const data = {
              id: parseId(xml2.getAttribute("url")),
              materials: {},
              skeletons: []
            };
            for (let i = 0; i < xml2.childNodes.length; i++) {
              const child = xml2.childNodes[i];
              switch (child.nodeName) {
                case "bind_material":
                  const instances = child.getElementsByTagName("instance_material");
                  for (let j = 0; j < instances.length; j++) {
                    const instance = instances[j];
                    const symbol = instance.getAttribute("symbol");
                    const target = instance.getAttribute("target");
                    data.materials[symbol] = parseId(target);
                  }
                  break;
                case "skeleton":
                  data.skeletons.push(parseId(child.textContent));
                  break;
                default:
                  break;
              }
            }
            return data;
          }
          function buildSkeleton(skeletons, joints) {
            const boneData = [];
            const sortedBoneData = [];
            let i, j, data;
            for (i = 0; i < skeletons.length; i++) {
              const skeleton = skeletons[i];
              let root;
              if (hasNode(skeleton)) {
                root = getNode(skeleton);
                buildBoneHierarchy(root, joints, boneData);
              } else if (hasVisualScene(skeleton)) {
                const visualScene = library.visualScenes[skeleton];
                const children = visualScene.children;
                for (let j2 = 0; j2 < children.length; j2++) {
                  const child = children[j2];
                  if (child.type === "JOINT") {
                    const root2 = getNode(child.id);
                    buildBoneHierarchy(root2, joints, boneData);
                  }
                }
              } else {
                console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", skeleton);
              }
            }
            for (i = 0; i < joints.length; i++) {
              for (j = 0; j < boneData.length; j++) {
                data = boneData[j];
                if (data.bone.name === joints[i].name) {
                  sortedBoneData[i] = data;
                  data.processed = true;
                  break;
                }
              }
            }
            for (i = 0; i < boneData.length; i++) {
              data = boneData[i];
              if (data.processed === false) {
                sortedBoneData.push(data);
                data.processed = true;
              }
            }
            const bones = [];
            const boneInverses = [];
            for (i = 0; i < sortedBoneData.length; i++) {
              data = sortedBoneData[i];
              bones.push(data.bone);
              boneInverses.push(data.boneInverse);
            }
            return new THREE2.Skeleton(bones, boneInverses);
          }
          function buildBoneHierarchy(root, joints, boneData) {
            root.traverse(function(object) {
              if (object.isBone === true) {
                let boneInverse;
                for (let i = 0; i < joints.length; i++) {
                  const joint = joints[i];
                  if (joint.name === object.name) {
                    boneInverse = joint.boneInverse;
                    break;
                  }
                }
                if (boneInverse === void 0) {
                  boneInverse = new THREE2.Matrix4();
                }
                boneData.push({
                  bone: object,
                  boneInverse,
                  processed: false
                });
              }
            });
          }
          function buildNode(data) {
            const objects = [];
            const matrix2 = data.matrix;
            const nodes = data.nodes;
            const type = data.type;
            const instanceCameras = data.instanceCameras;
            const instanceControllers = data.instanceControllers;
            const instanceLights = data.instanceLights;
            const instanceGeometries = data.instanceGeometries;
            const instanceNodes = data.instanceNodes;
            for (let i = 0, l = nodes.length; i < l; i++) {
              objects.push(getNode(nodes[i]));
            }
            for (let i = 0, l = instanceCameras.length; i < l; i++) {
              const instanceCamera = getCamera(instanceCameras[i]);
              if (instanceCamera !== null) {
                objects.push(instanceCamera.clone());
              }
            }
            for (let i = 0, l = instanceControllers.length; i < l; i++) {
              const instance = instanceControllers[i];
              const controller = getController(instance.id);
              const geometries = getGeometry(controller.id);
              const newObjects = buildObjects(geometries, instance.materials);
              const skeletons = instance.skeletons;
              const joints = controller.skin.joints;
              const skeleton = buildSkeleton(skeletons, joints);
              for (let j = 0, jl = newObjects.length; j < jl; j++) {
                const object2 = newObjects[j];
                if (object2.isSkinnedMesh) {
                  object2.bind(skeleton, controller.skin.bindMatrix);
                  object2.normalizeSkinWeights();
                }
                objects.push(object2);
              }
            }
            for (let i = 0, l = instanceLights.length; i < l; i++) {
              const instanceLight = getLight(instanceLights[i]);
              if (instanceLight !== null) {
                objects.push(instanceLight.clone());
              }
            }
            for (let i = 0, l = instanceGeometries.length; i < l; i++) {
              const instance = instanceGeometries[i];
              const geometries = getGeometry(instance.id);
              const newObjects = buildObjects(geometries, instance.materials);
              for (let j = 0, jl = newObjects.length; j < jl; j++) {
                objects.push(newObjects[j]);
              }
            }
            for (let i = 0, l = instanceNodes.length; i < l; i++) {
              objects.push(getNode(instanceNodes[i]).clone());
            }
            let object;
            if (nodes.length === 0 && objects.length === 1) {
              object = objects[0];
            } else {
              object = type === "JOINT" ? new THREE2.Bone() : new THREE2.Group();
              for (let i = 0; i < objects.length; i++) {
                object.add(objects[i]);
              }
            }
            object.name = type === "JOINT" ? data.sid : data.name;
            object.matrix.copy(matrix2);
            object.matrix.decompose(object.position, object.quaternion, object.scale);
            return object;
          }
          const fallbackMaterial = new THREE2.MeshBasicMaterial({
            color: 16711935
          });
          function resolveMaterialBinding(keys, instanceMaterials) {
            const materials = [];
            for (let i = 0, l = keys.length; i < l; i++) {
              const id = instanceMaterials[keys[i]];
              if (id === void 0) {
                console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", keys[i]);
                materials.push(fallbackMaterial);
              } else {
                materials.push(getMaterial(id));
              }
            }
            return materials;
          }
          function buildObjects(geometries, instanceMaterials) {
            const objects = [];
            for (const type in geometries) {
              const geometry = geometries[type];
              const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);
              if (materials.length === 0) {
                if (type === "lines" || type === "linestrips") {
                  materials.push(new THREE2.LineBasicMaterial());
                } else {
                  materials.push(new THREE2.MeshPhongMaterial());
                }
              }
              const skinning = geometry.data.attributes.skinIndex !== void 0;
              const material = materials.length === 1 ? materials[0] : materials;
              let object;
              switch (type) {
                case "lines":
                  object = new THREE2.LineSegments(geometry.data, material);
                  break;
                case "linestrips":
                  object = new THREE2.Line(geometry.data, material);
                  break;
                case "triangles":
                case "polylist":
                  if (skinning) {
                    object = new THREE2.SkinnedMesh(geometry.data, material);
                  } else {
                    object = new THREE2.Mesh(geometry.data, material);
                  }
                  break;
              }
              objects.push(object);
            }
            return objects;
          }
          function hasNode(id) {
            return library.nodes[id] !== void 0;
          }
          function getNode(id) {
            return getBuild(library.nodes[id], buildNode);
          }
          function parseVisualScene(xml2) {
            const data = {
              name: xml2.getAttribute("name"),
              children: []
            };
            prepareNodes(xml2);
            const elements = getElementsByTagName(xml2, "node");
            for (let i = 0; i < elements.length; i++) {
              data.children.push(parseNode(elements[i]));
            }
            library.visualScenes[xml2.getAttribute("id")] = data;
          }
          function buildVisualScene(data) {
            const group = new THREE2.Group();
            group.name = data.name;
            const children = data.children;
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              group.add(getNode(child.id));
            }
            return group;
          }
          function hasVisualScene(id) {
            return library.visualScenes[id] !== void 0;
          }
          function getVisualScene(id) {
            return getBuild(library.visualScenes[id], buildVisualScene);
          }
          function parseScene(xml2) {
            const instance = getElementsByTagName(xml2, "instance_visual_scene")[0];
            return getVisualScene(parseId(instance.getAttribute("url")));
          }
          function setupAnimations() {
            const clips = library.clips;
            if (isEmpty(clips) === true) {
              if (isEmpty(library.animations) === false) {
                const tracks = [];
                for (const id in library.animations) {
                  const animationTracks = getAnimation(id);
                  for (let i = 0, l = animationTracks.length; i < l; i++) {
                    tracks.push(animationTracks[i]);
                  }
                }
                animations.push(new THREE2.AnimationClip("default", -1, tracks));
              }
            } else {
              for (const id in clips) {
                animations.push(getAnimationClip(id));
              }
            }
          }
          function parserErrorToText(parserError2) {
            let result = "";
            const stack = [parserError2];
            while (stack.length) {
              const node = stack.shift();
              if (node.nodeType === Node.TEXT_NODE) {
                result += node.textContent;
              } else {
                result += "\n";
                stack.push.apply(stack, node.childNodes);
              }
            }
            return result.trim();
          }
          if (text.length === 0) {
            return {
              scene: new THREE2.Scene()
            };
          }
          const xml = new DOMParser().parseFromString(text, "application/xml");
          const collada = getElementsByTagName(xml, "COLLADA")[0];
          const parserError = xml.getElementsByTagName("parsererror")[0];
          if (parserError !== void 0) {
            const errorElement = getElementsByTagName(parserError, "div")[0];
            let errorText;
            if (errorElement) {
              errorText = errorElement.textContent;
            } else {
              errorText = parserErrorToText(parserError);
            }
            console.error("THREE.ColladaLoader: Failed to parse collada file.\n", errorText);
            return null;
          }
          const version = collada.getAttribute("version");
          console.log("THREE.ColladaLoader: File version", version);
          const asset = parseAsset(getElementsByTagName(collada, "asset")[0]);
          const textureLoader = new THREE2.TextureLoader(this.manager);
          textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
          let tgaLoader;
          if (THREE2.TGALoader) {
            tgaLoader = new THREE2.TGALoader(this.manager);
            tgaLoader.setPath(this.resourcePath || path);
          }
          const animations = [];
          let kinematics = {};
          let count = 0;
          const library = {
            animations: {},
            clips: {},
            controllers: {},
            images: {},
            effects: {},
            materials: {},
            cameras: {},
            lights: {},
            geometries: {},
            nodes: {},
            visualScenes: {},
            kinematicsModels: {},
            physicsModels: {},
            kinematicsScenes: {}
          };
          parseLibrary(collada, "library_animations", "animation", parseAnimation);
          parseLibrary(collada, "library_animation_clips", "animation_clip", parseAnimationClip);
          parseLibrary(collada, "library_controllers", "controller", parseController);
          parseLibrary(collada, "library_images", "image", parseImage);
          parseLibrary(collada, "library_effects", "effect", parseEffect);
          parseLibrary(collada, "library_materials", "material", parseMaterial);
          parseLibrary(collada, "library_cameras", "camera", parseCamera);
          parseLibrary(collada, "library_lights", "light", parseLight);
          parseLibrary(collada, "library_geometries", "geometry", parseGeometry);
          parseLibrary(collada, "library_nodes", "node", parseNode);
          parseLibrary(collada, "library_visual_scenes", "visual_scene", parseVisualScene);
          parseLibrary(collada, "library_kinematics_models", "kinematics_model", parseKinematicsModel);
          parseLibrary(collada, "library_physics_models", "physics_model", parsePhysicsModel);
          parseLibrary(collada, "scene", "instance_kinematics_scene", parseKinematicsScene);
          buildLibrary(library.animations, buildAnimation);
          buildLibrary(library.clips, buildAnimationClip);
          buildLibrary(library.controllers, buildController);
          buildLibrary(library.images, buildImage);
          buildLibrary(library.effects, buildEffect);
          buildLibrary(library.materials, buildMaterial);
          buildLibrary(library.cameras, buildCamera);
          buildLibrary(library.lights, buildLight);
          buildLibrary(library.geometries, buildGeometry);
          buildLibrary(library.visualScenes, buildVisualScene);
          setupAnimations();
          setupKinematics();
          const scene = parseScene(getElementsByTagName(collada, "scene")[0]);
          scene.animations = animations;
          if (asset.upAxis === "Z_UP") {
            scene.quaternion.setFromEuler(new THREE2.Euler(-Math.PI / 2, 0, 0));
          }
          scene.scale.multiplyScalar(asset.unit);
          return {
            get animations() {
              console.warn("THREE.ColladaLoader: Please access animations over scene.animations now.");
              return animations;
            },
            kinematics,
            library,
            scene
          };
        }
      }
      THREE2.ColladaLoader = ColladaLoader;
    })();
    module.exports = exports = THREE2.ColladaLoader;
  }
});

// node_modules/threebox-plugin/src/objects/loadObj.js
var require_loadObj = __commonJS({
  "node_modules/threebox-plugin/src/objects/loadObj.js"(exports, module) {
    var utils = require_utils();
    var Objects = require_objects();
    var OBJLoader = require_OBJLoader();
    var MTLLoader = require_MTLLoader();
    var FBXLoader = require_FBXLoader();
    var GLTFLoader = require_GLTFLoader();
    var ColladaLoader = require_ColladaLoader();
    var objLoader = new OBJLoader();
    var materialLoader = new MTLLoader();
    var gltfLoader = new GLTFLoader();
    var fbxLoader = new FBXLoader();
    var daeLoader = new ColladaLoader();
    function loadObj(options2, cb, promise) {
      if (options2 === void 0)
        return console.error("Invalid options provided to loadObj()");
      options2 = utils._validate(options2, Objects.prototype._defaults.loadObj);
      let loader;
      if (!options2.type) {
        options2.type = "mtl";
      }
      ;
      switch (options2.type) {
        case "mtl":
          loader = objLoader;
          break;
        case "gltf":
        case "glb":
          loader = gltfLoader;
          break;
        case "fbx":
          loader = fbxLoader;
          break;
        case "dae":
          loader = daeLoader;
          break;
      }
      materialLoader.load(options2.mtl, loadObject, () => null, (error) => {
        console.warn("No material file found " + error.stack);
      });
      function loadObject(materials) {
        if (materials && options2.type == "mtl") {
          materials.preload();
          loader.setMaterials(materials);
        }
        loader.load(options2.obj, (obj) => {
          let animations = [];
          switch (options2.type) {
            case "mtl":
              obj = obj.children[0];
              break;
            case "gltf":
            case "glb":
            case "dae":
              animations = obj.animations;
              obj = obj.scene;
              break;
            case "fbx":
              animations = obj.animations;
              break;
          }
          obj.animations = animations;
          const r = utils.types.rotation(options2.rotation, [0, 0, 0]);
          const s = utils.types.scale(options2.scale, [1, 1, 1]);
          obj.rotation.set(r[0], r[1], r[2]);
          obj.scale.set(s[0], s[1], s[2]);
          if (options2.normalize) {
            normalizeSpecular(obj);
          }
          obj.name = "model";
          let userScaleGroup = Objects.prototype._makeGroup(obj, options2);
          Objects.prototype._addMethods(userScaleGroup);
          userScaleGroup.setAnchor(options2.anchor);
          userScaleGroup.setCenter(options2.adjustment);
          userScaleGroup.raycasted = options2.raycasted;
          promise(userScaleGroup);
          cb(userScaleGroup);
          userScaleGroup.setFixedZoom(options2.mapScale);
          userScaleGroup.idle();
        }, () => null, (error) => {
          console.error("Could not load model file: " + options2.obj + " \n " + error.stack);
          promise("Error loading the model");
        });
      }
      ;
      function normalizeSpecular(model) {
        model.traverse(function(c) {
          if (c.isMesh) {
            let specularColor;
            if (c.material.type == "MeshStandardMaterial") {
              if (c.material.metalness) {
                c.material.metalness *= 0.1;
              }
              if (c.material.glossiness) {
                c.material.glossiness *= 0.25;
              }
              specularColor = new THREE.Color(12, 12, 12);
            } else if (c.material.type == "MeshPhongMaterial") {
              c.material.shininess = 0.1;
              specularColor = new THREE.Color(20, 20, 20);
            }
            if (c.material.specular && c.material.specular.isColor) {
              c.material.specular = specularColor;
            }
          }
        });
      }
    }
    module.exports = exports = loadObj;
  }
});

// node_modules/threebox-plugin/src/objects/line.js
var require_line = __commonJS({
  "node_modules/threebox-plugin/src/objects/line.js"(exports, module) {
    var THREE2 = require_three();
    var utils = require_utils();
    var Objects = require_objects();
    function line(obj) {
      obj = utils._validate(obj, Objects.prototype._defaults.line);
      var straightProject = utils.lnglatsToWorld(obj.geometry);
      var normalized = utils.normalizeVertices(straightProject);
      var flattenedArray = utils.flattenVectors(normalized.vertices);
      var geometry = new THREE2.LineGeometry();
      geometry.setPositions(flattenedArray);
      let matLine = new THREE2.LineMaterial({
        color: obj.color,
        linewidth: obj.width,
        // in pixels
        dashed: false,
        opacity: obj.opacity
      });
      matLine.resolution.set(window.innerWidth, window.innerHeight);
      matLine.isMaterial = true;
      matLine.transparent = true;
      matLine.depthWrite = false;
      line = new THREE2.Line2(geometry, matLine);
      line.position.copy(normalized.position);
      line.computeLineDistances();
      return line;
    }
    module.exports = exports = line;
    (function() {
      const _box = new THREE2.Box3();
      const _vector = new THREE2.Vector3();
      class LineSegmentsGeometry extends THREE2.InstancedBufferGeometry {
        constructor() {
          super();
          this.type = "LineSegmentsGeometry";
          const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
          const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
          const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
          this.setIndex(index);
          this.setAttribute("position", new THREE2.Float32BufferAttribute(positions, 3));
          this.setAttribute("uv", new THREE2.Float32BufferAttribute(uvs, 2));
        }
        applyMatrix4(matrix) {
          const start = this.attributes.instanceStart;
          const end = this.attributes.instanceEnd;
          if (start !== void 0) {
            start.applyMatrix4(matrix);
            end.applyMatrix4(matrix);
            start.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        setPositions(array) {
          let lineSegments;
          if (array instanceof Float32Array) {
            lineSegments = array;
          } else if (Array.isArray(array)) {
            lineSegments = new Float32Array(array);
          }
          const instanceBuffer = new THREE2.InstancedInterleavedBuffer(lineSegments, 6, 1);
          this.setAttribute("instanceStart", new THREE2.InterleavedBufferAttribute(instanceBuffer, 3, 0));
          this.setAttribute("instanceEnd", new THREE2.InterleavedBufferAttribute(instanceBuffer, 3, 3));
          this.computeBoundingBox();
          this.computeBoundingSphere();
          return this;
        }
        setColors(array) {
          let colors;
          if (array instanceof Float32Array) {
            colors = array;
          } else if (Array.isArray(array)) {
            colors = new Float32Array(array);
          }
          const instanceColorBuffer = new THREE2.InstancedInterleavedBuffer(colors, 6, 1);
          this.setAttribute("instanceColorStart", new THREE2.InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
          this.setAttribute("instanceColorEnd", new THREE2.InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
          return this;
        }
        fromWireframeGeometry(geometry) {
          this.setPositions(geometry.attributes.position.array);
          return this;
        }
        fromEdgesGeometry(geometry) {
          this.setPositions(geometry.attributes.position.array);
          return this;
        }
        fromMesh(mesh) {
          this.fromWireframeGeometry(new THREE2.WireframeGeometry(mesh.geometry));
          return this;
        }
        fromLineSegments(lineSegments) {
          const geometry = lineSegments.geometry;
          if (geometry.isGeometry) {
            console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");
            return;
          } else if (geometry.isBufferGeometry) {
            this.setPositions(geometry.attributes.position.array);
          }
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new THREE2.Box3();
          }
          const start = this.attributes.instanceStart;
          const end = this.attributes.instanceEnd;
          if (start !== void 0 && end !== void 0) {
            this.boundingBox.setFromBufferAttribute(start);
            _box.setFromBufferAttribute(end);
            this.boundingBox.union(_box);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new THREE2.Sphere();
          }
          if (this.boundingBox === null) {
            this.computeBoundingBox();
          }
          const start = this.attributes.instanceStart;
          const end = this.attributes.instanceEnd;
          if (start !== void 0 && end !== void 0) {
            const center = this.boundingSphere.center;
            this.boundingBox.getCenter(center);
            let maxRadiusSq = 0;
            for (let i = 0, il = start.count; i < il; i++) {
              _vector.fromBufferAttribute(start, i);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
              _vector.fromBufferAttribute(end, i);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
            }
          }
        }
        toJSON() {
        }
        applyMatrix(matrix) {
          console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
          return this.applyMatrix4(matrix);
        }
      }
      LineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;
      THREE2.LineSegmentsGeometry = LineSegmentsGeometry;
    })();
    (function() {
      class LineGeometry extends THREE2.LineSegmentsGeometry {
        constructor() {
          super();
          this.type = "LineGeometry";
        }
        setPositions(array) {
          var length = array.length - 3;
          var points = new Float32Array(2 * length);
          for (var i = 0; i < length; i += 3) {
            points[2 * i] = array[i];
            points[2 * i + 1] = array[i + 1];
            points[2 * i + 2] = array[i + 2];
            points[2 * i + 3] = array[i + 3];
            points[2 * i + 4] = array[i + 4];
            points[2 * i + 5] = array[i + 5];
          }
          super.setPositions(points);
          return this;
        }
        setColors(array) {
          var length = array.length - 3;
          var colors = new Float32Array(2 * length);
          for (var i = 0; i < length; i += 3) {
            colors[2 * i] = array[i];
            colors[2 * i + 1] = array[i + 1];
            colors[2 * i + 2] = array[i + 2];
            colors[2 * i + 3] = array[i + 3];
            colors[2 * i + 4] = array[i + 4];
            colors[2 * i + 5] = array[i + 5];
          }
          super.setColors(colors);
          return this;
        }
        fromLine(line2) {
          var geometry = line2.geometry;
          if (geometry.isGeometry) {
            console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.");
            return;
          } else if (geometry.isBufferGeometry) {
            this.setPositions(geometry.attributes.position.array);
          }
          return this;
        }
      }
      LineGeometry.prototype.isLineGeometry = true;
      THREE2.LineGeometry = LineGeometry;
    })();
    (function() {
      class WireframeGeometry2 extends THREE2.LineSegmentsGeometry {
        constructor(geometry) {
          super();
          this.type = "WireframeGeometry2";
          this.fromWireframeGeometry(new THREE2.WireframeGeometry(geometry));
        }
      }
      WireframeGeometry2.prototype.isWireframeGeometry2 = true;
      THREE2.WireframeGeometry2 = WireframeGeometry2;
    })();
    (function() {
      THREE2.UniformsLib.line = {
        worldUnits: {
          value: 1
        },
        linewidth: {
          value: 1
        },
        resolution: {
          value: new THREE2.Vector2(1, 1)
        },
        dashScale: {
          value: 1
        },
        dashSize: {
          value: 1
        },
        gapSize: {
          value: 1
        }
        // todo FIX - maybe change to totalSize
      };
      THREE2.ShaderLib["line"] = {
        uniforms: THREE2.UniformsUtils.merge([THREE2.UniformsLib.common, THREE2.UniformsLib.fog, THREE2.UniformsLib.line]),
        vertexShader: (
          /* glsl */
          `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			worldStart = start.xyz;
			worldEnd = end.xyz;

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
        ),
        fragmentShader: (
          /* glsl */
          `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
        )
      };
      class LineMaterial extends THREE2.ShaderMaterial {
        constructor(parameters) {
          super({
            type: "LineMaterial",
            uniforms: THREE2.UniformsUtils.clone(THREE2.ShaderLib["line"].uniforms),
            vertexShader: THREE2.ShaderLib["line"].vertexShader,
            fragmentShader: THREE2.ShaderLib["line"].fragmentShader,
            clipping: true
            // required for clipping support
          });
          Object.defineProperties(this, {
            color: {
              enumerable: true,
              get: function() {
                return this.uniforms.diffuse.value;
              },
              set: function(value) {
                this.uniforms.diffuse.value = value;
              }
            },
            worldUnits: {
              enumerable: true,
              get: function() {
                return "WORLD_UNITS" in this.defines;
              },
              set: function(value) {
                if (value === true) {
                  this.defines.WORLD_UNITS = "";
                } else {
                  delete this.defines.WORLD_UNITS;
                }
              }
            },
            linewidth: {
              enumerable: true,
              get: function() {
                return this.uniforms.linewidth.value;
              },
              set: function(value) {
                this.uniforms.linewidth.value = value;
              }
            },
            dashed: {
              enumerable: true,
              get: function() {
                return Boolean("USE_DASH" in this.defines);
              },
              set(value) {
                if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) {
                  this.needsUpdate = true;
                }
                if (value === true) {
                  this.defines.USE_DASH = "";
                } else {
                  delete this.defines.USE_DASH;
                }
              }
            },
            dashScale: {
              enumerable: true,
              get: function() {
                return this.uniforms.dashScale.value;
              },
              set: function(value) {
                this.uniforms.dashScale.value = value;
              }
            },
            dashSize: {
              enumerable: true,
              get: function() {
                return this.uniforms.dashSize.value;
              },
              set: function(value) {
                this.uniforms.dashSize.value = value;
              }
            },
            dashOffset: {
              enumerable: true,
              get: function() {
                return this.uniforms.dashOffset.value;
              },
              set: function(value) {
                this.uniforms.dashOffset.value = value;
              }
            },
            gapSize: {
              enumerable: true,
              get: function() {
                return this.uniforms.gapSize.value;
              },
              set: function(value) {
                this.uniforms.gapSize.value = value;
              }
            },
            opacity: {
              enumerable: true,
              get: function() {
                return this.uniforms.opacity.value;
              },
              set: function(value) {
                this.uniforms.opacity.value = value;
              }
            },
            resolution: {
              enumerable: true,
              get: function() {
                return this.uniforms.resolution.value;
              },
              set: function(value) {
                this.uniforms.resolution.value.copy(value);
              }
            },
            alphaToCoverage: {
              enumerable: true,
              get: function() {
                return Boolean("ALPHA_TO_COVERAGE" in this.defines);
              },
              set: function(value) {
                if (Boolean(value) !== Boolean("ALPHA_TO_COVERAGE" in this.defines)) {
                  this.needsUpdate = true;
                }
                if (value === true) {
                  this.defines.ALPHA_TO_COVERAGE = "";
                  this.extensions.derivatives = true;
                } else {
                  delete this.defines.ALPHA_TO_COVERAGE;
                  this.extensions.derivatives = false;
                }
              }
            }
          });
          this.setValues(parameters);
        }
      }
      LineMaterial.prototype.isLineMaterial = true;
      THREE2.LineMaterial = LineMaterial;
    })();
    (function() {
      const _start = new THREE2.Vector3();
      const _end = new THREE2.Vector3();
      const _start4 = new THREE2.Vector4();
      const _end4 = new THREE2.Vector4();
      const _ssOrigin = new THREE2.Vector4();
      const _ssOrigin3 = new THREE2.Vector3();
      const _mvMatrix = new THREE2.Matrix4();
      const _line = new THREE2.Line3();
      const _closestPoint = new THREE2.Vector3();
      const _box = new THREE2.Box3();
      const _sphere = new THREE2.Sphere();
      const _clipToWorldVector = new THREE2.Vector4();
      class LineSegments2 extends THREE2.Mesh {
        constructor(geometry = new THREE2.LineSegmentsGeometry(), material = new THREE2.LineMaterial({
          color: Math.random() * 16777215
        })) {
          super(geometry, material);
          this.type = "LineSegments2";
        }
        // for backwards-compatability, but could be a method of THREE.LineSegmentsGeometry...
        computeLineDistances() {
          const geometry = this.geometry;
          const instanceStart = geometry.attributes.instanceStart;
          const instanceEnd = geometry.attributes.instanceEnd;
          const lineDistances = new Float32Array(2 * instanceStart.count);
          for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
            _start.fromBufferAttribute(instanceStart, i);
            _end.fromBufferAttribute(instanceEnd, i);
            lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
            lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
          }
          const instanceDistanceBuffer = new THREE2.InstancedInterleavedBuffer(lineDistances, 2, 1);
          geometry.setAttribute("instanceDistanceStart", new THREE2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
          geometry.setAttribute("instanceDistanceEnd", new THREE2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
          return this;
        }
        raycast(raycaster, intersects) {
          if (raycaster.camera === null) {
            console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
          }
          const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
          const ray = raycaster.ray;
          const camera = raycaster.camera;
          const projectionMatrix = camera.projectionMatrix;
          const matrixWorld = this.matrixWorld;
          const geometry = this.geometry;
          const material = this.material;
          const resolution = material.resolution;
          const lineWidth = material.linewidth + threshold;
          const instanceStart = geometry.attributes.instanceStart;
          const instanceEnd = geometry.attributes.instanceEnd;
          const near = -camera.near;
          const ssMaxWidth = 2 * Math.max(lineWidth / resolution.width, lineWidth / resolution.height);
          if (geometry.boundingSphere === null) {
            geometry.computeBoundingSphere();
          }
          _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
          const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin));
          _clipToWorldVector.set(0, 0, -distanceToSphere, 1).applyMatrix4(camera.projectionMatrix);
          _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
          _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
          const sphereMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;
          _sphere.radius += sphereMargin;
          if (raycaster.ray.intersectsSphere(_sphere) === false) {
            return;
          }
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
          const distanceToBox = Math.max(camera.near, _box.distanceToPoint(ray.origin));
          _clipToWorldVector.set(0, 0, -distanceToBox, 1).applyMatrix4(camera.projectionMatrix);
          _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
          _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
          const boxMargin = Math.abs(ssMaxWidth / _clipToWorldVector.w) * 0.5;
          _box.max.x += boxMargin;
          _box.max.y += boxMargin;
          _box.max.z += boxMargin;
          _box.min.x -= boxMargin;
          _box.min.y -= boxMargin;
          _box.min.z -= boxMargin;
          if (raycaster.ray.intersectsBox(_box) === false) {
            return;
          }
          ray.at(1, _ssOrigin);
          _ssOrigin.w = 1;
          _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
          _ssOrigin.applyMatrix4(projectionMatrix);
          _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
          _ssOrigin.x *= resolution.x / 2;
          _ssOrigin.y *= resolution.y / 2;
          _ssOrigin.z = 0;
          _ssOrigin3.copy(_ssOrigin);
          _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
          for (let i = 0, l = instanceStart.count; i < l; i++) {
            _start4.fromBufferAttribute(instanceStart, i);
            _end4.fromBufferAttribute(instanceEnd, i);
            _start4.w = 1;
            _end4.w = 1;
            _start4.applyMatrix4(_mvMatrix);
            _end4.applyMatrix4(_mvMatrix);
            var isBehindCameraNear = _start4.z > near && _end4.z > near;
            if (isBehindCameraNear) {
              continue;
            }
            if (_start4.z > near) {
              const deltaDist = _start4.z - _end4.z;
              const t = (_start4.z - near) / deltaDist;
              _start4.lerp(_end4, t);
            } else if (_end4.z > near) {
              const deltaDist = _end4.z - _start4.z;
              const t = (_end4.z - near) / deltaDist;
              _end4.lerp(_start4, t);
            }
            _start4.applyMatrix4(projectionMatrix);
            _end4.applyMatrix4(projectionMatrix);
            _start4.multiplyScalar(1 / _start4.w);
            _end4.multiplyScalar(1 / _end4.w);
            _start4.x *= resolution.x / 2;
            _start4.y *= resolution.y / 2;
            _end4.x *= resolution.x / 2;
            _end4.y *= resolution.y / 2;
            _line.start.copy(_start4);
            _line.start.z = 0;
            _line.end.copy(_end4);
            _line.end.z = 0;
            const param = _line.closestPointToPointParameter(_ssOrigin3, true);
            _line.at(param, _closestPoint);
            const zPos = THREE2.MathUtils.lerp(_start4.z, _end4.z, param);
            const isInClipSpace = zPos >= -1 && zPos <= 1;
            const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;
            if (isInClipSpace && isInside) {
              _line.start.fromBufferAttribute(instanceStart, i);
              _line.end.fromBufferAttribute(instanceEnd, i);
              _line.start.applyMatrix4(matrixWorld);
              _line.end.applyMatrix4(matrixWorld);
              const pointOnLine = new THREE2.Vector3();
              const point = new THREE2.Vector3();
              ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
              intersects.push({
                point,
                pointOnLine,
                distance: ray.origin.distanceTo(point),
                object: this,
                face: null,
                faceIndex: i,
                uv: null,
                uv2: null
              });
            }
          }
        }
      }
      LineSegments2.prototype.LineSegments2 = true;
      THREE2.LineSegments2 = LineSegments2;
    })();
    (function() {
      class Line2 extends THREE2.LineSegments2 {
        constructor(geometry = new THREE2.LineGeometry(), material = new THREE2.LineMaterial({
          color: Math.random() * 16777215
        })) {
          super(geometry, material);
          this.type = "Line2";
        }
      }
      Line2.prototype.isLine2 = true;
      THREE2.Line2 = Line2;
    })();
    (function() {
      const _start = new THREE2.Vector3();
      const _end = new THREE2.Vector3();
      class Wireframe extends THREE2.Mesh {
        constructor(geometry = new THREE2.LineSegmentsGeometry(), material = new THREE2.LineMaterial({
          color: Math.random() * 16777215
        })) {
          super(geometry, material);
          this.type = "Wireframe";
        }
        // for backwards-compatability, but could be a method of THREE.LineSegmentsGeometry...
        computeLineDistances() {
          const geometry = this.geometry;
          const instanceStart = geometry.attributes.instanceStart;
          const instanceEnd = geometry.attributes.instanceEnd;
          const lineDistances = new Float32Array(2 * instanceStart.count);
          for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
            _start.fromBufferAttribute(instanceStart, i);
            _end.fromBufferAttribute(instanceEnd, i);
            lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
            lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
          }
          const instanceDistanceBuffer = new THREE2.InstancedInterleavedBuffer(lineDistances, 2, 1);
          geometry.setAttribute("instanceDistanceStart", new THREE2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
          geometry.setAttribute("instanceDistanceEnd", new THREE2.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
          return this;
        }
      }
      Wireframe.prototype.isWireframe = true;
      THREE2.Wireframe = Wireframe;
    })();
  }
});

// node_modules/threebox-plugin/src/objects/tube.js
var require_tube = __commonJS({
  "node_modules/threebox-plugin/src/objects/tube.js"(exports, module) {
    var utils = require_utils();
    var material = require_material();
    var Objects = require_objects();
    var THREE2 = require_three();
    var Object3D = require_Object3D();
    function tube(opt, world) {
      opt = utils._validate(opt, Objects.prototype._defaults.tube);
      let points = [];
      opt.geometry.forEach((p) => {
        points.push(new THREE2.Vector3(p[0], p[1], p[2]));
      });
      const curve = new THREE2.CatmullRomCurve3(points);
      let tube2 = new THREE2.TubeGeometry(curve, points.length, opt.radius, opt.sides, false);
      let mat = material(opt);
      let obj = new THREE2.Mesh(tube2, mat);
      return new Object3D({ obj, units: opt.units, anchor: opt.anchor, adjustment: opt.adjustment, bbox: opt.bbox, tooltip: opt.tooltip, raycasted: opt.raycasted });
    }
    module.exports = exports = tube;
  }
});

// node_modules/threebox-plugin/src/objects/LabelRenderer.js
var require_LabelRenderer = __commonJS({
  "node_modules/threebox-plugin/src/objects/LabelRenderer.js"(exports, module) {
    var THREE2 = require_CSS2DRenderer();
    function LabelRenderer(map) {
      this.map = map;
      this.renderer = new THREE2.CSS2DRenderer();
      this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight);
      this.renderer.domElement.style.position = "absolute";
      this.renderer.domElement.id = "labelCanvas";
      this.renderer.domElement.style.top = 0;
      this.renderer.domElement.style.zIndex = "0";
      this.map.getCanvasContainer().appendChild(this.renderer.domElement);
      this.scene, this.camera;
      this.dispose = function() {
        this.map.getCanvasContainer().removeChild(this.renderer.domElement);
        this.renderer.domElement.remove();
        this.renderer = {};
      };
      this.setSize = function(width, height) {
        this.renderer.setSize(width, height);
      };
      this.map.on("resize", (function() {
        this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight);
      }).bind(this));
      this.state = {
        reset: function() {
        }
      };
      this.render = async function(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        return new Promise((resolve) => {
          resolve(this.renderer.render(scene, camera));
        });
      };
      this.toggleLabels = async function(layerId, visible) {
        return new Promise((resolve) => {
          resolve(this.setVisibility(layerId, visible, this.scene, this.camera, this.renderer));
        });
      };
      this.setVisibility = function(layerId, visible, scene, camera, renderer2) {
        var cache = this.renderer.cacheList;
        cache.forEach(function(l) {
          if (l.visible != visible && l.layer === layerId) {
            if (visible && l.alwaysVisible || !visible) {
              l.visible = visible;
              renderer2.renderObject(l, scene, camera);
            }
          }
        });
      };
    }
    module.exports = exports = LabelRenderer;
  }
});

// node_modules/threebox-plugin/src/objects/effects/BuildingShadows.js
var require_BuildingShadows = __commonJS({
  "node_modules/threebox-plugin/src/objects/effects/BuildingShadows.js"(exports, module) {
    var SunCalc = require_suncalc();
    var BuildingShadows = class {
      constructor(options2, threebox) {
        this.id = options2.layerId;
        this.type = "custom";
        this.renderingMode = "3d";
        this.opacity = 0.5;
        this.buildingsLayerId = options2.buildingsLayerId;
        this.minAltitude = options2.minAltitude || 0.1;
        this.tb = threebox;
      }
      onAdd(map, gl) {
        this.map = map;
        const vertexSource = `
			uniform mat4 u_matrix;
			uniform float u_height_factor;
			uniform float u_altitude;
			uniform float u_azimuth;
			attribute vec2 a_pos;
			attribute vec4 a_normal_ed;
			attribute lowp vec2 a_base;
			attribute lowp vec2 a_height;
			void main() {
				float base = max(0.0, a_base.x);
				float height = max(0.0, a_height.x);
				float t = mod(a_normal_ed.x, 2.0);
				vec4 pos = vec4(a_pos, t > 0.0 ? height : base, 1);
				float len = pos.z * u_height_factor / tan(u_altitude);
				pos.x += cos(u_azimuth) * len;
				pos.y += sin(u_azimuth) * len;
				pos.z = 0.0;
				gl_Position = u_matrix * pos;
			}
			`;
        const fragmentSource = `
			void main() {
				gl_FragColor = vec4(0.0, 0.0, 0.0, 0.7);
			}
			`;
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexSource);
        gl.compileShader(vertexShader);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentSource);
        gl.compileShader(fragmentShader);
        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);
        gl.validateProgram(this.program);
        this.uMatrix = gl.getUniformLocation(this.program, "u_matrix");
        this.uHeightFactor = gl.getUniformLocation(this.program, "u_height_factor");
        this.uAltitude = gl.getUniformLocation(this.program, "u_altitude");
        this.uAzimuth = gl.getUniformLocation(this.program, "u_azimuth");
        this.aPos = gl.getAttribLocation(this.program, "a_pos");
        this.aNormal = gl.getAttribLocation(this.program, "a_normal_ed");
        this.aBase = gl.getAttribLocation(this.program, "a_base");
        this.aHeight = gl.getAttribLocation(this.program, "a_height");
      }
      render(gl, matrix) {
        gl.useProgram(this.program);
        const source = this.map.style.sourceCaches["composite"];
        const coords = source.getVisibleCoordinates().reverse();
        const buildingsLayer = this.map.getLayer(this.buildingsLayerId);
        const context = this.map.painter.context;
        const { lng, lat } = this.map.getCenter();
        const pos = this.tb.getSunPosition(this.tb.lightDateTime, [lng, lat]);
        gl.uniform1f(this.uAltitude, pos.altitude > this.minAltitude ? pos.altitude : 0);
        gl.uniform1f(this.uAzimuth, pos.azimuth + 3 * Math.PI / 2);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        var ext = gl.getExtension("EXT_blend_minmax");
        gl.disable(gl.DEPTH_TEST);
        for (const coord of coords) {
          const tile = source.getTile(coord);
          const bucket = tile.getBucket(buildingsLayer);
          if (!bucket)
            continue;
          const [heightBuffer, baseBuffer] = bucket.programConfigurations.programConfigurations[this.buildingsLayerId]._buffers;
          gl.uniformMatrix4fv(this.uMatrix, false, coord.posMatrix);
          gl.uniform1f(this.uHeightFactor, Math.pow(2, coord.overscaledZ) / tile.tileSize / 8);
          for (const segment of bucket.segments.get()) {
            const numPrevAttrib = context.currentNumAttributes || 0;
            const numNextAttrib = 2;
            for (let i = numNextAttrib; i < numPrevAttrib; i++)
              gl.disableVertexAttribArray(i);
            const vertexOffset = segment.vertexOffset || 0;
            gl.enableVertexAttribArray(this.aPos);
            gl.enableVertexAttribArray(this.aNormal);
            gl.enableVertexAttribArray(this.aHeight);
            gl.enableVertexAttribArray(this.aBase);
            bucket.layoutVertexBuffer.bind();
            gl.vertexAttribPointer(this.aPos, 2, gl.SHORT, false, 12, 12 * vertexOffset);
            gl.vertexAttribPointer(this.aNormal, 4, gl.SHORT, false, 12, 4 + 12 * vertexOffset);
            heightBuffer.bind();
            gl.vertexAttribPointer(this.aHeight, 1, gl.FLOAT, false, 4, 4 * vertexOffset);
            baseBuffer.bind();
            gl.vertexAttribPointer(this.aBase, 1, gl.FLOAT, false, 4, 4 * vertexOffset);
            bucket.indexBuffer.bind();
            context.currentNumAttributes = numNextAttrib;
            gl.drawElements(gl.TRIANGLES, segment.primitiveLength * 3, gl.UNSIGNED_SHORT, segment.primitiveOffset * 3 * 2);
          }
        }
      }
    };
    module.exports = exports = BuildingShadows;
  }
});

// node_modules/threebox-plugin/src/Threebox.js
var require_Threebox = __commonJS({
  "node_modules/threebox-plugin/src/Threebox.js"(exports, module) {
    var THREE2 = require_three();
    var CameraSync = require_CameraSync();
    var utils = require_utils();
    var SunCalc = require_suncalc();
    var ThreeboxConstants = require_constants();
    var Objects = require_objects();
    var material = require_material();
    var sphere = require_sphere();
    var extrusion = require_extrusion();
    var label = require_label();
    var tooltip = require_tooltip();
    var loader = require_loadObj();
    var Object3D = require_Object3D();
    var line = require_line();
    var tube = require_tube();
    var LabelRenderer = require_LabelRenderer();
    var BuildingShadows = require_BuildingShadows();
    function Threebox(map, glContext, options2) {
      this.init(map, glContext, options2);
    }
    Threebox.prototype = {
      repaint: function() {
        this.map.repaint = true;
      },
      /**
       * Threebox constructor init method
       * @param {mapboxgl.map} map
       * @param {WebGLRenderingContext} glContext
       * @param {defaultOptions} options
       */
      init: function(map, glContext, options2) {
        this.options = utils._validate(options2 || {}, defaultOptions);
        this.map = map;
        this.map.tb = this;
        this.objects = new Objects();
        this.mapboxVersion = parseFloat(this.map.version);
        this.renderer = new THREE2.WebGLRenderer({
          alpha: true,
          antialias: true,
          preserveDrawingBuffer: options2.preserveDrawingBuffer,
          canvas: map.getCanvas(),
          context: glContext
        });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(this.map.getCanvas().clientWidth, this.map.getCanvas().clientHeight);
        this.renderer.outputEncoding = THREE2.sRGBEncoding;
        this.renderer.autoClear = false;
        this.labelRenderer = new LabelRenderer(this.map);
        this.scene = new THREE2.Scene();
        this.world = new THREE2.Group();
        this.world.name = "world";
        this.scene.add(this.world);
        this.objectsCache = /* @__PURE__ */ new Map();
        this.zoomLayers = [];
        this.fov = this.options.fov;
        this.orthographic = this.options.orthographic || false;
        this.raycaster = new THREE2.Raycaster();
        this.raycaster.layers.set(0);
        this.mapCenter = this.map.getCenter();
        this.mapCenterUnits = utils.projectToWorld([this.mapCenter.lng, this.mapCenter.lat]);
        this.lightDateTime = /* @__PURE__ */ new Date();
        this.lightLng = this.mapCenter.lng;
        this.lightLat = this.mapCenter.lat;
        this.sunPosition;
        this.rotationStep = 5;
        this.gridStep = 6;
        this.altitudeStep = 0.1;
        this.defaultCursor = "default";
        this.lights = this.initLights;
        if (this.options.defaultLights)
          this.defaultLights();
        if (this.options.realSunlight)
          this.realSunlight(this.options.realSunlightHelper);
        this.skyLayerName = "sky-layer";
        this.terrainSourceName = "mapbox-dem";
        this.terrainExaggeration = 1;
        this.terrainLayerName = "";
        this.enableSelectingFeatures = this.options.enableSelectingFeatures || false;
        this.enableSelectingObjects = this.options.enableSelectingObjects || false;
        this.enableDraggingObjects = this.options.enableDraggingObjects || false;
        this.enableRotatingObjects = this.options.enableRotatingObjects || false;
        this.enableTooltips = this.options.enableTooltips || false;
        this.multiLayer = this.options.multiLayer || false;
        this.enableHelpTooltips = this.options.enableHelpTooltips || false;
        this.map.on("style.load", function() {
          this.tb.zoomLayers = [];
          if (this.tb.options.multiLayer)
            this.addLayer({ id: "threebox_layer", type: "custom", renderingMode: "3d", map: this, onAdd: function(map2, gl) {
            }, render: function(gl, matrix) {
              this.map.tb.update();
            } });
          this.once("idle", () => {
            this.tb.setObjectsScale();
          });
          if (this.tb.options.sky) {
            this.tb.sky = true;
          }
          if (this.tb.options.terrain) {
            this.tb.terrain = true;
          }
          let rasterLayers = ["satellite", "mapbox-mapbox-satellite", "satelliteLayer"];
          rasterLayers.forEach((l) => {
            if (this.getLayer(l))
              this.tb.terrainLayerName = l;
          });
        });
        this.map.on("load", function() {
          this.selectedObject;
          this.selectedFeature;
          this.draggedObject;
          let draggedAction;
          this.overedObject;
          this.overedFeature;
          let canvas = this.getCanvasContainer();
          this.getCanvasContainer().style.cursor = this.tb.defaultCursor;
          let start;
          let startCoords = [];
          let lngDiff;
          let latDiff;
          let altDiff;
          let rotationDiff;
          function mousePos(e) {
            var rect = canvas.getBoundingClientRect();
            return {
              x: e.originalEvent.clientX - rect.left - canvas.clientLeft,
              y: e.originalEvent.clientY - rect.top - canvas.clientTop
            };
          }
          this.unselectObject = function() {
            this.selectedObject.selected = false;
            this.selectedObject = null;
          };
          this.outObject = function() {
            this.overedObject.over = false;
            this.overedObject = null;
          };
          this.unselectFeature = function(f) {
            if (typeof f.id == "undefined")
              return;
            this.setFeatureState(
              { source: f.source, sourceLayer: f.sourceLayer, id: f.id },
              { select: false }
            );
            this.removeTooltip(f);
            f = this.queryRenderedFeatures({ layers: [f.layer.id], filter: ["==", ["id"], f.id] })[0];
            if (f)
              this.fire("SelectedFeatureChange", { detail: f });
            this.selectedFeature = null;
          };
          this.selectFeature = function(f) {
            this.selectedFeature = f;
            this.setFeatureState(
              { source: this.selectedFeature.source, sourceLayer: this.selectedFeature.sourceLayer, id: this.selectedFeature.id },
              { select: true }
            );
            this.selectedFeature = this.queryRenderedFeatures({ layers: [this.selectedFeature.layer.id], filter: ["==", ["id"], this.selectedFeature.id] })[0];
            this.addTooltip(this.selectedFeature);
            this.fire("SelectedFeatureChange", { detail: this.selectedFeature });
          };
          this.outFeature = function(f) {
            if (this.overedFeature && typeof this.overedFeature != "undefined" && this.overedFeature.id != f) {
              map.setFeatureState(
                { source: this.overedFeature.source, sourceLayer: this.overedFeature.sourceLayer, id: this.overedFeature.id },
                { hover: false }
              );
              this.removeTooltip(this.overedFeature);
              this.overedFeature = null;
            }
          };
          this.addTooltip = function(f) {
            if (!this.tb.enableTooltips)
              return;
            let coordinates = this.tb.getFeatureCenter(f);
            let t = this.tb.tooltip({
              text: f.properties.name || f.id || f.type,
              mapboxStyle: true,
              feature: f
            });
            t.setCoords(coordinates);
            this.tb.add(t, f.layer.id);
            f.tooltip = t;
            f.tooltip.tooltip.visible = true;
          };
          this.removeTooltip = function(f) {
            if (f.tooltip) {
              f.tooltip.visibility = false;
              this.tb.remove(f.tooltip);
              f.tooltip = null;
            }
          };
          map.onContextMenu = function(e) {
            alert("contextMenu");
          };
          this.onClick = function(e) {
            let intersectionExists;
            let intersects = [];
            if (map.tb.enableSelectingObjects) {
              intersects = this.tb.queryRenderedFeatures(e.point);
            }
            intersectionExists = typeof intersects[0] == "object";
            if (intersectionExists) {
              let nearestObject = Threebox.prototype.findParent3DObject(intersects[0]);
              if (nearestObject) {
                if (this.selectedFeature) {
                  this.unselectFeature(this.selectedFeature);
                }
                if (!this.selectedObject) {
                  this.selectedObject = nearestObject;
                  this.selectedObject.selected = true;
                } else if (this.selectedObject.uuid != nearestObject.uuid) {
                  this.selectedObject.selected = false;
                  nearestObject.selected = true;
                  this.selectedObject = nearestObject;
                } else if (this.selectedObject.uuid == nearestObject.uuid) {
                  this.unselectObject();
                  return;
                }
                this.selectedObject.dispatchEvent({ type: "Wireframed", detail: this.selectedObject });
                this.selectedObject.dispatchEvent({ type: "IsPlayingChanged", detail: this.selectedObject });
                this.repaint = true;
                e.preventDefault();
              }
            } else {
              let features = [];
              if (map.tb.enableSelectingFeatures) {
                features = this.queryRenderedFeatures(e.point);
              }
              if (features.length > 0) {
                if (features[0].layer.type == "fill-extrusion" && typeof features[0].id != "undefined") {
                  if (this.selectedObject) {
                    this.unselectObject();
                  }
                  if (!this.selectedFeature) {
                    this.selectFeature(features[0]);
                  } else if (this.selectedFeature.id != features[0].id) {
                    this.unselectFeature(this.selectedFeature);
                    this.selectFeature(features[0]);
                  } else if (this.selectedFeature.id == features[0].id) {
                    this.unselectFeature(this.selectedFeature);
                    return;
                  }
                }
              }
            }
          };
          this.onMouseMove = function(e) {
            let current = mousePos(e);
            this.getCanvasContainer().style.cursor = this.tb.defaultCursor;
            if (e.originalEvent.altKey && this.draggedObject) {
              if (!map.tb.enableRotatingObjects)
                return;
              draggedAction = "rotate";
              this.getCanvasContainer().style.cursor = "move";
              var minX = Math.min(start.x, current.x), maxX = Math.max(start.x, current.x), minY = Math.min(start.y, current.y), maxY = Math.max(start.y, current.y);
              let rotation = { x: 0, y: 0, z: Math.round(rotationDiff[2] + ~~((current.x - start.x) / this.tb.rotationStep) % 360 * this.tb.rotationStep % 360) };
              this.draggedObject.setRotation(rotation);
              if (map.tb.enableHelpTooltips)
                this.draggedObject.addHelp("rot: " + rotation.z + "&#176;");
              return;
            }
            if (e.originalEvent.shiftKey && this.draggedObject) {
              if (!map.tb.enableDraggingObjects)
                return;
              draggedAction = "translate";
              this.getCanvasContainer().style.cursor = "move";
              let coords = e.lngLat;
              let options3 = [Number((coords.lng + lngDiff).toFixed(this.tb.gridStep)), Number((coords.lat + latDiff).toFixed(this.tb.gridStep)), this.draggedObject.modelHeight];
              this.draggedObject.setCoords(options3);
              if (map.tb.enableHelpTooltips)
                this.draggedObject.addHelp("lng: " + options3[0] + "&#176;, lat: " + options3[1] + "&#176;");
              return;
            }
            if (e.originalEvent.ctrlKey && this.draggedObject) {
              if (!map.tb.enableDraggingObjects)
                return;
              draggedAction = "altitude";
              this.getCanvasContainer().style.cursor = "move";
              let now = e.point.y * this.tb.altitudeStep;
              let options3 = [this.draggedObject.coordinates[0], this.draggedObject.coordinates[1], Number((-now - altDiff).toFixed(this.tb.gridStep))];
              this.draggedObject.setCoords(options3);
              if (map.tb.enableHelpTooltips)
                this.draggedObject.addHelp("alt: " + options3[2] + "m");
              return;
            }
            let intersectionExists;
            let intersects = [];
            if (map.tb.enableSelectingObjects) {
              intersects = this.tb.queryRenderedFeatures(e.point);
            }
            intersectionExists = typeof intersects[0] == "object";
            if (intersectionExists) {
              let nearestObject = Threebox.prototype.findParent3DObject(intersects[0]);
              if (nearestObject) {
                this.outFeature(this.overedFeature);
                this.getCanvasContainer().style.cursor = "pointer";
                if (!this.selectedObject || nearestObject.uuid != this.selectedObject.uuid) {
                  if (this.overedObject && this.overedObject.uuid != nearestObject.uuid) {
                    this.outObject();
                  }
                  nearestObject.over = true;
                  this.overedObject = nearestObject;
                } else if (this.selectedObject && nearestObject.uuid == this.selectedObject.uuid) {
                  nearestObject.over = true;
                  this.overedObject = nearestObject;
                }
                this.repaint = true;
                e.preventDefault();
              }
            } else {
              if (this.overedObject) {
                this.outObject();
              }
              let features = [];
              if (map.tb.enableSelectingFeatures) {
                features = this.queryRenderedFeatures(e.point);
              }
              if (features.length > 0) {
                this.outFeature(features[0]);
                if (features[0].layer.type == "fill-extrusion" && typeof features[0].id != "undefined") {
                  if (!this.selectedFeature || this.selectedFeature.id != features[0].id) {
                    this.getCanvasContainer().style.cursor = "pointer";
                    this.overedFeature = features[0];
                    this.setFeatureState(
                      { source: this.overedFeature.source, sourceLayer: this.overedFeature.sourceLayer, id: this.overedFeature.id },
                      { hover: true }
                    );
                    this.overedFeature = map.queryRenderedFeatures({ layers: [this.overedFeature.layer.id], filter: ["==", ["id"], this.overedFeature.id] })[0];
                    this.addTooltip(this.overedFeature);
                  }
                }
              }
            }
          };
          this.onMouseDown = function(e) {
            if (!((e.originalEvent.shiftKey || e.originalEvent.altKey || e.originalEvent.ctrlKey) && e.originalEvent.button === 0 && this.selectedObject))
              return;
            if (!map.tb.enableDraggingObjects && !map.tb.enableRotatingObjects)
              return;
            e.preventDefault();
            map.getCanvasContainer().style.cursor = "move";
            map.once("mouseup", this.onMouseUp);
            this.draggedObject = this.selectedObject;
            start = mousePos(e);
            startCoords = this.draggedObject.coordinates;
            rotationDiff = utils.degreeify(this.draggedObject.rotation);
            lngDiff = startCoords[0] - e.lngLat.lng;
            latDiff = startCoords[1] - e.lngLat.lat;
            altDiff = -this.draggedObject.modelHeight - e.point.y * this.tb.altitudeStep;
          };
          this.onMouseUp = function(e) {
            this.getCanvasContainer().style.cursor = this.tb.defaultCursor;
            this.off("mouseup", this.onMouseUp);
            this.off("mouseout", this.onMouseUp);
            this.dragPan.enable();
            if (this.draggedObject) {
              this.draggedObject.dispatchEvent({ type: "ObjectDragged", detail: { draggedObject: this.draggedObject, draggedAction } });
              this.draggedObject.removeHelp();
              this.draggedObject = null;
              draggedAction = null;
            }
            ;
          };
          this.onMouseOut = function(e) {
            if (this.overedFeature) {
              let features = this.queryRenderedFeatures(e.point);
              if (features.length > 0 && this.overedFeature.id != features[0].id) {
                this.getCanvasContainer().style.cursor = this.tb.defaultCursor;
                this.outFeature(features[0]);
              }
            }
          };
          this.onZoom = function(e) {
            this.tb.zoomLayers.forEach((l) => {
              this.tb.toggleLayer(l);
            });
            this.tb.setObjectsScale();
          };
          let ctrlDown = false;
          let shiftDown = false;
          let ctrlKey = 17, cmdKey = 91, shiftKey = 16, sK = 83, dK = 68;
          function onKeyDown(e) {
            if (e.which === ctrlKey || e.which === cmdKey)
              ctrlDown = true;
            if (e.which === shiftKey)
              shiftDown = true;
            let obj = this.selectedObject;
            if (shiftDown && e.which === sK && obj) {
              let dc = utils.toDecimal;
              if (!obj.help) {
                let s = obj.modelSize;
                let sf = 1;
                if (obj.userData.units !== "meters") {
                  sf = utils.projectedUnitsPerMeter(obj.coordinates[1]);
                  if (!sf) {
                    sf = 1;
                  }
                  ;
                  sf = dc(sf, 7);
                }
                if (map.tb.enableHelpTooltips)
                  obj.addHelp("size(m): " + dc(s.x / sf, 3) + " W, " + dc(s.y / sf, 3) + " L, " + dc(s.z / sf, 3) + " H");
                this.repaint = true;
              } else {
                obj.removeHelp();
              }
              return false;
            }
          }
          ;
          function onKeyUp(e) {
            if (e.which == ctrlKey || e.which == cmdKey)
              ctrlDown = false;
            if (e.which === shiftKey)
              shiftDown = false;
          }
          this.on("click", this.onClick);
          this.on("mousemove", this.onMouseMove);
          this.on("mouseout", this.onMouseOut);
          this.on("mousedown", this.onMouseDown);
          this.on("zoom", this.onZoom);
          this.on("zoomend", this.onZoom);
          document.addEventListener("keydown", onKeyDown.bind(this), true);
          document.addEventListener("keyup", onKeyUp.bind(this));
        });
      },
      //[jscastro] added property to manage an athmospheric sky layer
      get sky() {
        return this.options.sky;
      },
      set sky(value) {
        if (value) {
          this.createSkyLayer();
        } else {
          this.removeLayer(this.skyLayerName);
        }
        this.options.sky = value;
      },
      //[jscastro] added property to manage an athmospheric sky layer
      get terrain() {
        return this.options.terrain;
      },
      set terrain(value) {
        this.terrainLayerName = "";
        if (value) {
          this.createTerrainLayer();
        } else {
          if (this.mapboxVersion < 2) {
            console.warn("Terrain layer are only supported by Mapbox-gl-js > v2.0");
            return;
          }
          ;
          if (this.map.getTerrain()) {
            this.map.setTerrain(null);
            this.map.removeSource(this.terrainSourceName);
          }
        }
        this.options.terrain = value;
      },
      //[jscastro] added property to manage FOV for perspective camera
      get fov() {
        return this.options.fov;
      },
      set fov(value) {
        if (this.camera instanceof THREE2.PerspectiveCamera && this.options.fov !== value) {
          this.map.transform.fov = value;
          this.camera.fov = this.map.transform.fov;
          this.cameraSync.setupCamera();
          this.map.repaint = true;
          this.options.fov = value;
        }
      },
      //[jscastro] added property to manage camera type
      get orthographic() {
        return this.options.orthographic;
      },
      set orthographic(value) {
        const h = this.map.getCanvas().clientHeight;
        const w = this.map.getCanvas().clientWidth;
        if (value) {
          this.map.transform.fov = 0;
          this.camera = new THREE2.OrthographicCamera(w / -2, w / 2, h / 2, h / -2, 0.1, 1e21);
        } else {
          this.map.transform.fov = this.fov;
          this.camera = new THREE2.PerspectiveCamera(this.map.transform.fov, w / h, 0.1, 1e21);
        }
        this.camera.layers.enable(0);
        this.camera.layers.enable(1);
        this.cameraSync = new CameraSync(this.map, this.camera, this.world);
        this.map.repaint = true;
        this.options.orthographic = value;
      },
      //[jscastro] method to create an athmospheric sky layer
      createSkyLayer: function() {
        if (this.mapboxVersion < 2) {
          console.warn("Sky layer are only supported by Mapbox-gl-js > v2.0");
          this.options.sky = false;
          return;
        }
        ;
        let layer = this.map.getLayer(this.skyLayerName);
        if (!layer) {
          this.map.addLayer({
            "id": this.skyLayerName,
            "type": "sky",
            "paint": {
              "sky-opacity": [
                "interpolate",
                ["linear"],
                ["zoom"],
                0,
                0,
                5,
                0.3,
                8,
                1
              ],
              // set up the sky layer for atmospheric scattering
              "sky-type": "atmosphere",
              // explicitly set the position of the sun rather than allowing the sun to be attached to the main light source
              "sky-atmosphere-sun": this.getSunSky(this.lightDateTime),
              // set the intensity of the sun as a light source (0-100 with higher values corresponding to brighter skies)
              "sky-atmosphere-sun-intensity": 10
            }
          });
          this.map.once("idle", () => {
            this.setSunlight();
            this.repaint();
          });
        }
      },
      //[jscastro] method to create a terrain layer
      createTerrainLayer: function() {
        if (this.mapboxVersion < 2) {
          console.warn("Terrain layer are only supported by Mapbox-gl-js > v2.0");
          this.options.terrain = false;
          return;
        }
        ;
        let layer = this.map.getTerrain();
        if (!layer) {
          this.map.addSource(this.terrainSourceName, {
            "type": "raster-dem",
            "url": "mapbox://mapbox.mapbox-terrain-dem-v1",
            "tileSize": 512,
            "maxzoom": 14
          });
          this.map.setTerrain({ "source": this.terrainSourceName, "exaggeration": this.terrainExaggeration });
          this.map.once("idle", () => {
            this.cameraSync.updateCamera();
            this.repaint();
          });
        }
      },
      // Objects
      sphere: function(options2) {
        this.setDefaultView(options2, this.options);
        return sphere(options2, this.world);
      },
      line,
      label,
      tooltip,
      tube: function(options2) {
        this.setDefaultView(options2, this.options);
        return tube(options2, this.world);
      },
      extrusion: function(options2) {
        this.setDefaultView(options2, this.options);
        return extrusion(options2);
      },
      Object3D: function(options2) {
        this.setDefaultView(options2, this.options);
        return Object3D(options2);
      },
      loadObj: async function loadObj(options2, cb) {
        this.setDefaultView(options2, this.options);
        if (options2.clone === false) {
          return new Promise(
            async (resolve) => {
              loader(options2, cb, async (obj) => {
                resolve(obj);
              });
            }
          );
        } else {
          let cache = this.objectsCache.get(options2.obj);
          if (cache) {
            cache.promise.then((obj) => {
              cb(obj.duplicate(options2));
            }).catch((err) => {
              this.objectsCache.delete(options2.obj);
              console.error("Could not load model file: " + options2.obj);
            });
          } else {
            this.objectsCache.set(options2.obj, {
              promise: new Promise(
                async (resolve, reject) => {
                  loader(options2, cb, async (obj) => {
                    if (obj.duplicate) {
                      resolve(obj.duplicate());
                    } else {
                      reject(obj);
                    }
                  });
                }
              )
            });
          }
        }
      },
      // Material
      material: function(o2) {
        return material(o2);
      },
      initLights: {
        ambientLight: null,
        dirLight: null,
        dirLightBack: null,
        dirLightHelper: null,
        hemiLight: null,
        pointLight: null
      },
      utils,
      SunCalc,
      Constants: ThreeboxConstants,
      projectToWorld: function(coords) {
        return this.utils.projectToWorld(coords);
      },
      unprojectFromWorld: function(v3) {
        return this.utils.unprojectFromWorld(v3);
      },
      projectedUnitsPerMeter: function(lat) {
        return this.utils.projectedUnitsPerMeter(lat);
      },
      //get the center point of a feature
      getFeatureCenter: function getFeatureCenter(feature, obj, level) {
        return utils.getFeatureCenter(feature, obj, level);
      },
      getObjectHeightOnFloor: function(feature, obj, level) {
        return utils.getObjectHeightOnFloor(feature, obj, level);
      },
      queryRenderedFeatures: function(point) {
        let mouse = new THREE2.Vector2();
        mouse.x = point.x / this.map.transform.width * 2 - 1;
        mouse.y = 1 - point.y / this.map.transform.height * 2;
        this.raycaster.setFromCamera(mouse, this.camera);
        let intersects = this.raycaster.intersectObjects(this.world.children, true);
        return intersects;
      },
      //[jscastro] find 3D object of a mesh. this method is needed to know the object of a raycasted mesh
      findParent3DObject: function(mesh) {
        var result;
        mesh.object.traverseAncestors(function(m) {
          if (m.parent) {
            if (m.parent.type == "Group" && m.userData.obj) {
              result = m;
            }
          }
        });
        return result;
      },
      //[jscastro] method to replicate behaviour of map.setLayoutProperty when Threebox are affected
      setLayoutProperty: function(layerId, name, value) {
        this.map.setLayoutProperty(layerId, name, value);
        if (value !== null && value !== void 0) {
          if (name === "visibility") {
            this.world.children.filter((o2) => o2.layer === layerId).forEach((o2) => {
              o2.visibility = value;
            });
          }
        }
      },
      //[jscastro] Custom Layers doesn't work on minzoom and maxzoom attributes, and if the layer is including labels they don't hide either on minzoom
      setLayerZoomRange: function(layerId, minZoomLayer, maxZoomLayer) {
        if (this.map.getLayer(layerId)) {
          this.map.setLayerZoomRange(layerId, minZoomLayer, maxZoomLayer);
          if (!this.zoomLayers.includes(layerId))
            this.zoomLayers.push(layerId);
          this.toggleLayer(layerId);
        }
      },
      //[jscastro] method to set the height of all the objects in a level. this only works if the objects have a geojson feature
      setLayerHeigthProperty: function(layerId, level) {
        let layer = this.map.getLayer(layerId);
        if (!layer)
          return;
        if (layer.type == "fill-extrusion") {
          let data = this.map.getStyle().sources[layer.source].data;
          let features = data.features;
          features.forEach(function(f) {
            f.properties.level = level;
          });
          this.map.getSource(layer.source).setData(data);
        } else if (layer.type == "custom") {
          this.world.children.forEach(function(obj) {
            let feature = obj.userData.feature;
            if (feature && feature.layer === layerId) {
              let location = this.tb.getFeatureCenter(feature, obj, level);
              obj.setCoords(location);
            }
          });
        }
      },
      //[jscastro] method to set globally all the objects that are fixedScale
      setObjectsScale: function() {
        this.world.children.filter((o2) => o2.fixedZoom != null).forEach((o2) => {
          o2.setObjectScale(this.map.transform.scale);
        });
      },
      //[jscastro] mapbox setStyle removes all the layers, including custom layers, so tb.world must be cleaned up too
      setStyle: function(styleId, options2) {
        this.clear().then(() => {
          this.map.setStyle(styleId, options2);
        });
      },
      //[jscastro] method to toggle Layer visibility checking zoom range
      toggleLayer: function(layerId, visible = true) {
        let l = this.map.getLayer(layerId);
        if (l) {
          if (!visible) {
            this.toggle(l.id, false);
            return;
          }
          let z = this.map.getZoom();
          if (l.minzoom && z < l.minzoom) {
            this.toggle(l.id, false);
            return;
          }
          ;
          if (l.maxzoom && z >= l.maxzoom) {
            this.toggle(l.id, false);
            return;
          }
          ;
          this.toggle(l.id, true);
        }
        ;
      },
      //[jscastro] method to toggle Layer visibility
      toggle: function(layerId, visible) {
        this.setLayoutProperty(layerId, "visibility", visible ? "visible" : "none");
        this.labelRenderer.toggleLabels(layerId, visible);
      },
      update: function() {
        if (this.map.repaint)
          this.map.repaint = false;
        var timestamp = Date.now();
        this.objects.animationManager.update(timestamp);
        this.updateLightHelper();
        this.renderer.resetState();
        this.renderer.render(this.scene, this.camera);
        this.labelRenderer.render(this.scene, this.camera);
        if (this.options.passiveRendering === false)
          this.map.triggerRepaint();
      },
      add: function(obj, layerId, sourceId) {
        if (!this.enableTooltips && obj.tooltip) {
          obj.tooltip.visibility = false;
        }
        ;
        this.world.add(obj);
        if (layerId) {
          obj.layer = layerId;
          obj.source = sourceId;
          let l = this.map.getLayer(layerId);
          if (l) {
            let v = l.visibility;
            let u = typeof v === "undefined";
            obj.visibility = u || v === "visible" ? true : false;
          }
        }
      },
      removeByName: function(name) {
        let obj = this.world.getObjectByName(name);
        if (obj)
          this.remove(obj);
      },
      remove: function(obj) {
        if (this.map.selectedObject && obj.uuid == this.map.selectedObject.uuid)
          this.map.unselectObject();
        if (this.map.draggedObject && obj.uuid == this.map.draggedObject.uuid)
          this.map.draggedObject = null;
        if (obj.dispose)
          obj.dispose();
        this.world.remove(obj);
        obj = null;
      },
      //[jscastro] this clears tb.world in order to dispose properly the resources
      clear: async function(layerId = null, dispose = false) {
        return new Promise((resolve, reject) => {
          let objects = [];
          this.world.children.forEach(function(object) {
            objects.push(object);
          });
          for (let i = 0; i < objects.length; i++) {
            let obj = objects[i];
            if (obj.layer === layerId || !layerId) {
              this.remove(obj);
            }
          }
          if (dispose) {
            this.objectsCache.forEach((value) => {
              value.promise.then((obj) => {
                obj.dispose();
                obj = null;
              });
            });
          }
          resolve("clear");
        });
      },
      //[jscastro] remove a layer clearing first the 3D objects from this layer in tb.world
      removeLayer: function(layerId) {
        this.clear(layerId, true).then(() => {
          this.map.removeLayer(layerId);
        });
      },
      //[jscastro] get the sun position (azimuth, altitude) from a given datetime, lng, lat
      getSunPosition: function(date, coords) {
        return SunCalc.getPosition(date || Date.now(), coords[1], coords[0]);
      },
      //[jscastro] get the sun times for sunrise, sunset, etc.. from a given datetime, lng, lat and alt
      getSunTimes: function(date, coords) {
        return SunCalc.getTimes(date, coords[1], coords[0], coords[2] ? coords[2] : 0);
      },
      //[jscastro] set shadows for fill-extrusion layers
      setBuildingShadows: function(options2) {
        if (this.map.getLayer(options2.buildingsLayerId)) {
          let layer = new BuildingShadows(options2, this);
          this.map.addLayer(layer, options2.buildingsLayerId);
        } else {
          console.warn("The layer '" + options2.buildingsLayerId + "' does not exist in the map.");
        }
      },
      //[jscastro] This method set the sun light for a given datetime and lnglat
      setSunlight: function(newDate = /* @__PURE__ */ new Date(), coords) {
        if (!this.lights.dirLight || !this.options.realSunlight) {
          console.warn("To use setSunlight it's required to set realSunlight : true in Threebox initial options.");
          return;
        }
        var date = new Date(newDate.getTime());
        if (coords) {
          if (coords.lng && coords.lat)
            this.mapCenter = coords;
          else
            this.mapCenter = { lng: coords[0], lat: coords[1] };
        } else {
          this.mapCenter = this.map.getCenter();
        }
        if (this.lightDateTime && this.lightDateTime.getTime() === date.getTime() && this.lightLng === this.mapCenter.lng && this.lightLat === this.mapCenter.lat) {
          return;
        }
        this.lightDateTime = date;
        this.lightLng = this.mapCenter.lng;
        this.lightLat = this.mapCenter.lat;
        this.sunPosition = this.getSunPosition(date, [this.mapCenter.lng, this.mapCenter.lat]);
        let altitude = this.sunPosition.altitude;
        let azimuth = Math.PI + this.sunPosition.azimuth;
        let radius = ThreeboxConstants.WORLD_SIZE / 2;
        let alt = Math.sin(altitude);
        let altRadius = Math.cos(altitude);
        let azCos = Math.cos(azimuth) * altRadius;
        let azSin = Math.sin(azimuth) * altRadius;
        this.lights.dirLight.position.set(azSin, azCos, alt);
        this.lights.dirLight.position.multiplyScalar(radius);
        this.lights.dirLight.intensity = Math.max(alt, 0);
        this.lights.hemiLight.intensity = Math.max(alt * 1, 0.1);
        this.lights.dirLight.updateMatrixWorld();
        this.updateLightHelper();
        if (this.map.loaded()) {
          this.updateSunGround(this.sunPosition);
          this.map.setLight({
            anchor: "map",
            position: [3, 180 + this.sunPosition.azimuth * 180 / Math.PI, 90 - this.sunPosition.altitude * 180 / Math.PI],
            intensity: Math.cos(this.sunPosition.altitude),
            //0.4,
            color: `hsl(40, ${50 * Math.cos(this.sunPosition.altitude)}%, ${Math.max(20, 20 + 96 * Math.sin(this.sunPosition.altitude))}%)`
          }, { duration: 0 });
          if (this.sky) {
            this.updateSunSky(this.getSunSky(date, this.sunPosition));
          }
        }
      },
      getSunSky: function(date, sunPos) {
        if (!sunPos) {
          var center = this.map.getCenter();
          sunPos = this.getSunPosition(
            date || Date.now(),
            [center.lng, center.lat]
          );
        }
        var sunAzimuth = 180 + sunPos.azimuth * 180 / Math.PI;
        var sunAltitude = 90 - sunPos.altitude * 180 / Math.PI;
        return [sunAzimuth, sunAltitude];
      },
      updateSunSky: function(sunPos) {
        if (this.sky) {
          this.map.setPaintProperty(this.skyLayerName, "sky-atmosphere-sun", sunPos);
        }
      },
      updateSunGround: function(sunPos) {
        if (this.terrainLayerName != "") {
          this.map.setPaintProperty(this.terrainLayerName, "raster-opacity", Math.max(Math.min(1, sunPos.altitude * 4), 0.25));
        }
      },
      //[jscastro] this updates the directional light helper
      updateLightHelper: function() {
        if (this.lights.dirLightHelper) {
          this.lights.dirLightHelper.position.setFromMatrixPosition(this.lights.dirLight.matrixWorld);
          this.lights.dirLightHelper.updateMatrix();
          this.lights.dirLightHelper.update();
        }
      },
      //[jscastro] method to fully dispose the resources, watch out is you call this without navigating to other page
      dispose: async function() {
        console.log(this.memory());
        return new Promise((resolve) => {
          resolve(
            this.clear(null, true).then((resolve2) => {
              this.map.remove();
              this.map = {};
              this.scene.remove(this.world);
              this.world.children = [];
              this.world = null;
              this.objectsCache.clear();
              this.labelRenderer.dispose();
              console.log(this.memory());
              this.renderer.dispose();
              return resolve2;
            })
          );
        });
      },
      defaultLights: function() {
        this.lights.ambientLight = new THREE2.AmbientLight(new THREE2.Color("hsl(0, 0%, 100%)"), 0.75);
        this.scene.add(this.lights.ambientLight);
        this.lights.dirLightBack = new THREE2.DirectionalLight(new THREE2.Color("hsl(0, 0%, 100%)"), 0.25);
        this.lights.dirLightBack.position.set(30, 100, 100);
        this.scene.add(this.lights.dirLightBack);
        this.lights.dirLight = new THREE2.DirectionalLight(new THREE2.Color("hsl(0, 0%, 100%)"), 0.25);
        this.lights.dirLight.position.set(-30, 100, -100);
        this.scene.add(this.lights.dirLight);
      },
      realSunlight: function(helper = false) {
        this.renderer.shadowMap.enabled = true;
        this.lights.dirLight = new THREE2.DirectionalLight(16777215, 1);
        this.scene.add(this.lights.dirLight);
        if (helper) {
          this.lights.dirLightHelper = new THREE2.DirectionalLightHelper(this.lights.dirLight, 5);
          this.scene.add(this.lights.dirLightHelper);
        }
        let d2 = 1e3;
        let r2 = 2;
        let mapSize2 = 8192;
        this.lights.dirLight.castShadow = true;
        this.lights.dirLight.shadow.radius = r2;
        this.lights.dirLight.shadow.mapSize.width = mapSize2;
        this.lights.dirLight.shadow.mapSize.height = mapSize2;
        this.lights.dirLight.shadow.camera.top = this.lights.dirLight.shadow.camera.right = d2;
        this.lights.dirLight.shadow.camera.bottom = this.lights.dirLight.shadow.camera.left = -d2;
        this.lights.dirLight.shadow.camera.near = 1;
        this.lights.dirLight.shadow.camera.visible = true;
        this.lights.dirLight.shadow.camera.far = 4e8;
        this.lights.hemiLight = new THREE2.HemisphereLight(new THREE2.Color(16777215), new THREE2.Color(16777215), 0.6);
        this.lights.hemiLight.color.setHSL(0.661, 0.96, 0.12);
        this.lights.hemiLight.groundColor.setHSL(0.11, 0.96, 0.14);
        this.lights.hemiLight.position.set(0, 0, 50);
        this.scene.add(this.lights.hemiLight);
        this.setSunlight();
        this.map.once("idle", () => {
          this.setSunlight();
          this.repaint();
        });
      },
      setDefaultView: function(options2, defOptions) {
        options2.bbox = (options2.bbox || options2.bbox == null) && defOptions.enableSelectingObjects;
        options2.tooltip = (options2.tooltip || options2.tooltip == null) && defOptions.enableTooltips;
        options2.mapScale = this.map.transform.scale;
      },
      memory: function() {
        return this.renderer.info.memory;
      },
      programs: function() {
        return this.renderer.info.programs.length;
      },
      version: "2.2.7"
    };
    var defaultOptions = {
      defaultLights: false,
      realSunlight: false,
      realSunlightHelper: false,
      passiveRendering: true,
      preserveDrawingBuffer: false,
      enableSelectingFeatures: false,
      enableSelectingObjects: false,
      enableDraggingObjects: false,
      enableRotatingObjects: false,
      enableTooltips: false,
      enableHelpTooltips: false,
      multiLayer: false,
      orthographic: false,
      fov: ThreeboxConstants.FOV_DEGREES,
      sky: false,
      terrain: false
    };
    module.exports = exports = Threebox;
  }
});

// node_modules/threebox-plugin/main.js
var require_main = __commonJS({
  "node_modules/threebox-plugin/main.js"(exports, module) {
    module.exports = exports = {
      Threebox: require_Threebox(),
      THREE: require_three()
    };
  }
});
export default require_main();
/*! Bundled license information:

threebox-plugin/src/three.js:
  (**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

threebox-plugin/src/objects/fflate.min.js:
  (*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=threebox-plugin.js.map
